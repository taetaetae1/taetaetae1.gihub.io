<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>꿈꾸는 태태태의 공간</title>
  
  <subtitle>taetaetae</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://taetaetae.github.io/"/>
  <updated>2019-10-27T15:25:54.090Z</updated>
  <id>https://taetaetae.github.io/</id>
  
  <author>
    <name>taetaetae</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  <image>
    <url>
      https://taetaetae.github.io/assets/images/profile.png
    </url>
  </image>
  
  <entry>
    <title>개발하기 바쁜데 글까지 쓰라고? (글쓰는 개발자가 되자.)</title>
    <link href="https://taetaetae.github.io/2019/10/27/a-reason-for-writing/"/>
    <id>https://taetaetae.github.io/2019/10/27/a-reason-for-writing/</id>
    <published>2019-10-27T04:51:16.000Z</published>
    <updated>2019-10-27T15:25:54.090Z</updated>
    
    <content type="html"><![CDATA[<p>신입시절. 배워야 할 것도 회사 업무도 많아 허우적대던 때가 있었다. 그렇게 하루에 3~4시간 자며 정신없이 하루를 보내던 날 문득 동기 형이 “개발자는 기술 블로그를 해야 돼!”라는 전혀 이해가 안 되는 말을 해온다. 이렇게 바빠 죽겠는데 블로그에 글까지 쓰라고? <a id="more"></a>말이 되는 소릴 하라며 반박하다 못내 이기는 척 하나 둘 글을 쓰기 시작했고, 다른 유명 블로거처럼 엄청나진 않지만 하루에 1,000~2,000명 정도 들어오며 점점 성장해 가는 나만의 기술 블로그가 되었다. </p><div class="figure center" style="width:;"><a class="fancybox" href="blog_graph.jpg" title="미약하지만 처음보다는 성장하고 있는 블로그 PV(Page View)" data-caption="미약하지만 처음보다는 성장하고 있는 블로그 PV(Page View)" data-fancybox="default"><img class="fig-img" src="blog_graph.jpg" alt="미약하지만 처음보다는 성장하고 있는 블로그 PV(Page View)"><span class="image-caption">미약하지만 처음보다는 성장하고 있는 블로그 PV(Page View)</span></a><span class="caption">미약하지만 처음보다는 성장하고 있는 블로그 PV(Page View)</span></div><div style="clear:both;"></div><p>또한 필자의 개발자 경력(?)을 돌이켜 보자면 기술 블로그를 하기 전과 하고 난 후로 나뉠 만큼 기술 블로그는 개인적으로 엄청난 영향력이 되었다.</p><blockquote><p>이 기회를 빌어 동기 형에게 감사의 인사를 전하고 싶다. 형. 보고 있죠? ;]</p></blockquote><p>이번 포스팅은 꼭 “블로그를 하자” 라기 보다 “글을 왜 써야 하고 어떻게 써야 하는지”에 대해 이야기해보고자 한다. 처음 이 글을 쓰려고 마음먹었을 땐 개발자라는 직군에 국한되지 않고 누구에게나 적용될 정도의 범용적인 글을 쓰려 했으나 “S”의 조언으로 독자(타깃)을 최대한 개발자에 맞춰 써보고자 한다. thanks to “S”<br>사실 조금만 검색을 해보면 특히 개발자에게 글쓰기가 얼마나 중요한지 찾아볼 수 있을 정도로 다양한 글들에서 “개발자가 왜 글을 써야 하는가”에 대한 내용이 언급이 되곤 했었다. 글을 쓰지 않던 개발자. 하지만 지금은 글쓰기가 정말 중요하다고 느끼며 적어도 2주에 하나 이상의 글을 쓰려는 현업 개발자의 시선에서 정리를 해보고자 한다.<br>그리고 마침 멘토링 해주고 있는 분께도 글 쓰는것에 대한 중요성을 알려주고 싶었고, 팀 내에도 공유를 하고 싶어 겸사겸사.</p><h2 id="왜-글을-써야-할까"><a href="#왜-글을-써야-할까" class="headerlink" title="# 왜 글을 써야 할까?"></a># 왜 글을 써야 할까?</h2><h5 id="✓-비로소-내-것이-되기-위한-과정"><a href="#✓-비로소-내-것이-되기-위한-과정" class="headerlink" title="✓ 비로소 내 것이 되기 위한 과정"></a>✓ 비로소 내 것이 되기 위한 과정</h5><p>프로그래밍 언어를 처음 배울때 꼭 만나는 문구 <code>Hello World를 출력하시오</code>. 이게 의미하는 의미가 무엇일까? 정말 새로운 세계를 알려주려 하는 것 일까?(그럴수도 있다…) 우리가 살아가며 “배움”이라는 과정은 대부분 비슷하겠지만 특히 IT 기술은 책을 다 읽었다든지, 동영상 강의를 다 들었다고 해서 내 것이 되었다고 말하기는 어려울 것 같다. 직접 키보드를 두드려 가며 거기서 얻을 수 있는 또 다른 “인사이트” 가 생길 수도 있기 때문이다.<br>다른 예로, 운영하던 시스템이나 서비스에서 장애를 맞았다고 가정해보자. 하지만 우리는 늘 그래왔듯 어떻게든 장애를 해결할 것이다. 이러한 상황에서 분명 “문제의 원인”이 있었을 테고 “해결 과정”이 있기 마련인데 이곳에서도 “인사이트”가 분명 있을 것이다.<br>이러한 “인사이트”를 글로 적다 보면 그냥 “아~ 그렇구나, 그랬었지” 하는 머릿속에서의 기억보다는 훨씬 더 오래 남을 것이고 혹여 글에서 정리를 잘못해 다른 사람들의 피드백이 있다면 더할 나위 없이 좋은 효과라고 생각이 된다. (이것이 바로 공유의 힘!)<br>더불어 글을 쓸 때 올바른 정보에 기반하여 쓰는 습관이 중요한데 그러다 보면 원래 쓰려고 했던 내용보다 더 깊게 알아가는 과정 속에서 또 다른 배움을 얻을 수 있는 반강제적 기회가 생길 수 있다. 누가 시키지 않았어도 배운 것에 대한 활용을 하고 싶은 생각이 들고 이를 또 글로 쓰고. 긍정적인 순환 속에 생겨나는 작은 발자국일지라도 성장해가는 자신을 느낄 수 있을 것이다.</p><h5 id="✓-몸이-기억하는-정리하는-습관"><a href="#✓-몸이-기억하는-정리하는-습관" class="headerlink" title="✓ 몸이 기억하는 정리하는 습관"></a>✓ 몸이 기억하는 정리하는 습관</h5><p>개발을 하다 보면 정말 간단한 “CRUD”(Create, Read, Update, Delete) 부터 시작해서 엄청나게 복잡한 도메인 지식에 기반하여 개발을 해야 하는 상황이 생긴다. 그럴 때면 머릿속으로 정리하는 것보다 그림이나 글을 써가면서 정리하는 게 좋다는 건 굳이 말하지 않아도 아는 사실. 글을 쓰다 보면 기승전결의 정리 방법과 목적이 무엇이고 근거가 무엇인지에 대해 구분하는 스킬이 늘어나는 것 같다.(적어도 필자는 기술 블로그를 운영하면서 정리하는 스킬이 그전보다 엄청나게 늘어났다고 자부한다.)<br><div class="figure center" style="width:;"><a class="fancybox" href="ink.jpg" title="중국 속담중에 하나, 머릿속에 박혀 나오질 않는다." data-caption="중국 속담중에 하나, 머릿속에 박혀 나오질 않는다." data-fancybox="default"><img class="fig-img" src="ink.jpg" alt="중국 속담중에 하나, 머릿속에 박혀 나오질 않는다."><span class="image-caption">중국 속담중에 하나, 머릿속에 박혀 나오질 않는다.</span></a><span class="caption">중국 속담중에 하나, 머릿속에 박혀 나오질 않는다.</span></div><div style="clear:both;"></div><br>구조가 보기 어렵게 꼬여버린 스파게티 코드나 기능(스펙)이 너무 복잡한 도메인 지식도 글을 쓰며 갈고닦은 “정리 스킬”이 있다면 보다 깔끔한 코드로, 복잡하지만 간결한 스펙으로 정리하는 데 도움이 될 수 있다. 이러한 스킬은 비단 개발할 때나 스펙 정리할 때 뿐만 아니라 상대방과의 이야기를 할 때나 어떠한 계획을 세울 때. 고민이 생겼을 때 등 정말 다양한 곳에서 사용할 수 있는 정말 “나만의 무기”가 될 수 있다.</p><h5 id="✓-나를-브랜딩하는-수단-a-k-a-기술블로그"><a href="#✓-나를-브랜딩하는-수단-a-k-a-기술블로그" class="headerlink" title="✓ 나를 브랜딩하는 수단 (a.k.a 기술블로그)"></a>✓ 나를 브랜딩하는 수단 (a.k.a 기술블로그)</h5><p>특히 이 글을 읽고 있는 독자가 학생이시라면 “글쓰기”, 나아가서는 “기술 블로그”를 강력 추천하고 싶다. (그렇다고 학생이 아니라면 늦었다는 소리는 아니다. 지금 당장 시작하자.)<br><div class="figure center" style="width:;"><a class="fancybox" href="park.jpg" title="늦었으니 지금당장 시작하라는 소리일꺼다. 그쵸 명수형? <br>출처 : http://blog.besunny.com/?p=6111" data-caption="늦었으니 지금당장 시작하라는 소리일꺼다. 그쵸 명수형? <br>출처 : http://blog.besunny.com/?p=6111" data-fancybox="default"><img class="fig-img" src="park.jpg" alt="늦었으니 지금당장 시작하라는 소리일꺼다. 그쵸 명수형? <br>출처 : http://blog.besunny.com/?p=6111"><span class="image-caption">늦었으니 지금당장 시작하라는 소리일꺼다. 그쵸 명수형? <br>출처 : http://blog.besunny.com/?p=6111</span></a><span class="caption">늦었으니 지금당장 시작하라는 소리일꺼다. 그쵸 명수형? <br>출처 : http://blog.besunny.com/?p=6111</span></div><div style="clear:both;"></div><br>자신이 어떤 생각을 가지고 어떤 기술에 관심을 가지며 어떤 문제 해결을 해왔는지에 대해 나만의 개발 히스토리로 한눈에 볼 수 있는 수단이 된다고 생각하기 때문이다. 참, 요즘 채용시에 Github 계정이나 기술 블로그를 제출해야 하는 곳이 많이 생길 정도로 기술 블로그에 대한 관심이 부쩍 늘어난 것 같다. (적어도 필자가 취업할 때보다는… 아. 옛날이여)<br>필자는 기술 블로그를 운영하면서 집필, 추천평 등 전혀 예상하지 못한 경험을 할 수 있었다. (그중에 한 것도 있고 거절한 것도 있지만…) 그에 발표를 할 수 있었던 좋은 기회도 생겼고, 개인 메일로 이직 제안이나 기술 문의 등 “회사”라는 명찰을 떼고 외부에서 오롯이 나 혼자 일어설 수 있는 힘이 조금씩 생겨나고 있는것 같다. (그렇다고 이직 의사가 있다는 건 전~혀 아니니 오해는 말자. 회사님 사랑해요.)<br>취업이나 이직을 할 때. 나에 대해 누군가에게 알리는 순간이 있을 때 구구절절 이런저런 기술들을 할 줄 알고 이런저런 경험을 해봤어요라고 말하는 것도 방법이 될수 있지만 우아하게 기술 블로그 링크하나 딱! 전달해 보는건 어떨까? 뭔가 더 있어 보이지 않을까?</p><h3 id="글을-쓸때-중요한-핵심-6가지"><a href="#글을-쓸때-중요한-핵심-6가지" class="headerlink" title="# 글을 쓸때 중요한 핵심 6가지"></a># 글을 쓸때 중요한 핵심 6가지</h3><h5 id="✓-그래서-너가-말하고-싶은게-뭔데"><a href="#✓-그래서-너가-말하고-싶은게-뭔데" class="headerlink" title="✓ 그래서 너가 말하고 싶은게 뭔데?"></a>✓ 그래서 너가 말하고 싶은게 뭔데?</h5><p>글을 쓰다 보면 이야기하고 싶은 게 많아서(잘 쓰고 싶어서) 결론보다는 그 결론을 말하기 위한 보충 설명이나 근거를 먼저 말하곤 한다. 하지만 글을 읽는 독자 입장에서는 정답(=결론)이 가장 궁금한데 그것이 글의 말미에 있다면 자칫 글의 퀄리티가 아무리 좋더라도 지루한(?) 과정을 거치는 수고가 필요할 수밖에 없다. 가급적 글의 무게중심은 서두에 두는 게 “글”이라는 목적에 부합하는 것 같다. 결론을 앞에서 이야기하고 근거를 이야기한 후 마지막에 한 번 더 결론을 이야기하는 것도 하나의 방법이 될 수 있겠다.<br>그래도 뚜렷한 결론이 있다면 다행이다. 결론마저 없는 글은 독자로 하여금 왜 글을 썼는지 모를 느낌을 안겨줄 수 있다.(최악의 경우 읽다가 중단하게 된다…ㅜㅜ) 글쓰기에 있어 결론도 중요하지만 이 글을 쓰는 목적이 명확해야 설령 목표가 글 뒤에 배치되었다고 해도 끝까지 읽을 수 있는 힘이 생기지 않을까?<br><div class="figure center" style="width:;"><a class="fancybox" href="kimchi.jpg" title="반전에 반전을 거듭하며 결론을 도무지 알수없는 레파토리는 김치싸대기를 던지던 아침 드라마가 어울린다.<br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14289808&memberNo=12508720" data-caption="반전에 반전을 거듭하며 결론을 도무지 알수없는 레파토리는 김치싸대기를 던지던 아침 드라마가 어울린다.<br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14289808&memberNo=12508720" data-fancybox="default"><img class="fig-img" src="kimchi.jpg" alt="반전에 반전을 거듭하며 결론을 도무지 알수없는 레파토리는 김치싸대기를 던지던 아침 드라마가 어울린다.<br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14289808&memberNo=12508720"><span class="image-caption">반전에 반전을 거듭하며 결론을 도무지 알수없는 레파토리는 김치싸대기를 던지던 아침 드라마가 어울린다.<br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14289808&memberNo=12508720</span></a><span class="caption">반전에 반전을 거듭하며 결론을 도무지 알수없는 레파토리는 김치싸대기를 던지던 아침 드라마가 어울린다.<br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14289808&memberNo=12508720</span></div><div style="clear:both;"></div></p><h5 id="✓-누가-읽게-되는-글인가"><a href="#✓-누가-읽게-되는-글인가" class="headerlink" title="✓ 누가 읽게 되는 글인가?"></a>✓ 누가 읽게 되는 글인가?</h5><p>글을 쓰는 사람(필자)이 있으면 글을 읽는 사람(독자)이 있기 마련. 대부분의 글들은 필자가 독자를 “설득”하기 위한 내용이 주를 이룬다. 독자가 한정적이라면. 예컨대, 주간 보고를 쓴다고 가정했을 때 독자는 오롯이 팀장님이 된다. 이런 경우 주저리주저리 쓰거나 다시 한번 묻게 되는 문장들보다는 팀장님이 정말 궁금해할 내용을 적어주는 게 좋다. 한 번 더 안 물어볼 수 있게 작성한 글을 팀장님의 위치에서 다시 한번 읽어보는 것도 하나의 방법이 될 수 있다.<br>만약 독자의 스펙트럼이 넓거나 기술 블로그처럼 불특정 다수라면 가장 지식이 없는 사람에게 쓰는 것처럼 글을 써보자. 가끔 너무 쉽고 자세히 써서 당신이 아마추어처럼 보일 것 같다는 우려를 할 수도 있다. 하지만 지금 글을 쓰는 당신이 적어도 글을 안 쓰고 읽기만 하는 독자보다는 가장 프로에 가깝다.<br>독자가 다 알 거라는 생각은 하지 말자. 최대한 쉽게. 처음 보는 사람도 보고 따라 하거나 이해가 되도록 눈높이를 낮춰서 쓰는 습관을 길러보자. 무려 당신의 글을 시간을 할애하면서까지 읽어주는데 최대한 친절해야 하지 않을까?</p><h5 id="✓-앵무새가-되지-말자"><a href="#✓-앵무새가-되지-말자" class="headerlink" title="✓ 앵무새가 되지 말자."></a>✓ 앵무새가 되지 말자.</h5><p>링크만 복붙하거나 소위 말해 펌 글, 정작 내용은 없고 코드만 덩그러니 있거나 단순히 “글쓰기”를 위해 쓰는 글들은 오히려 안 쓰는게 좋다.<br>글에는 자신만의 생각이 녹아있어야 한다고 생각한다. 그렇지 않고서는 따라쟁이 앵무새와 다를 게 없다. 어떠한 오픈소스를 도입하는 과정을 글로 썼다고 생각해보자. Step By Step으로 따라 할 수 있게 작성한 글일지라도 최소한 마지막에는 자신만의 생각이 정리되어 있어야 글을 쓰는 자신도, 글을 읽는 독자도 “마무리”가 될 수 있기 때문이다. 왜 오픈소스를 도입하게 되었고, 도입하는 과정에서의 문제, 도입하고 나서의 장점과 단점 등 이야기할 거리는 무궁무진하다.</p><h5 id="✓-글쓰기에도-호흡이-중요"><a href="#✓-글쓰기에도-호흡이-중요" class="headerlink" title="✓ 글쓰기에도 호흡이 중요"></a>✓ 글쓰기에도 호흡이 중요</h5><p>TV나 인터넷 영상들을 보고 있노라면 편집의 기술이 엄청나게 발전된 것을 체감할 수 있다. 혹시 체감하지 못했다면 화면의 전환이나 자막 등 너무 자연스러워서일 수 있다. 글쓰기에서도 이러한 전환이나 문장의 흐름, 호흡은 정말 중요하다.<br>이러한 글쓰기에서의 호흡은 문장 쪼개기, 단락 구분하기, 적절한 그림 및 표 활용 등 독자가 읽을 때 지루하지 않을 정도의 말 그대로 “숨 쉴 수 있는 타이밍”을 제공해야 한다. 읽을 때 집중이 잘 안되거나 어디까지 읽었지 하며 흐름이 끊긴 경우를 경험해 봤을 거라 생각이 든다. 사실 이 부분은 필자도 잘 안되긴 하지만 이번 포스팅처럼 말하고자 하는 메인 키워드 단위로 나눈다거나 약간의 위트를 더하기 위한 짤 같은 것도 이러한 “호흡”의 기술이라 생각한다.</p><h5 id="✓-퇴고-글쓰기의-가장-중요한-단계"><a href="#✓-퇴고-글쓰기의-가장-중요한-단계" class="headerlink" title="✓ 퇴고. 글쓰기의 가장 중요한 단계"></a>✓ 퇴고. 글쓰기의 가장 중요한 단계</h5><p>지금 이 글을 쓰는 순간에도 퇴고를 10번 이상 하는 것 같다. 필자가 생각하는 퇴고라 함은 쓴 글의 처음부터 끝까지 읽어보며 맞춤법이나 띄어쓰기 교정, 실제로 소리 내어 읽어보며 숨이 차거나 집중이 흐려지진 않은지 하는 일련의 과정을 말한다.<br>퇴고를 꼭 몇번 해야 한다는 정해진 규칙은 없지만 최소 3번은 하는 것 같다. 그러면서 더 중요한 것을 위로 올리고 불필요하게 글자 수만 늘린 건 없는지. 글의 목적과는 거리가 있는 문장은 없는지 등 우리가 서비스를 출시하기 위해 개발 환경에서 테스트를 하고 QA 단계를 거쳐 최종 운영환경에 릴리즈 하는것 처럼.<br>글쓰기는 말하고자 하는 것을 “텍스트”로 전달하는 아주 기본적이며 제한적인 수단이기 때문에 몇 번이고 읽어보면서 고칠 수 있는 부분은 최대한 고치자. 그러면서 글을 썼던 자신을 되돌아보며 무슨 생각으로 이런 글을 썼나 돌아보는 기회도 되고.</p><h5 id="✓-나만의-글쓰기-플랫폼을-찾자"><a href="#✓-나만의-글쓰기-플랫폼을-찾자" class="headerlink" title="✓ 나만의 글쓰기 플랫폼을 찾자."></a>✓ 나만의 글쓰기 플랫폼을 찾자.</h5><p>정말 다양한 글쓰기 플랫폼이 있다. Github, 네이버 블로그, 티스토리, 워드프레스 등 서버호스팅 비용 없이도 무료로 제공해주는 곳들인데 각 플랫폼 마다의 장단점이 있으니 자신에게 맞는 곳을 찾아서 글을 써보자. 특히 Github 블로그는 정말 다양한 방법으로 블로그를 만들 수 있고 테마 또한 무궁무진하며 웹에 대한 지식이 있다면 얼마든지 커스터마이징이 가능하다.<br>블로그를 만들었으면 검색에 잘 되도록 SEO 설정을 해두고 RSS를 만들어 국내 기술블로그를 모아둔 <a href="https://github.com/sarojaba/awesome-devblog" target="_blank" rel="noopener">awesome-devblog</a>에 자신의 블로그 정보에 대해 PullRequest를 날려보자. 그러면 필자가 만든 <a href="http://daily-devblog.com" target="_blank" rel="noopener">기술블로그 구독서비스</a>에서 여러 사람들에게 매일 오전 10시에 친절하게, 그것도 무료로 홍보를 해주기 때문이다. (갑 분 서비스 홍보, 후원좀…)<br>GA(Google Analytics)를 붙여 어디서 유입되고 얼마나 들어오는지 보는 재미도 쏠쏠하다. 필자도 처음엔 많아야 10명(그게 전부 필자였다는건 비밀)이었지만 점점 방문자수가 늘어나니 글을 좀더 재미있고 잘 써야겠다는 사명감과 책임감도 생겨서 초창기에 썼던 글과 요즘의 글을 비교를 해보면 글의 퀄리티가 훨씬 늘어난것 같다.</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><div class="figure center" style="width:;"><a class="fancybox" href="cyworld.jpg" title="무엇을 말하려는지의 글쓴이의 목적은 충분히 전달되었다. 오글거림도 함께. <br>출처 : http://m.news.zum.com/articles/25408896" data-caption="무엇을 말하려는지의 글쓴이의 목적은 충분히 전달되었다. 오글거림도 함께. <br>출처 : http://m.news.zum.com/articles/25408896" data-fancybox="default"><img class="fig-img" src="cyworld.jpg" alt="무엇을 말하려는지의 글쓴이의 목적은 충분히 전달되었다. 오글거림도 함께. <br>출처 : http://m.news.zum.com/articles/25408896"><span class="image-caption">무엇을 말하려는지의 글쓴이의 목적은 충분히 전달되었다. 오글거림도 함께. <br>출처 : http://m.news.zum.com/articles/25408896</span></a><span class="caption">무엇을 말하려는지의 글쓴이의 목적은 충분히 전달되었다. 오글거림도 함께. <br>출처 : http://m.news.zum.com/articles/25408896</span></div><div style="clear:both;"></div><p>우리는 사실 어렸을때부터 글쓰기를 해왔다. 어렸을적 그림일기부터 시작하여 사랑하는 사람에게 손편지를 쓰고 싸이월드에 흑역사를 만들었던 시절들. 개발자가 된, 혹은 이제 개발자가 되려는 사람들이 있다면 그냥 글이 아닌 자신이 가지고 있는 기술에 대한 글을 써보는건 어떨까. Stack Overflow Driven Development (SODD) 라는 말이 있듯이 개발은 사실 엄청난 성능과 최적의 알고리즘을 요하는게 아니라면 개발자 간의 경쟁력은 일반적인 개발실력 이외엔 시간과 경험의 차이인것 같다. 여기에 글쓰기 연습을 하며 보다 논리적이고 정리하는 습관을 기른다면 이또한 남들과는 다른 나만의 무기가 될수 있지 않을까 하는 생각을 해본다.<br>이 글을 읽는 독자분들 중 자신만의 기술블로그가 없다면 지금 당장이라도 시작하라고 권하고 싶다. 첫 시작은 어렵겠지만 자신만의 스타일로 “글쓰는 개발자”가 되는데 건투를 빈다.</p><hr><p># 참고<br><a href="https://www.44bits.io/ko/post/8-suggestions-for-tech-programming-blog" target="_blank" rel="noopener">좋은 기술 블로그를 만들어 나가기 위한 8가지 제언</a><br><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=13673719" target="_blank" rel="noopener">강원국의 글쓰기 : 남과 다른 글은 어떻게 쓰는가</a><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;신입시절. 배워야 할 것도 회사 업무도 많아 허우적대던 때가 있었다. 그렇게 하루에 3~4시간 자며 정신없이 하루를 보내던 날 문득 동기 형이 “개발자는 기술 블로그를 해야 돼!”라는 전혀 이해가 안 되는 말을 해온다. 이렇게 바빠 죽겠는데 블로그에 글까지 쓰라고?
    
    </summary>
    
      <category term="blog" scheme="https://taetaetae.github.io/categories/blog/"/>
    
    
      <category term="writing" scheme="https://taetaetae.github.io/tags/writing/"/>
    
      <category term="blog" scheme="https://taetaetae.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>더이상 기다리지 않아도 되는 배치 무중단 배포</title>
    <link href="https://taetaetae.github.io/2019/10/13/batch-nondisruptive-deploy/"/>
    <id>https://taetaetae.github.io/2019/10/13/batch-nondisruptive-deploy/</id>
    <published>2019-10-13T06:46:12.000Z</published>
    <updated>2019-11-04T01:03:44.746Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://taetaetae.github.io/2019/09/29/woowabros-spring-batch/">지난 포스팅</a>, 그러니까 우아한 형제들에서 초대를 받아 Spring batch 에 대한 테크세미나에 다녀 왔다. 그 중 가장 인상깊었던 부분이 바로 <code>무중단 배포</code>. 차일피일 미루다 필자가 속한 팀에서도 배포때마다 가장 불편을 느끼고 있었던 부분이었기도 했고<a id="more"></a>, <code>그런가보다</code> 하며 개념만 알고 넘어가기엔 무언가 양심에 찔려 직접 무중단 배포를 할 수 있도록 구성을 해보고 테스트까지 해보고자 한다.</p><h3 id="상황-및-문제점"><a href="#상황-및-문제점" class="headerlink" title="# 상황 및 문제점"></a># 상황 및 문제점</h3><p>리눅스 서버에 Jenkins가 설치되어 있고, Spring batch 모듈을 실행시키고 있다. 수동으로 실행을 하거나, Jenkins RestApi를 이용해서 실행을 할 수 있지만 주로 정해진 시간 즉, 스케쥴링에 의해 실행되곤 한다. 스케쥴링의 가장 작은 단위는 1분단위 배치도 있기 때문에 24시간 멈추지 않고 실행되고 있다고 무방하다. 하지만 배치 모듈이 수정되고, 배포를 하기 위해서는 다음과 같은 시나리오로 진행이 된다.</p><ol><li>Jenkins 설정의 <code>끄기전 준비</code> 를 실행하여 더이상 Jenkins에 의해 Spring batch 모듈(이하 Job)이 실행되지 않도록 한다.</li><li>새로운 Job은 더이상 실행되지 않지만 이미 실행중이였던 Job 은 강제로 중단을 하거나 Job 이 끝날때까지 기다린다.</li><li>실행중인 Job이 없을 경우 이제 배포를 진행한다.</li><li>배포가 완료되면 Jenkins 설정의 <code>끄기전 준비</code>를 해제한다.</li></ol><div class="figure center" style="width:;"><a class="fancybox" href="wait.jpg" title="실행중인 Job이 안끝나면 마냥 기다릴텐가? <br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14100660&memberNo=2032633" data-caption="실행중인 Job이 안끝나면 마냥 기다릴텐가? <br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14100660&memberNo=2032633" data-fancybox="default"><img class="fig-img" src="wait.jpg" alt="실행중인 Job이 안끝나면 마냥 기다릴텐가? <br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14100660&memberNo=2032633"><span class="image-caption">실행중인 Job이 안끝나면 마냥 기다릴텐가? <br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14100660&memberNo=2032633</span></a><span class="caption">실행중인 Job이 안끝나면 마냥 기다릴텐가? <br>출처 : https://m.post.naver.com/viewer/postView.nhn?volumeNo=14100660&memberNo=2032633</span></div><div style="clear:both;"></div><p>실행되는 Job을 중단하지 못하는 상황 즉, 실행중에 중단하면 트랜잭션이 깨져 무조건 기다려야만 하는 상황이라면 배포 또한 계속 지연될 수 밖에 없는 상황인 것이다. Spring boot에 java config 를 활용하고 딱 <code>jar</code> 파일 하나를 실행하는 방식이라면 <code>jar</code>파일을 바꿔치기 하는 식으로 고민을 해볼수도 있을것 같다. 하지만 Legacy 코드가 아직 존재하여 일반 Spring 에 xml 로 config 하는 방식으로 운영중이라 <code>jar</code>파일 하나만 바꿔치기 하기엔 무리가 있는 상황. </p><p>은총알처럼 어디에서나 사용이 가능한 만병통치약 같은 방법은 없다. 언제나 그랬듯 현재 시스템(xml config 방식)에 가장 최적화된 방법, 그리고 java config 방식에서도 사용이 가능할것 같은 방법을 생각해 보았다.</p><h3 id="무중단-배포를-가능케-하는-3가지-핵심"><a href="#무중단-배포를-가능케-하는-3가지-핵심" class="headerlink" title="# 무중단 배포를 가능케 하는 3가지 핵심"></a># 무중단 배포를 가능케 하는 3가지 핵심</h3><p><strong>1. 배포를 매번 새로운 경로에 배포한다.</strong><br>각 회사마다, 그리고 서비스마다 정말 다양한 배포 시스템이 있다. 그들의 공통점은 원격서버의 <code>특정 경로</code>에 빌드된 파일들을 밀어 넣어준다는 것. 시나리오는 다음과 같다.</p><ol><li>배포할때마다 별도의 디렉토리를 생성한뒤 심볼릭 링크를 연결해준다.</li><li>배포는 <code>1</code>에서 연결한 심볼릭 링크에 배포되도록 설정, 결국 매번 만들어지는 디렉토리에 배포가 되게 된다.</li></ol><p>여기서 중요한점은 “배포할 때마다 새로운 디렉토리에 배포가 된다” 와 배포시에는 항상 심볼릭 링크에만 배포를 하면 되기 때문에 “배포시스템이 새로 만들어지는 디렉토리의 경로를 몰라도 무방하다”는 점이다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> /~~~/deploy/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임시 디렉토리</span></span><br><span class="line">DIRECTORY_NAME=batch_$(/bin/date +%Y%m%d%H%M%S)</span><br><span class="line">mkdir <span class="variable">$DIRECTORY_NAME</span></span><br></pre></td></tr></table></figure></p><p>위 쉘 스크립트를 실행하면 batch_20191012205218 와 같은 디렉토리가 생성이 된다. 심볼릭 링크 관련해서는 바로 아래 이어서 설명하겠다.</p><p><strong>2. 심볼릭 링크의 원래 링크를 즉시 변경</strong><br>보통 심볼릭 링크 (즉, 바로가기) 의 경로를 변경하기 위해서는 아래처럼 지웠다가 삭제하는 식으로 했었는데<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir directory_a</span><br><span class="line">$ mkdir directory_b</span><br><span class="line">$ ln -s directory_a asdf</span><br><span class="line">$ ll</span><br><span class="line">asdf -&gt; directory_a</span><br><span class="line">directory_a</span><br><span class="line">directory_b</span><br><span class="line"></span><br><span class="line"><span class="comment"># directory_a 에서 directory_b 로 바꾸는 경우 (심볼릭 링크 자체를 삭제하고 다시 심볼릭 링크 생성)</span></span><br><span class="line">$ rm asdf</span><br><span class="line">$ ln -s directory_b asdf</span><br><span class="line">$ ll</span><br><span class="line">asdf -&gt; directory_b</span><br><span class="line">directory_a</span><br><span class="line">directory_b</span><br></pre></td></tr></table></figure></p><p>이렇게 되면 삭제하고 ~ 다시 만들어지는 타이밍에 배포가 되거나 실행이 되는 즉, 해당 경로에 엑세스 하는 경우 이전의 경로를 바라본다거나 의도했던 방식으로 실행이 되지 않는 상황이 발생한다. (찰나의 타이밍 이지만 필자는 이러한 문제로 이전의 경로를 바라보는 문제가 발생했었다.) 그래서 ln 의 옵션중인 <code>-Tfs</code>옵션으로 즉시 변경을 해주도록 하자. (<a href="https://linux.die.net/man/1/ln" target="_blank" rel="noopener">ln man 참고</a>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 만든 임시 디렉토리로 배포될수 있도록 설정한다.</span></span><br><span class="line">ln -Tfs /deploy/<span class="variable">$DIRECTORY_NAME</span> /~~~/deploy/batch</span><br></pre></td></tr></table></figure></p><p><strong>3. 심볼릭 링크가 가리키는 원래 링크에서 실행</strong><br>리눅스 명령어 중에 <a href="https://linux.die.net/man/1/readlink" target="_blank" rel="noopener">readlink</a>라는게 있다. 실제 링크를 얻어오는 명령어 인데 이를 활용하여 위에서 설정해둔 심볼릭 링크의 실제 링크(최신 배포된 경로)를 가져오고 그곳에서 Spring batch 모듈을 실행하는 식으로 구성을 해보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">BASEDIR=`readlink -f $(dirname <span class="variable">$0</span>)` <span class="comment"># -f 옵션 : 전체경로</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$BASEDIR</span> <span class="comment"># 이후 Spring batch jar 실행</span></span><br></pre></td></tr></table></figure></p><p>이렇게 되면 Job이 실행중이라도 기존에 실행중인 Job은 기존 모듈을 바라보고 실행이 되고, 도중에 새로 배포가 되어도 기존 실행되는 Job에는 영향을 주지 않으며(심볼릭 링크에 연결되었던 과거 배포 경로에서 실행되고 있기 때문) 새롭게 배포된 후 Job이 실행될때도 배포된 경로의 &gt; 심볼릭 링크의 &gt; 실제 링크 즉, 새롭게 배포된 경로에서 실행되기 때문에 무중단 배포가 가능하게 된다.</p><h3 id="전체-흐름"><a href="#전체-흐름" class="headerlink" title="# 전체 흐름"></a># 전체 흐름</h3><p>핵심만 설명하다보니 전체적으로 어떻게 돌아가는지 이해를 못하셨을 분들을 위해 전체 흐름에 대해 설명을 해보고자 한다.<br><strong>1. 배포 전</strong><br>  임시 디렉토리를 생성하고, 그곳에 배포가 될 수 있도록 심볼릭 링크를 연결해준다.<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> /~~~/deploy/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 임시 디렉토리</span></span><br><span class="line">DIRECTORY_NAME=batch_$(/bin/date +%Y%m%d%H%M%S)</span><br><span class="line">mkdir <span class="variable">$DIRECTORY_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 만든 임시 디렉토리로 배포될수 있도록 설정한다.</span></span><br><span class="line">ln -Tfs /~~~/deploy/<span class="variable">$DIRECTORY_NAME</span> /~~~/deploy/batch</span><br></pre></td></tr></table></figure></p><p><strong>2. 배포</strong><br>  배포 시스템에 의해 <code>/~~~/deploy/batch</code> 로 배포되도록 한다.</p><p><strong>3. 배포 후</strong><br>  이후 배포 실행은 새롭게 배포된 경로에서 실행되도록 심볼릭 링크를 수정해준다.<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> /~~~/deploy/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 배포된 경로를 실행할 경로로 변경해준다.</span></span><br><span class="line">REAL_DIRECTORY_PATH=$(readlink -f /~~~/deploy/batch)</span><br><span class="line">ln -Tfs <span class="variable">$REAL_DIRECTORY_PATH</span> /~~~/deploy/batch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예전에 배포된 폴더들을 삭제해준다. (최근 몇개까지만 지울것인가는 상황에 따라)</span></span><br></pre></td></tr></table></figure></p><p><strong>4. 배치 실행</strong><br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">BASEDIR=`readlink -f $(dirname <span class="variable">$0</span>)` <span class="comment"># -f 옵션 : 전체경로</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$BASEDIR</span> <span class="comment"># 이후 배치 실행 ( e.g. batch.jar xxxJob )</span></span><br></pre></td></tr></table></figure></p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p><code>jar</code>파일이 실행되고 <code>JVM</code>에 올라가게 되면 <code>jar</code>파일을 삭제한다거나 위치를 이동시켜도 에러가 나거나 하지는 않지만 코드 내에서 상대경로같은 설정들이 있기 때문에 폴더 전체를 심볼릭 링크로 연결하고 그 안에서 실행되도록 수정하였다. 앞서 이야기 했지만 이러한 설계는 어디까지나 필자가 운영하고 있는 상황에 맞춘것이기 때문에 이를 어떻게 잘 <code>활용</code>하는가가 이번 포스팅에 주요 핵심이 될 수 있을것 같다.<br>항상 배포 할때마다 <code>예전에 그렇게 해왔기 때문에</code> 라는 핑계로 Job이 돌고있으면 기다렸다가 배포해야만 했던 필자 자신이 부끄러워진다. 시도조차 안해보고 그런가보다 하고 적응만 하려 하거나, 불편하지만 안불편한척 하는 그런 태도를 버려야 하지 않을까 하는 반성을 해보는 시간이 되었다.<br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://taetaetae.github.io/2019/09/29/woowabros-spring-batch/&quot;&gt;지난 포스팅&lt;/a&gt;, 그러니까 우아한 형제들에서 초대를 받아 Spring batch 에 대한 테크세미나에 다녀 왔다. 그 중 가장 인상깊었던 부분이 바로 &lt;code&gt;무중단 배포&lt;/code&gt;. 차일피일 미루다 필자가 속한 팀에서도 배포때마다 가장 불편을 느끼고 있었던 부분이었기도 했고
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="jenkins" scheme="https://taetaetae.github.io/tags/jenkins/"/>
    
      <category term="linux" scheme="https://taetaetae.github.io/tags/linux/"/>
    
      <category term="batch" scheme="https://taetaetae.github.io/tags/batch/"/>
    
  </entry>
  
  <entry>
    <title>우아한 스프링 배치 테크세미나 정리 및 후기 (by 우아한 형제들)</title>
    <link href="https://taetaetae.github.io/2019/09/29/woowabros-spring-batch/"/>
    <id>https://taetaetae.github.io/2019/09/29/woowabros-spring-batch/</id>
    <published>2019-09-29T08:55:50.000Z</published>
    <updated>2019-09-30T04:22:41.750Z</updated>
    
    <content type="html"><![CDATA[<p>지난주 우아한 형제들에서 진행하였던 “9월 우아한 테크 세미나 - 우아한 스프링 배치” 에 다녀왔다. 필자에게 이번 9월은 정신이 어디에 있는지 모를만큼 바쁘고 힘들었지만 예전부터 궁금하기도 했고 <a id="more"></a>요즘들어 관심을 갖던 “배치 어플리케이션”을 어떻게 하면 “우아한 방법”으로 사용할 수 있을지에 대해 여러 생각들이 있었기에 큰 기대를 가지고 지옥철을 견디며 잠실 근처에 있는 우아한 형제들 작은집으로 가게 되었다.<br>어떤 내용을 발표하였는지에 대해 <code>기억잘하는 똑똑한 앵무새</code>가 되어 정리하기 보다 주요 포인트에 대한 생각과 함께 참여를 못한 분들 위해서라기 보다 내 스스로 정리를 하기 위해 포스팅을 작성해 보고자 한다.<br>(이번에도 불러주셔서 감사합니다 ^=^)</p><h3 id="인트로"><a href="#인트로" class="headerlink" title="# 인트로"></a># 인트로</h3><p>연사자 분은 워낙에 유명하신 분이라 별도의 설명이 필요 없이 운영하시는 <a href="https://jojoldu.tistory.com" target="_blank" rel="noopener">블로그 주소</a>로 대체를 해본다. 이번 행사에 초대되신 분들은 한번이라도 스프링 배치를 써분 분들을 대상으로 진행하게 되었다고 했는데 마침 필자도 팀 내에서 운영하고 있는 배치 어플리케이션을 보다 효율적이고 우아하게 바꿔보고자 하는 니즈가 있었기에 아마 초대된게 아닐까 싶다.<br><div class="figure center" style="width:;"><a class="fancybox" href="small_house.jpg" title="아기자기한 우아한 형제들 건물 내부" data-caption="아기자기한 우아한 형제들 건물 내부" data-fancybox="default"><img class="fig-img" src="small_house.jpg" alt="아기자기한 우아한 형제들 건물 내부"><span class="image-caption">아기자기한 우아한 형제들 건물 내부</span></a><span class="caption">아기자기한 우아한 형제들 건물 내부</span></div><div style="clear:both;"></div></p><p>더불어 발표전에 간략히 회사가 원하는 인재에 대하여 언급해주셨는데 그게 어찌나 공감이 가던지. 역시 생각이 남다른 회사구나 하고 다시한번 생각을.</p><blockquote><p>자기보다 경험이 “적은” 사람에게 “설득을 당할 수” 있어야 하고, 자기보다 경험이 “많은 사람을 설득” 시킬 수 있어야 한다.</p></blockquote><h3 id="기본편"><a href="#기본편" class="headerlink" title="# 기본편"></a># 기본편</h3><p>배치 어플리케이션이란 컴퓨터에서 사람와 상호작용없이 이어지는 프로그램(작업)들의 실행이라고 <a href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B4%84_%EC%B2%98%EB%A6%AC" target="_blank" rel="noopener">위키피디아</a>에 간결&amp;명료하게 정리되어 있다. 그만큼 일반적인 웹 어플리케이션과의 차이가 있는데 웹 어플리케이션은 실시간 처리가 기본이고 요청에 대한 응답을 제공해야 하니 아무래도 속도가 상대적이며 QA시 편한 부분이 있다. 그에 반해 배치 어플리케이션은 웹 어플리케이션에서 말하는 요청이라는 개념보다 후속처리에 가깝고, 속도 또한 절대적이며 QA가 복잡하다는게 특징이다. 따라서 테스트코드는 웹 어플리케이션 보다 배치 어플리케이션이 더 필요하다고 볼 수 있다.<br>배치 어플리케이션이 필요한 상황은 크게 두가지로 나눠 볼 수가 있다고 한다.</p><ul><li>일정 주기로 실행 되어야 할 때</li><li>실시간 처리가 어려운 대량의 데이터를 처리 할때</li></ul><p>평소 첫번째 상황만 생각하고 배치 어플리케이션을 작성하곤 했었는데 두번재 상황에 대해 생각에 생각을 더 해보니 스프링 배치를 간단하게만 (Tasklet) 사용하고 있는건 아닌가 하는 반성을 해보곤 했다. (Reader, Processor, Writer 등 다양한 레이어가 있는데도…)</p><p>특히 스프링 배치에서는 기본적으로 모든 데이터를 메모리에 쌓지 않는 조회방식라고 한다. (DB기준) Paging 혹은 Cursor로 pageSize만큼만 읽어오고 chunkSize만큼만 commit 하는 형태. 이러한 각 레이어별 size를 잘 조정하기만 해도 적은 노력으로 큰 성능을 얻을 수 있는 부분이 프레임워크를 사용하는 이유 아닐까 라고 생각해본다.</p><p>또한 <code>@JobScope</code> 나 <code>@StepScope</code>는 Late Binding 즉 배치 어플리케이션이 실행되는 시점이 아니라 Job 이 실행될때 생성이 되기 때문에 이를 활용하여 동적으로 reader / processor / wirter 레이어를 만들 수 있다고 한다.</p><h3 id="활용편"><a href="#활용편" class="headerlink" title="# 활용편"></a># 활용편</h3><p>스프링 배치를 이용한 배치 어플리케이션이 있고 이를 스케쥴링 등 관리를 해주는 도구들에 이야기를 해주셨다. </p><ul><li>Cron<ul><li>리눅스를 어느정도 사용해봤다면 알만한 리눅스 기본 스케쥴링 프로그램인 Cron.</li><li>필자도 Cron 으로 주기적으로 실행하도록 설정해보기도 하였지만 배치 어플리케이션의 특성상 로그 및 실행/종료 등 제한사항이 많은 건 사실인것 같다.</li></ul></li><li>Spring MVC + API Call<ul><li>주변에서 사용하고 있다고 하던 방식. 이 방식의 장점은 항상 떠있기 때문에 어플리케이션 구동시간이 별도로 필요 없다는 장점이 있지만 전반적인 관리가 어려운 단점이 있는것 같다.</li><li>물론 울며 겨자먹기 식으로 단점을 극복할 방법은 여러가지가 있겠지만 모든건 항상 Trade off</li></ul></li><li>Spring Batch Admin (Deprecated)<ul><li>예전 팀분이 알려주셔서 잠깐 봤던 부분이긴 한데 어느사이에 Deprecated 되었다고 한다. </li></ul></li><li>Quertz + Admin<ul><li><a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">http://www.quartz-scheduler.org/</a></li><li>아주 오래전에 써본 기억이 있지만 배보다 배꼽이 더 큰 상황같았던 힘들었던 기억들만 남아있는 구현방법인것 같다. 여러 레이어를 혼용해서 쓰다보면 각 레이어간의 상호 연결성의 위배되는 경우가 많기에…</li></ul></li><li>CI Tools (Jenkins / Teamcity 등)<ul><li>아무래도 가장 추천할만한게 CI Tool 인것 같다. 그중에 필자도 Jenkins라는 툴을 너무 좋아하고.</li><li>유료 툴 중에 Teamcity 를 잠깐 언급해주셨는데 찾아보니 한번즈음 써보고 싶을만한 기능들이 있어보였다.</li></ul></li></ul><p>Jenkins 의 장점은 <del>말해뭐해</del> 정도로 배치 어플리케이션과 궁합이 너무 잘 맞는 툴인것 같다. (물론 다른 툴들도 있겠지만 필자<code>개취</code>라 넘어가도록 하자.) 특히 실행시 필요한 플러그인들이 다양하게 많이 있고, 실행방법 또한 수동/스케쥴링 으로 다양하게 할 수가 있으며 RestAPI 지원과 보안, 실행이력관리, 로그 등 최적화 되어있다고 해도 과언이 아닐정도로 다양한 장점들이 있는것 같다.</p><p>Jenkins 설정중에 Global properteis 을 통해 환경변수를 설정하는것도 가능하다고 설명해 주셨다. 또한 환경변수들의 묶음을 다시 환경변수로 재 정의해서 사용할 수 도 있고. 참 대단한 Jenkins. 필자는 이제까지 하나의 쉘스크립트를 만들고 공통으로 사용할 파라미터들을 스크립트 단에서 설정후에 Jenkins 에서 쉘스크립트를 실행하는 방식으로 구성하곤 하였는데 이렇게 Jenkins 의 환경변수를 이용하는 방법도 다른 측면에서 활용범위가 높을것 같아 좋아보였다.</p><p>무중단 배포에 대해 설명을 해주셨다. 이는 사실 스프링배치 나 Jenkins 와는 관련이 없지만 이 둘을 사용하면서 배포를 할때 리눅스의 명령어니 <code>readlink</code>와 <code>ln -s</code>를 활용하여 중단없이 배포를 할 수 있도록 한다고 한다. 필자는 이제까지 Jenkins의 <code>끄기전 준비</code>를 실행 하고 스케쥴러에 의해 다음 Job이 실행되지 않는것을 확인 후에 배포를 하곤 했었는데 이러한 기능을 통해 충분히 무중단 배포를 구성 해볼수도 있을껏 같았다. 이 부분은 별도의 포스팅으로 정리를 해볼까 한다.</p><div class="figure center" style="width:;"><a class="fancybox" href="seminar.jpg" title="정말 중요한 Jenkins의 장점과 멱등성" data-caption="정말 중요한 Jenkins의 장점과 멱등성" data-fancybox="default"><img class="fig-img" src="seminar.jpg" alt="정말 중요한 Jenkins의 장점과 멱등성"><span class="image-caption">정말 중요한 Jenkins의 장점과 멱등성</span></a><span class="caption">정말 중요한 Jenkins의 장점과 멱등성</span></div><div style="clear:both;"></div><p><code>멱등성</code>에 대해 설명해 주셨다. 필자도 같은 생각인데 배치 어플리케이션을 구성하면서 가장 중요시 생각해야할 개념이 <code>멱등성</code>인것 같다. 우선 <code>멱등성</code>이란 연산을 여러번 적용 하더라도 결과가 달라지지 않는 성질을 의미하는데 코드 내에 <code>LocalDateTime.now()</code>같은게 있다면 과거 기준으로 실행하고 싶어도 해당 코드로 인해 수정/배포를 하지 않고서는 할 수 없는 경우가 생기는것 같다. 그래서 제어할수 없는 코드는 제어할 수 있도록 파라미터를 받아 처리하는 형식으로 구성해야 좀더 효율적으로 실행할 수 있는 것 같다.</p><p>배치 어플리케이션에 대한 책을 추천해주셨다. <a href="https://www.apress.com/gp/book/9781484237236" target="_blank" rel="noopener">The Definitive Guide to Spring Batch</a>와 내년 상반기에 책을 출간할 예정이라고 하시는데 꼭 들여다 보고 싶을 책인것 같다. (국내 최초 스프링 배치에 대한 내용의 책!)</p><h3 id="오늘의-질문"><a href="#오늘의-질문" class="headerlink" title="# 오늘의 질문"></a># 오늘의 질문</h3><p>이번에도 어김없이 이 시간을 내것으로 만들기 위해 질문을 하였다. 이 세미나에 온 목적이기도 하다.<br>젠킨스로 스케쥴링을 하고, jar를 실행시켜 젠킨스에 로깅을 남기는게 일반적인것 실행방식 같은데 그러다보면 jar실행시 job과 관련없는 bean들이 뜨다보니 실행시간이 느려진다. 이부분은 어떻게 해소할수 있을까?<br>​라는 질문에 <code>@ConditionalOnProperty</code> 어노테이션을 활용하게되면 해당 Job 에서 필요한 bean 만 띄울수 있다고 하셨다.<br>필자가 운영하고 있는 스프링 배치 버전이 3.x 이기도 하고 멀티 모듈로 구성되어 있으며 (batch가 단독 컴포넌트가 아님…) 필요한 bean만을 지정하기에는 스파게티 코드가 될게 뻔한 상황인것 같아 질문의 답변에서 해법을 찾기에는 조금 힘들었지만 또 언제나 그랬듯 이러한 상황에서 해결방법을 찾아야 하는게 개발자의 숙명 아니겠는가. 좀더 고민해봐야할 부분인것 같다.</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>스프링 배치에 대한 기본개념과 관리도구를 활용해서 생생한 현장감과 함께 배치 어플리케이션의 운영 노하우를 들을 수 있어서 너무 좋았던 세미나였다. 이번에도 역시나 내가 고민하고 있던 문제는 누군가 이미 고민했던 문제라는것, 그리고 그러한 고민의 해결방법을 공유함에 있어 생겨나는 가치에 대해 다시한번 온몸으로 뜨거운 열정을 느낄수 있었던 날로 기억에 남을 것 같다.<br><div class="figure center" style="width:;"><a class="fancybox" href="think.gif" title="충분하면 만족해야만 할까?<br>출처 : https://vryjam.com/gif.php?id=ODWEBD0bmRGzTq5" data-caption="충분하면 만족해야만 할까?<br>출처 : https://vryjam.com/gif.php?id=ODWEBD0bmRGzTq5" data-fancybox="default"><img class="fig-img" src="think.gif" alt="충분하면 만족해야만 할까?<br>출처 : https://vryjam.com/gif.php?id=ODWEBD0bmRGzTq5"><span class="image-caption">충분하면 만족해야만 할까?<br>출처 : https://vryjam.com/gif.php?id=ODWEBD0bmRGzTq5</span></a><span class="caption">충분하면 만족해야만 할까?<br>출처 : https://vryjam.com/gif.php?id=ODWEBD0bmRGzTq5</span></div><div style="clear:both;"></div><br>다만, 이제까지 A라는 구조로 구성된 어플리케이션에 단순 기능 추가만 할게 아니라 정말 A라는 구조가 최선일까, A의 구조보다 보다 더 효율적이고 유연한 B 나 C 의 구조는 없을까 하는 이러한 고민을 계속 하려는 자세를 가져야 겠구나 하는 생각을 해본다.<br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;지난주 우아한 형제들에서 진행하였던 “9월 우아한 테크 세미나 - 우아한 스프링 배치” 에 다녀왔다. 필자에게 이번 9월은 정신이 어디에 있는지 모를만큼 바쁘고 힘들었지만 예전부터 궁금하기도 했고
    
    </summary>
    
      <category term="review" scheme="https://taetaetae.github.io/categories/review/"/>
    
    
      <category term="jenkins" scheme="https://taetaetae.github.io/tags/jenkins/"/>
    
      <category term="spring" scheme="https://taetaetae.github.io/tags/spring/"/>
    
      <category term="batch" scheme="https://taetaetae.github.io/tags/batch/"/>
    
  </entry>
  
  <entry>
    <title>네트워크 모니터링이 궁금할땐 ? Packetbeat !</title>
    <link href="https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/"/>
    <id>https://taetaetae.github.io/2019/09/08/network-monitor-by-packetbeat/</id>
    <published>2019-09-08T09:11:34.000Z</published>
    <updated>2019-09-08T16:24:02.633Z</updated>
    
    <content type="html"><![CDATA[<p>모니터링은 서비스 로직 개발 만큼 한번씩 고민해보고 경험해 봤을 중요한 영역이라 할 수 있다. 그중 웹서버에서 제공해주는 엑세스 로그는 운영하고 있는 웹서비스에 대해 여러가지 측면에서 분석할 수 있는 가장 강력한 아이템 중에 하나라고 생각한다. <a id="more"></a>이를 통해 사용자들이 어떤 url을 많이 호출하고, 어떤 user-agent형태를 사용하는지 알게 되면 그에 따라 서비스 전략을 변경할수도 있고 악의적으로 공격적인 요청에 대해 웹서버단에서 차단을 할 수 있기 때문이다.<br>이렇게 <code>inbound 트래픽(외부에서 들어오는 요청)</code>에 대해서는 엑세스 로그를 잘 분석하면 기존의 웹 어플리케이션과는 전혀 무관하게 모니터링이 가능하지만 반대로 <code>outbund 트래픽(외부로 나가는 요청)</code>에 대해서는 어떤식으로 모니터링을 할 수 있을까? </p><div class="figure center" style="width:;"><a class="fancybox" href="passbook.jpg" title="월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘...<br>이미지 출처 : https://www.app24moa.com/feedDetail/2/2002" data-caption="월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘...<br>이미지 출처 : https://www.app24moa.com/feedDetail/2/2002" data-fancybox="default"><img class="fig-img" src="passbook.jpg" alt="월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘...<br>이미지 출처 : https://www.app24moa.com/feedDetail/2/2002"><span class="image-caption">월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘...<br>이미지 출처 : https://www.app24moa.com/feedDetail/2/2002</span></a><span class="caption">월급통장의 inbound 트래픽보다 outbound 트래픽이 너무 많은 요즘...<br>이미지 출처 : https://www.app24moa.com/feedDetail/2/2002</span></div><p>예컨데, 날씨 서비스를 하기 위해 외부에서 <code>서울날씨</code>라는 페이지를 조회했을 경우 기상청 API에서 넘겨받은 데이터를 가공하여 보여준다고 가정해보자. 이때 기상청에서 제공해주는 특정 API중에 어느 하나가 늦게 응답이 온다거나, 특정시간대에 에러응답을 받을경우 과연 이를 어떤식으로 모니터링 할수 있을까? 어플리케이션 코드에 <code>모니터링을 위한 코드</code>를 추가할 것인가? 혹 하나의 서버에서 A모듈은 java로, B모듈은 python으로 개발되었을 경우 각각 모듈마다 모니터링을 위한 코드를 추가하는 식으로 하다보면 비지니스 로직을 방해하거나 오히려 추가한 코드 또한 관리해야 하는 배보다 배꼽이 더 커져버릴 상황도 생길수 있다.<br>어플리케이션의 비지니스 로직과는 무관하게 서버 자체에서 외부로 나가는 네트워크 트래픽에 대해 모니터링을 할 수 있는 <code>가벼우면서도 심플한 모듈</code>을 찾고 싶었다. 어플리케이션의 개발언어가 무엇이든 상관없이 별도의 에이전트 형식으로 띄워두기만 하면 네트워크 트래픽을 수집 및 분석, 나아가서는 모니터링까지 할수있는… 그래서 찾다보니 역시나 이러한 고민을 누군가는 하고 있었고 오픈소스까지 되어있는 Elastic Stack 의 Beat중 <code>Packetbeat</code>라는 데이터 수집모듈을 알게 되었다.</p><blockquote><p>역시 내가 하고있는 고민은 이미 누군가 했던 고민들… 이러한 고민에 대해 해결하는 방법을 보다 빨리 찾는게 경쟁력이 될텐데…</p></blockquote><p>이번 포스팅에서는 Packetbeat 에 대해 간단히 알아보고 이를 활용하여 outbound 트래픽에 대해 모니터링을 해보며 어떤식으로 활용할 수 있는지에 대해 알아보고자 한다.</p><h3 id="Packetbeat"><a href="#Packetbeat" class="headerlink" title="# Packetbeat ?"></a># Packetbeat ?</h3><p>ElasticStack 중에 데이터 수집기 플랫폼인 <code>Beats</code>중 네트워크 트래픽 데이터에 대해 수집을 할 수 있는 데이터 수집기를 제공하고 있다. <a href="https://ko.wikipedia.org/wiki/Pcap" target="_blank" rel="noopener">pcap</a>라이브러리를 이용하여 서버의 네트워크 레벨에서 데이터를 수집 및 분석한 후 외부로(Elasticsearch, Logstash, Kafka 등) 전송해주는 <code>경량 네트워크 패킷 분석기</code>라고 <a href="https://www.elastic.co/kr/products/beats/packetbeat" target="_blank" rel="noopener">공식 홈페이지</a>에 소개되고 있다.<br>몇번 사용해보면서 느낀 장점들은 다음과 같다.</p><ul><li>설치 및 실행이 너무 간단하다.</li><li>설정값 튜닝을 통해 간단하지만, 그러한 간단함에 비해서 너무 강력한 수집이 가능하다.</li><li>앞서 이야기 했던 어플리케이션 코드와는 전혀 무관하게 작동한다.</li></ul><h3 id="무엇을-해볼것인가-a-k-a-목표"><a href="#무엇을-해볼것인가-a-k-a-목표" class="headerlink" title="# 무엇을 해볼것인가?! (a.k.a. 목표)"></a># 무엇을 해볼것인가?! (a.k.a. 목표)</h3><p>필자가 운영하는 <a href="http://daily-devblog.com" target="_blank" rel="noopener">Daily-DevBlog</a> 라는 서비스가 있다. <del>(갑분 서비스 홍보)</del> 여러 사람들의 rss를 조회하고 파싱해서 메일을 보내주는 서비스 인데, packetbeat 사용 예시를 들기위해 조금 변형하여 모든 rss를 접근하고 가장 최신글의 제목을 출력하는 아주 간단한 python 스크립트로 outbound 트래픽을 발생시켜 보고자 한다.<br>그리고 packetbeat 를 이용하여 외부로 호출되는 트래픽을 수집하고 Elasticsearch 로 인덱싱 하여 최종적으로는 어느 rss의 속도가 가장 느린지 실행되는 python코드와는 전혀 관련없이 모니터링 해보고자 한다.<br>python 코드는 다음과 같다.</p><blockquote><p>참고로 필자는 <code>awesome-devblog</code>의 운영자분께 해당 데이터 사용에 대해 허락을 받은 상태이다.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, yaml, feedparser</span><br><span class="line"></span><br><span class="line">blog_info_list_yml_url = <span class="string">'https://raw.githubusercontent.com/sarojaba/awesome-devblog/master/db.yml'</span></span><br><span class="line">blog_info_list_yml = requests.get(url=blog_info_list_yml_url).text</span><br><span class="line">blog_info_yaml_parse_list = yaml.load(blog_info_list_yml)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> blog_info <span class="keyword">in</span> blog_info_yaml_parse_list :</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'rss'</span> <span class="keyword">not</span> <span class="keyword">in</span> blog_info.keys() <span class="keyword">or</span> <span class="keyword">not</span> blog_info[<span class="string">'rss'</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    rss_url = blog_info[<span class="string">'rss'</span>]</span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        parse_feed = feedparser.parse(rss_url)</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    parse_feed_data =  parse_feed.entries[<span class="number">0</span>]</span><br><span class="line">    print(blog_info[<span class="string">'name'</span>], <span class="string">'|'</span>, parse_feed_data[<span class="string">'title'</span>], <span class="string">'|'</span>, parse_feed_data[<span class="string">'link'</span>])</span><br></pre></td></tr></table></figure><p>위 코드를 실행하면 아래처럼 아주 간단하게 <code>블로그 주인의 이름</code>과 <code>최신글 제목</code>, <code>링크</code>가 출력이 된다.</p><div class="figure center" style="width:;"><a class="fancybox" href="rss_python_script.jpg" title="그러고 보니 너무 오랜만에 글쓰네... (숙연)" data-caption="그러고 보니 너무 오랜만에 글쓰네... (숙연)" data-fancybox="default"><img class="fig-img" src="rss_python_script.jpg" alt="그러고 보니 너무 오랜만에 글쓰네... (숙연)"><span class="image-caption">그러고 보니 너무 오랜만에 글쓰네... (숙연)</span></a><span class="caption">그러고 보니 너무 오랜만에 글쓰네... (숙연)</span></div><h3 id="백문이-불여일견-백견이-불여일타"><a href="#백문이-불여일견-백견이-불여일타" class="headerlink" title="# 백문이 불여일견? 백견이 불여일타!"></a># 백문이 불여일견? 백견이 불여일타!</h3><p>언제 어디서부터 유래된 이야기 인지는 모르지만 “백번 듣는것이 한번 보는것보다 못하고, 백번 보는것이 한번 타자 치는것보다 못하다” 라는 <code>개발버전</code> 속담이 있다. 자, 위에서 정의한 목표를 이루기 위해 실제로 각종 모듈을 설치해 보도록 하자! ( 필자가 테스트 했던 서버의 환경은 CentOS 7.4 64Bit 이니 참고 )</p><ul><li><p>Elasticsearch<br>  이왕 설치하는거 가장 최신버전인 7.3.1을 설치해보자! (버전업이 빨라도 너~무 빨라…)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 다운을 받고</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">// 압축을 푼다음</span><br><span class="line">tar -zxvf elasticsearch-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">cd elasticsearch-7.3.1/conf</span><br><span class="line">// 각종 설정후</span><br><span class="line">vi elasticsearch.yml</span><br><span class="line">node.name: node-1</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">discovery.seed_hosts: [&quot;localhost&quot;]</span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br><span class="line">// 실행</span><br><span class="line">bin/elasticsearch</span><br></pre></td></tr></table></figure><p>  <code>http://server-url:9200</code>접근시 아래처럼 나오면 설치 성공</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"node-1"</span>,</span><br><span class="line"><span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line"><span class="attr">"cluster_uuid"</span>: <span class="string">"---"</span>,</span><br><span class="line"><span class="attr">"version"</span>: &#123;</span><br><span class="line"><span class="attr">"number"</span>: <span class="string">"7.3.1"</span>,</span><br><span class="line">~~~</span><br><span class="line">&#125;,</span><br><span class="line">"tagline": "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Kibana</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 다운을 받고 </span><br><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">// 압축을 푼 다음</span><br><span class="line">tar -zxvf kibana-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">cd kibana-7.3.1-linux-x86_64/config</span><br><span class="line">   // 각종 설정후</span><br><span class="line">   vi kibana.yml</span><br><span class="line">server.host: &quot;~.~.~.~&quot;</span><br><span class="line">elasticsearch.hosts: [&quot;http://~.~.~.~:9200&quot;]</span><br><span class="line">// 실행</span><br><span class="line">bin/kibana</span><br></pre></td></tr></table></figure><p>  <code>http://server-url:5601</code>접근시 키바나 화면이 나오면 설치 성공</p></li><li><p>Packetbeat</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 다운을 받고</span><br><span class="line">wget https://artifacts.elastic.co/downloads/beats/packetbeat/packetbeat-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">// 압축을 푼 다음</span><br><span class="line">tar -zxvf packetbeat-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">// 각종 설정후 실행 (root 권한으로 실행해야 함)</span><br><span class="line">sudo chown root:root packetbeat.yml</span><br><span class="line">sudo vi packetbeat.yml</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  # Array of hosts to connect to.</span><br><span class="line">  hosts: [&quot;~.~.~.~:9200&quot;]</span><br><span class="line">sudo ./packetbeat -e -c packetbeat.yml</span><br></pre></td></tr></table></figure><p>  이렇게 하고나서 키바나에 가보면 아래처럼 Packetbeat 인덱스 패턴을 만들수 있고 수집이 되고있는것 까지 확인 가능하다.</p>  <div class="figure center" style="width:;"><a class="fancybox" href="packetbeat_es_kibana.jpg" title="데이터가 엄~청 다양하고 많이 수집된다." data-caption="데이터가 엄~청 다양하고 많이 수집된다." data-fancybox="default"><img class="fig-img" src="packetbeat_es_kibana.jpg" alt="데이터가 엄~청 다양하고 많이 수집된다."><span class="image-caption">데이터가 엄~청 다양하고 많이 수집된다.</span></a><span class="caption">데이터가 엄~청 다양하고 많이 수집된다.</span></div></li></ul><h3 id="무엇을-모니터링-할-수-있을까"><a href="#무엇을-모니터링-할-수-있을까" class="headerlink" title="# 무엇을 모니터링 할 수 있을까?"></a># 무엇을 모니터링 할 수 있을까?</h3><p>이제 각종 구성은 했으니 처음에 목표한 <code>어느 rss가 가장 느린가</code>를 체크해 볼 시간이다. python 스크립트를 돌리면 packetbeat 에 의해 네트워크 트래픽이 수집~분석~Elasticsearch에 인덱싱이 되고 이를 키바나의 비쥬얼라이즈를 통해 적절하게 만들어보면 아래처럼 너무나도 간단하게 어느 rss의 응답속도가 가장 느린지 확인할 수 있다. <code>event.duration</code> 필드는 기본적으로 nano second 이다보니 아래 그림에서는 2.6초가 가장 오래걸린 rss url 이라 볼 수 있다.<br><div class="figure center" style="width:;"><a class="fancybox" href="visualize.jpg" title="보라, 키바나의 강력한 비쥬얼라이즈 기능을! (아 눈부셔)" data-caption="보라, 키바나의 강력한 비쥬얼라이즈 기능을! (아 눈부셔)" data-fancybox="default"><img class="fig-img" src="visualize.jpg" alt="보라, 키바나의 강력한 비쥬얼라이즈 기능을! (아 눈부셔)"><span class="image-caption">보라, 키바나의 강력한 비쥬얼라이즈 기능을! (아 눈부셔)</span></a><span class="caption">보라, 키바나의 강력한 비쥬얼라이즈 기능을! (아 눈부셔)</span></div></p><p>한가지 더, packetbeat를 설치하고 기본 설정으로 실행하게 되면 불필요한(outbound 트래픽만을 수집하겠다던 목표와는 무관한) 데이터들도 수집되다보니 아무래도 cpu에 불필요한 부하가 발생할수 있고(아무래도 모든 네트워크 트래픽을 트래킹 하고 분석해야하니…) Elasticsearch 에도 불필요한 데이터가 인덱싱 되곤 한다. 그래서 지금의 Packetbeat 뿐만 아니라 오픈소스를 사용할 경우엔 설정값들을 정확히 알고 목적에 맞는 커스터마이징은 필수인듯 하다. 필자는 http의 outbound 트래픽만을 보고 싶었기 때문에 아래처럼 packetbeat 설정을 하고 다시 실행 해보면 Elasticsearch 에 수집되는 도큐먼트 사이즈가 확연하게 차이나는 것을 확인할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">packetbeat.protocols: # 아래 2개 이외에는 전부 주석처리</span><br><span class="line">- type: http</span><br><span class="line">  ports: [80] # 80 port 의 http를 수집하겠다.</span><br><span class="line">- type: tls</span><br><span class="line">  ports:</span><br><span class="line">     - 443   # 443 의 tls를 수집하겠다.</span><br><span class="line"></span><br><span class="line">processors:</span><br><span class="line">  - drop_event.when.equals.network.direction : &quot;inbound&quot; # inbound는 수집하지 않겠다.</span><br></pre></td></tr></table></figure></p><div class="figure center" style="width:;"><a class="fancybox" href="packetbeat_config.jpg" title="좌측이 기본, 우측이 불필요 데이터 제외하고 나서의 수집 상태" data-caption="좌측이 기본, 우측이 불필요 데이터 제외하고 나서의 수집 상태" data-fancybox="default"><img class="fig-img" src="packetbeat_config.jpg" alt="좌측이 기본, 우측이 불필요 데이터 제외하고 나서의 수집 상태"><span class="image-caption">좌측이 기본, 우측이 불필요 데이터 제외하고 나서의 수집 상태</span></a><span class="caption">좌측이 기본, 우측이 불필요 데이터 제외하고 나서의 수집 상태</span></div><p>사실 위 설정값은 <a href="https://www.facebook.com/groups/elasticsearch.kr/permalink/2384124035006756/" target="_blank" rel="noopener">페이스북 한국 Elasticsearch 유저그룹</a>에 문의해서 알게된 내용이다. 역시 커뮤니티 파워, 집단지성의 힘을 다시한번 느낄 수 있었다. (모르면 물어보자! + 문제에 대해 좀더 잘 검색하도록 노력하자!)</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>Packetbeat 을 사용하면서 가장 좋았던 점은 기존 로직과는 전혀 무관하게 작동하는 점이 가장 좋았다. 이러한 점은 어느 상황에서도 서비스 코드 디펜던시가 없어 자유롭게 활용이 가능하다는 뜻으로 해석을 해보곤 한다.<br><div class="figure center" style="width:;"><a class="fancybox" href="angry.jpg" title="마냥 좋다고 운영환경에 무작정 도입하면 이런 따사로운 눈빛을 받을 수 있으니 참고<br>이미지 출처 : https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4" data-caption="마냥 좋다고 운영환경에 무작정 도입하면 이런 따사로운 눈빛을 받을 수 있으니 참고<br>이미지 출처 : https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4" data-fancybox="default"><img class="fig-img" src="angry.jpg" alt="마냥 좋다고 운영환경에 무작정 도입하면 이런 따사로운 눈빛을 받을 수 있으니 참고<br>이미지 출처 : https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4"><span class="image-caption">마냥 좋다고 운영환경에 무작정 도입하면 이런 따사로운 눈빛을 받을 수 있으니 참고<br>이미지 출처 : https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4</span></a><span class="caption">마냥 좋다고 운영환경에 무작정 도입하면 이런 따사로운 눈빛을 받을 수 있으니 참고<br>이미지 출처 : https://namu.wiki/w/%EB%82%98%EB%8A%94%20%EC%9E%90%EC%97%B0%EC%9D%B8%EC%9D%B4%EB%8B%A4</span></div><br>필자는 최근 운영환경에도 packetbeat를 적용해서 outbound 트래픽을 모니터링 하고 문제가 있는 엔드포인트에 대해 자동으로 점검을 하는 시스템을 만들려고 하고 있는데, 네트워크 패킷을 전부 까보며(?) 아무래도 cpu 성능에 지장을 줄수밖에 없는 오픈소스 모듈이다보니 다양한 테스트를 통해 서비스 운영에 영향이 없도록 설정값들을 튜닝해 가며 적용해봐야 할 것 같다. (무작정 좋다고 적용하다 오히려 큰 화를 부를 수 있다…)</p><p>내가 맛있어 하는 음식이 남들도 맛있으리란 법 없듯, 소개팅에 나가기전 준비한 멘트가 전부 먹히리라는 법 없듯…<br>모든 상황에는 튜닝은 필수다. 그 튜닝을 얼마나 잘, 그리고 센스있게 하냐가 포인트!<br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;모니터링은 서비스 로직 개발 만큼 한번씩 고민해보고 경험해 봤을 중요한 영역이라 할 수 있다. 그중 웹서버에서 제공해주는 엑세스 로그는 운영하고 있는 웹서비스에 대해 여러가지 측면에서 분석할 수 있는 가장 강력한 아이템 중에 하나라고 생각한다.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="packetbeat" scheme="https://taetaetae.github.io/tags/packetbeat/"/>
    
      <category term="network" scheme="https://taetaetae.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>아파치 로드밸런싱으로 여러 WAS 운영하기</title>
    <link href="https://taetaetae.github.io/2019/08/04/apache-load-balancing/"/>
    <id>https://taetaetae.github.io/2019/08/04/apache-load-balancing/</id>
    <published>2019-08-04T10:50:43.000Z</published>
    <updated>2019-09-18T05:24:00.378Z</updated>
    
    <content type="html"><![CDATA[<p>웹서버 하나만 사용하거나 WAS 하나만을 사용하며 웹서비스를 운영하는 경우는 극히 드물다. 웹서버의 장점과 WAS의 장점 그 두마리의 토끼를 다 잡기 위해 보통 앞단에 웹서버를 두고 그 뒤에 WAS를 두며 서비스를 운영하곤 한다. 헌데 운영하는 서비스가 인기가 많아져(?) 사용량이 많아지다면 그만큼 응답이 느려 (TPS 등) 서버를 늘려야 하는 상황이 생긴다고 가정해보자.<a id="more"></a> (물론 서버를 늘리는 것보다 캐시를 적용하거나 로직을 바꿔보는 노력이 선행되야 하겠지만…) 당연히 서버부터 구매하며 “Scale Out”을 하려고 할것이다. 만약 원래 운영하던 서버가 너무 좋아서 CPU나 메모리 사용률이 거의 바닥이여도 서버를 구매해야 할까?<br>서버를 구매하게되면 결국 두개 이상의 서버가 운영될텐데 그 서버들을 앞에서 묶어주며 트래픽을 분산시켜주는 무언가가 필요하다. 그러한 기술을 바로 <code>로드밸런싱</code> 이라고 한다. 통상 L4 스위치를 활용하여 요청을 여러 서버들로 분산시키며 산술적으로는 서버 대수만큼 성능이 좋아지는 효과를 볼 수 있다.<br>하지만 앞서 말했듯 서버의 자원 사용률이 바닥일 정도로 거의 사용을 안할경우 서버를 구매하는건 너무나 비효율적이다. 이번 포스팅에서는 서버를 늘리지 않으면서 웹서버 중 아파치를 활용하여 여러 WAS를 운영하는 방법에 대해 알아보고자 한다. 서버 늘려야 하는 상황에서 사용해 볼 수 있는 나만의 좋은 무기(?)가 생긴게 아닐까 생각이 든다.</p><p>아파치는 <a href="https://httpd.apache.org/#apache-httpd-22-end-of-life-2018-01-01" target="_blank" rel="noopener">EOL</a>이 되었기 때문에 2.4버전으로 설치하고, WAS는 편의상 톰켓 최신버전으로 설치해서 동일한 서버에 아파치 한대와 톰켓 3대를 연동하는것을 목적으로 한다. 로드밸런싱이 어떤식으로 이루어 지고 하위에 연결된 톰켓을 컨트롤 하는 방법 또한 알아볼 예정이다.</p><blockquote><p>서버 환경 및 설치하게 될 각 버전은 다음과 같다.<br>서버 : CentOS 7.4 64Bit<br>apache : httpd-2.4.39<br>tomcat : apache-tomcat-8.5.43<br>tomcat-connectors(mod_jk) : 1.2.46</p></blockquote><h3 id="Apache-와-Tomcat-설치"><a href="#Apache-와-Tomcat-설치" class="headerlink" title="# Apache 와 Tomcat 설치"></a># Apache 와 Tomcat 설치</h3><p>필자의 포스팅에서 종종 나오는 부분이기도 하고, 구글링 해보면 바로 설치 방법을 쉽게 찾을 수 있겠지만 그렇다고 언급을 안하고 넘어가기엔 너무 불친절하니… 치트키처럼(?) 빠르게 정리해보자.</p><ul><li>Apache<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://apache.tt.co.kr//httpd/httpd-2.4.39.tar.gz</span><br><span class="line">$ tar -zxvf httpd-2.4.39.tar.gz</span><br><span class="line">$ ./configure --prefix=/home/~~~/apache</span><br><span class="line">$ make &amp;&amp; make install</span><br><span class="line">$ cd /home/~~~/apache/bin</span><br><span class="line">$ sudo chown root:계정명 httpd</span><br><span class="line">$ sudo chmod +s httpd</span><br><span class="line">$ vi /home/~~~/apache/conf/httpd.conf</span><br><span class="line">User 계정명</span><br><span class="line">Grop 계정명</span><br><span class="line">$ /home/~~~/apache/bin/apachectl start ← 실행</span><br></pre></td></tr></table></figure></li></ul><p>이렇게 설치를 한뒤 실행을 시키고 서버의 ip를 접속해보면 아래와 같은 화면을 볼 수 있다.</p><ul><li>Tomcat<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://mirror.apache-kr.org/tomcat/tomcat-8/v8.5.43/bin/apache-tomcat-8.5.43.tar.gz</span><br><span class="line">$ tar -zxvf apache-tomcat-8.5.43.tar.gz</span><br><span class="line">$ /home/apache-tomcat-8.5.43/bin/start.sh ← 실행</span><br></pre></td></tr></table></figure></li></ul><p>톰켓의 기본 http 포트인 8080으로 접속을 해보면 귀여운 고양이가 있는 톰켓 기본화면을 볼 수 있다.</p><h3 id="아파치와-톰켓-연동하기"><a href="#아파치와-톰켓-연동하기" class="headerlink" title="# 아파치와 톰켓 연동하기"></a># 아파치와 톰켓 연동하기</h3><p>아파치와 톰켓의 연동은 <code>mod_jk</code> 와 <code>mod_proxy</code> 등 다양한 모듈로 연동을 할 수 있는데 이번 포스팅에서는 <code>mod_jk</code> 를 활용하는 방법에 대해 알아보고자 한다. 우선 mod_jk 를 설치하자.</p><blockquote><p>간단히 mod_jk 는 컴파일, 설정 등 복잡하지만 톰켓 전용 바이너리 프로토콜인 AJP를 사용하기 때문에 높은 성능을 기대할수가 있다. mod_proxy 는 반면 기본으로 아파치에 탑재되어있는 모듈이기 때문에 별도의 모듈 설치가 필요 없고 설정도 간단하다는 장점이 있다. 각 연동방식의 장단점이 있기 때문에 본인이 운영하는 서버 상황에 맞추어 적용 할 필요가 있다.</p></blockquote><ul><li>mod_jk 설치<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://apache.tt.co.kr/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.46-src.tar.gz</span><br><span class="line">$ tar -zxvf tomcat-connectors-1.2.46-src.tar.gz</span><br><span class="line">$ cd tomcat-connectors-1.2.46-src/native</span><br><span class="line">$ ./configure --with-apxs=/home/~~~/apache/bin/apxs</span><br><span class="line">$ make &amp;&amp; make install</span><br><span class="line">$ /home/~~~/apache/modules 하위에 mod_jk.so가 생김</span><br></pre></td></tr></table></figure></li></ul><p>mod_jk 를 활용하면 AJP라는 통신으로 아파치와 톰켓이 연동되는데 톰켓의 기본 AJP 포트는 8009번임을 알고 다음처럼 설정을 해주자.</p><ul><li><p>apache/conf/workers.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker.list=tomcat1</span><br><span class="line">worker.tomcat1.port=8009</span><br><span class="line">worker.tomcat1.host=localhost</span><br><span class="line">worker.tomcat1.type=ajp13</span><br><span class="line">worker.tomcat1.lbfactor=1</span><br></pre></td></tr></table></figure></li><li><p>apache/conf/httpd.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LoadModule jk_module modules/mod_jk.so</span><br><span class="line">&lt;IfModule jk_module&gt;</span><br><span class="line">    JkWorkersFile    conf/workers.properties</span><br><span class="line">    JkLogFile        logs/mod_jk.log</span><br><span class="line">    JkLogLevel       info</span><br><span class="line">    JkMount /* tomcat1</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></li></ul><p>이렇게 하고서 아파치와 톰켓을 재시작 후에 서버의 ip로 접속해보면 (별도의 port 없이) 톰켓 설정페이지로 랜딩이 되는것을 확인할 수 있다.</p><h3 id="로드밸런싱을-위한-작업"><a href="#로드밸런싱을-위한-작업" class="headerlink" title="# 로드밸런싱을 위한 작업"></a># 로드밸런싱을 위한 작업</h3><p>여기까지는 본 포스팅을 작성하기 위한 밑거름이라고 말할 수 있다. 이제 실제로 로드밸런싱을 해볼 차례.<br>앞서 톰켓 하나만 설치했는데 편의상 톰켓 3개를 설치해두자. (하나를 설치하고 cp -r 명령어를 활용하는게 빠르다.) 그 다음 각 톰켓의 모든 포트를 셋다 다르게 설정해야 하는데 겹치지 않도록 설정해 두고 (필자는 앞자리를 1,2,3 이런식으로 다르게 설정하였다.) 워커(workers.properties)를 아래처럼 설정해주자.</p><ul><li>apache/conf/workers.properties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">worker.list=load_balancer</span><br><span class="line"></span><br><span class="line">worker.load_balancer.type=lb</span><br><span class="line">worker.load_balancer.balance_workers=tomcat1,tomcat2,tomcat3</span><br><span class="line"></span><br><span class="line">worker.tomcat1.port=18009</span><br><span class="line">worker.tomcat1.host=localhost</span><br><span class="line">worker.tomcat1.type=ajp13</span><br><span class="line">worker.tomcat1.lbfactor=1</span><br><span class="line"></span><br><span class="line">worker.tomcat2.port=28009</span><br><span class="line">worker.tomcat2.host=localhost</span><br><span class="line">worker.tomcat2.type=ajp13</span><br><span class="line">worker.tomcat2.lbfactor=1</span><br><span class="line"></span><br><span class="line">worker.tomcat3.port=38009</span><br><span class="line">worker.tomcat3.host=localhost</span><br><span class="line">worker.tomcat3.type=ajp13</span><br><span class="line">worker.tomcat3.lbfactor=1</span><br></pre></td></tr></table></figure></li></ul><p>이렇게 설정을 한 뒤 앞서 설정한 httpd.conf 에 JkMount 부분도 아래처럼 변경해주자.</p><ul><li>apache/conf/httpd.conf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JkMount /* load_balancer</span><br></pre></td></tr></table></figure></li></ul><p>위 설정을 다시한번 살펴보자면, <code>/*</code>으로 들어오는 요청을 <code>load_balancer</code>라는 워커로 넘기는데 워커 설정에서는 로드밸런싱이 설정되어 있기 때문에 tomcat1, tomcat2, tomcat3 골고루 요청을 분산해준다는 의미이다.<br>tomcat 하위 logs 폴더에 보면 아래 기본 설정에 의해 엑세스 로그가 로깅이 되는데<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>실제로 테스트를 해보면 다음처럼 9번의 요청을 3대의 톰켓에 골고루 요청된 것을 확인할 수 있다.<br><div class="figure center" style="width:;"><a class="fancybox" href="apache_lb_test.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="apache_lb_test.jpg" alt=""></a></div><div style="clear:both;"></div></p><h3 id="로드밸런싱을-컨트롤-하기-jkmanager"><a href="#로드밸런싱을-컨트롤-하기-jkmanager" class="headerlink" title="# 로드밸런싱을 컨트롤 하기 (jkmanager)"></a># 로드밸런싱을 컨트롤 하기 (jkmanager)</h3><p>위에서 알아본 mod_jk 를 활용한 로드밸런싱을 별도의 서버 재시작 없이 <code>컨트롤</code>이 가능하다고 한다. 이게 어떤것을 의미하냐면 연동된 톰켓 3대중에 한대를 별도의 서버 셧다운을 하지 않아도 제외시킬수 있으며 반대로 다시 투입도 가능하다는 이야기이다. 이를 활용해보면 서비스 배포를 할 경우 위와 같은 설정이 되어있을때 제외 &gt; 배포 &gt; 투입하는 식으로 서비스가 무중단 상태에서 배포가 될수 있는 효과를 얻을 수 있다.<br>설치는 별도로 하지 않아도 되고 mod_jk 모듈 내에 있기 때문에 별도의 설정만 추가해주면 된다.</p><ul><li><p>apache/conf/httpd.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule jk_module&gt;</span><br><span class="line">    JkWorkersFile    conf/workers.properties</span><br><span class="line">    JkLogFile        logs/mod_jk.log</span><br><span class="line">    JkLogLevel       info</span><br><span class="line">    JkMount /* load_balancer</span><br><span class="line"></span><br><span class="line">    &lt;Location /jkmanager/&gt;</span><br><span class="line">        JkMount jkstatus</span><br><span class="line">        Order deny,allow</span><br><span class="line">        Deny from all</span><br><span class="line">        Allow from 127.0.0.1</span><br><span class="line">        Allow from &#123;접근 가능한 IP&#125;</span><br><span class="line">    &lt;/Location&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></li><li><p>apache/conf/workers.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.list=jkstatus</span><br><span class="line">worker.jkstatus.type=status</span><br></pre></td></tr></table></figure></li></ul><p>설정에서 볼 수 있듯이 해당 설정은 다른측면에서는 상당히 취약점이 많은 부분이다. 해당 설정이 외부에 노출이 되어있다면 그 컨트롤을 서버 관리자가 아닌 다른 누군가가 할수 있기 때문에 꼭 Allow 설정으로 접근 제한을 해둬야 한다. 이렇게 하고 <code>서버 IP/jkmanager/</code> 을 접속해보면 “JK Status Manager” 이라는 문구와 함께 아파치에 연동된 톰켓의 상태를 한눈에 파악할 수 있다.<br><div class="figure center" style="width:;"><a class="fancybox" href="jk_status_manager.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="jk_status_manager.jpg" alt=""></a></div><div style="clear:both;"></div></p><p>여기서 tomcat1 좌측에 있는 <code>E</code>(=edit)를 클릭하고 Activation 값을 “Disabled” 으로 바꿔본 뒤 앞서 테스트한 방법을 다시 해보면 tomcat1 에는 엑세스가 들어오지 않고 9번 엑세스가 골고루 tomca2 와 tomcat3 으로 로드밸런싱이 된것을 확인할 수 있다.<br><div class="figure center" style="width:;"><a class="fancybox" href="apache_lb_test_jkmanager.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="apache_lb_test_jkmanager.jpg" alt=""></a></div><div style="clear:both;"></div></p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>각 설정값들은 아무리 필자가 설명을 잘 해도 도큐먼트를 따라갈 수 없듯이 실제 각 도큐먼트를 보면서 설정값 하나하나를 조절해보며 운영하고 있는 서비스의 특징과 상황에 맞도록 맞춰가는것이 핵심일것 같다. (본 포스팅은 아주 가볍게 연동만 해보는 형태이고, 각 설정이나 워커들간의 우선순위 로드밸런싱 같은 경우는 직접 설정을 해가면서 확인이 필요하다. )<br>사실 이부분은 머릿속으로는 어떻게 하는구나라고 알고만 있었는데 실제로 해보니 각 설정들이 어떤 의미이고 어떻게 조절하면 보다 더 좋은 성능이나 다양한 이득을 취할수 있을것 같다는 생각을 해본다.</p><ul><li>참고 링크<br><a href="https://tomcat.apache.org/connectors-doc/reference/workers.html" target="_blank" rel="noopener">https://tomcat.apache.org/connectors-doc/reference/workers.html</a><br><a href="https://tomcat.apache.org/connectors-doc/common_howto/loadbalancers.html" target="_blank" rel="noopener">https://tomcat.apache.org/connectors-doc/common_howto/loadbalancers.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;웹서버 하나만 사용하거나 WAS 하나만을 사용하며 웹서비스를 운영하는 경우는 극히 드물다. 웹서버의 장점과 WAS의 장점 그 두마리의 토끼를 다 잡기 위해 보통 앞단에 웹서버를 두고 그 뒤에 WAS를 두며 서비스를 운영하곤 한다. 헌데 운영하는 서비스가 인기가 많아져(?) 사용량이 많아지다면 그만큼 응답이 느려 (TPS 등) 서버를 늘려야 하는 상황이 생긴다고 가정해보자.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="apache" scheme="https://taetaetae.github.io/tags/apache/"/>
    
      <category term="tomcat" scheme="https://taetaetae.github.io/tags/tomcat/"/>
    
      <category term="Load Balance" scheme="https://taetaetae.github.io/tags/Load-Balance/"/>
    
  </entry>
  
  <entry>
    <title>스프링을 활용한 대용량 파일 업로드 구현</title>
    <link href="https://taetaetae.github.io/2019/07/21/spring-file-upload/"/>
    <id>https://taetaetae.github.io/2019/07/21/spring-file-upload/</id>
    <published>2019-07-21T13:09:58.000Z</published>
    <updated>2019-07-21T16:28:50.271Z</updated>
    
    <content type="html"><![CDATA[<p>개발을 하다보면 실제로 직접 구현을 해본적은 없지만 여기저기서 들어본 지식과 그 동안의 짬밥(?)으로 추측해볼수 있는 부분들이 있다. 물론 모든일에 정답은 없겠지만 요즘 느끼는건 책에서 공부만 해본것과 다른 블로그들에서 눈으로만 보고 넘어가는것들 그리고 직접 손가락을 움직여가며 왜 여기서는 이 방법을 사용하지 고민하면서 구현을 해본다는건 정말 엄청나게 큰 차이가 있는것 같다. <a id="more"></a><br>웹 어플리케이션을 개발하다보면 한번 쯤 만나게 되는 <code>파일 업로드</code> 기능. 필자도 몇번 구현은 해봤지만 그냥 단순히 <code>구현</code>만 해본 상태였다가 최근에 그냥 파일 업로드가 아닌 <code>대용량</code> 파일 업로드에서의 문제가 발생하여 여기저기 삽질을 하게 되었고 정리도 해볼겸 스프링에서의 대용량 파일 업로드시 한번쯤 고려해봐야 할 부분에 대해 정리를 해보려고 한다.</p><blockquote><p>물론 구글에서 검색을 해보면 아마 필자가 쓴것 보다 더 자세하고 좋은 글들이 있겠지만 필자는 보다 <code>대용량</code>에 집중에서 작성해 보고자 한다. 명심하자. “아무리 흐린 잉크라도 좋은 기억력보다 낫다” 라는 말이 있듯이</p></blockquote><h3 id="스프링을-활용한-파일-업로드-구현"><a href="#스프링을-활용한-파일-업로드-구현" class="headerlink" title="# 스프링을 활용한 파일 업로드 구현"></a># 스프링을 활용한 파일 업로드 구현</h3><p>우선 완전 초기상태에서 시작하기 위해 스프링 부트 프로젝트를 만들고 간단하게 파일 업로드를 할 수 있는 form 페이지와 업로드 버튼을 눌렀을때 작동하게 되는 컨트롤러를 만들어 보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 너무 간단 ...</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/form"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">form</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"form"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile multipartFile) </span>&#123;</span><br><span class="line">log.info(<span class="string">"### upload"</span>);</span><br><span class="line">File targetFile = <span class="keyword">new</span> File(<span class="string">"/home1/irteam/"</span> + multipartFile.getOriginalFilename());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream fileStream = multipartFile.getInputStream();</span><br><span class="line">FileUtils.copyInputStreamToFile(fileStream, targetFile);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">FileUtils.deleteQuietly(targetFile);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/form"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>upload</code> 요청이 들어오면 <code>file</code>이라는 이름의 파라미터로 <code>MultipartFile</code>을 받고 파일의 이름을 확인 후 스트림을 읽어 특정 경로에 파일로 저장하는 로직이다. 그다음 <code>/form</code>을 접속하게 되면 나오는 폼 화면을 만들자. 이것도 아주 심플하게!<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>파일 업로드<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">value</span>=<span class="string">"파일 선택"</span> <span class="attr">name</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"업로드"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>multipart/form-data</code> 라는 Content-Type 을 명시해주고 파일을 선택하면 <code>/upload</code>로 POST요청을 하도록 설정한다. 이렇게 되면 너무 간단하게 + 이상없이 파일이 업로드가 잘 되니 이게 이야기 할 꺼리인가(?) 싶을정도로 심플하다.</p><h3 id="그런데-파일-크기가-크다면"><a href="#그런데-파일-크기가-크다면" class="headerlink" title="# 그런데 파일 크기가 크다면?"></a># 그런데 파일 크기가 크다면?</h3><div class="figure center" style="width:;"><a class="fancybox" href="omg.jpg" title="설마 파일 업로드 하는 용량이 크겠어?... 왠지 파일의 용량이 크면 문제있을것 같은데... <br>출처 : https://m.blog.naver.com/naibbo0407/30170815180" data-caption="설마 파일 업로드 하는 용량이 크겠어?... 왠지 파일의 용량이 크면 문제있을것 같은데... <br>출처 : https://m.blog.naver.com/naibbo0407/30170815180" data-fancybox="default"><img class="fig-img" src="omg.jpg" alt="설마 파일 업로드 하는 용량이 크겠어?... 왠지 파일의 용량이 크면 문제있을것 같은데... <br>출처 : https://m.blog.naver.com/naibbo0407/30170815180"><span class="image-caption">설마 파일 업로드 하는 용량이 크겠어?... 왠지 파일의 용량이 크면 문제있을것 같은데... <br>출처 : https://m.blog.naver.com/naibbo0407/30170815180</span></a><span class="caption">설마 파일 업로드 하는 용량이 크겠어?... 왠지 파일의 용량이 크면 문제있을것 같은데... <br>출처 : https://m.blog.naver.com/naibbo0407/30170815180</span></div><div style="clear:both;"></div><p>개발을 하다보면 항상 생각해야 할 부분중에 하나가 바로 확장성인것 같다. 이 부분에서 역시 문제가 되었던 것. 평소보다 용량이 큰 파일이 업로드가 되면서 (평소 3~400MB 였다가 3~4GB정도의 파일이 업로드가 되는 매직) 업로드가 안되는 상황이 발생하였다. 당연히 문제가 발생하면 누군가 말했듯 로그부터 살펴보았는데 Apache - (AJP) - Tomcat 으로 구성된 환경에서 tomcat 로그에 <code>### upload</code>라는 로그가 없고 아파치 로그엔 <code>502 에러</code>가 발생한 것이었다. 왜 톰켓 로그도 안남고 그전에 에러가 발생하였을까?<br>이때부터 (근거없는 추측을 하며…) 고난과 역경의 삽질을 하기 시작하게 된다. 톰켓 버전이 문제일까? 로그가 안찍혔다면 다른 필터나 인터셉터에서 무언가를 먹고(?)있는건 아닐까? 잠깐, 근데 원래 대용량 업로드가 되긴 해? 파일 업로드/다운로드 하는 사이트 보면 별도 프로그램으로 하던데… 꼬불꼬불 미로속을 헤메는것만 같았던 삽질의 문제는 결국 <code>메모리</code>에 있었다.<br>파일을 업로드 하게 되면 해당 내용을 우선 메모리에 담게 되고 다 담은 후 메모리에 있는 내용을 was에 전달한 뒤 HttpServletRequest 로 넘어오게 된다.(Apache &gt; Tomcat) 그런데 파일을 업로드 하면서 메모리에 파일이 써지다가 메모리 부족으로 OOM이 발생하게 되버린 것이었다. 또한 스프링 파일 최대크기를 별도로 지정하지 않고 있었기 때문에 메모리가 충분했다 하더라도 에러가 발생했을 상황이었다. ( <a href="https://spring.io/guides/gs/uploading-files/" target="_blank" rel="noopener">https://spring.io/guides/gs/uploading-files/</a> 참조 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.servlet.multipart.max-file-size</span><br><span class="line">spring.servlet.multipart.max-request-size</span><br></pre></td></tr></table></figure></p><p>그러다보니 웹 서버인 아파치에서는 was 에러인 <code>503</code>이 아닌 <code>502</code>라고 에러를 발생하던 것이였고 지나고 보면 정말 아무것도 아닌 간단한 설정들을 놓친 문제였는데 꽤나 긴 시간을 허비해야만 했던 안타깝지만 보람찼던 (응?) 트러블 슈팅이었다.</p><h3 id="삽질은-곧-경험이-되고-시야가-된다"><a href="#삽질은-곧-경험이-되고-시야가-된다" class="headerlink" title="# 삽질은 곧 경험이 되고 시야가 된다."></a># 삽질은 곧 경험이 되고 시야가 된다.</h3><p>legacy 로직이다보니 was가 파일 업로드 처리를 하게 되었는데 가급적이면 was가 처리하는것 보다는 static 파일을 처리할 수 있는 별도의 웹서버를 만드는게 어떨까 생각이 든다. (조금 알아보니 nodejs 모듈인 <a href="https://github.com/expressjs/multer" target="_blank" rel="noopener">multer</a> 라는게 있다.) 물론 파일 업로드 한 뒤에 별도의 로직을 처리하려면 was가 관여를 해야겠지만 이 부분은 설계를 어떻게 하냐에 따라 충분히 해결할 수 있을것으로 보인다. (웹서버에서 파일을 업로드 한 뒤 비동기로 파일 업로드 완료여부에 따라 was에서 처리를 한다거나 등…)<br>더불어 항상 어플리케이션을 만들때에는 <code>예외처리</code>라는 것을 생각하면서 개발해야한다고 느끼게 되었다. NPE 같은 사소한 로직에서의 예외처리부터 파일 업로드시 서버의 메모리를 생각할수 있는 시야. 이런게 경험이 아닐까 싶다.<br>또한 (잘 돌아가니까) 환경설정 값을 수정하지 않고 배포하는 것보단 가급적 어떤 설정값들에 의해서 어플리케이션이 돌아가는지 특히, 스프링 같은 프레임워크의 도움을 받는다면 해당 프레임워크의 설정값들을 수정하며 성능에 이득을 취할 부분들은 없는지 꼼꼼하게 개발하는 습관을 길러야 할 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;개발을 하다보면 실제로 직접 구현을 해본적은 없지만 여기저기서 들어본 지식과 그 동안의 짬밥(?)으로 추측해볼수 있는 부분들이 있다. 물론 모든일에 정답은 없겠지만 요즘 느끼는건 책에서 공부만 해본것과 다른 블로그들에서 눈으로만 보고 넘어가는것들 그리고 직접 손가락을 움직여가며 왜 여기서는 이 방법을 사용하지 고민하면서 구현을 해본다는건 정말 엄청나게 큰 차이가 있는것 같다.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="spring" scheme="https://taetaetae.github.io/tags/spring/"/>
    
      <category term="fileupload" scheme="https://taetaetae.github.io/tags/fileupload/"/>
    
  </entry>
  
  <entry>
    <title>2019 상반기 리뷰 (feat. 글또)</title>
    <link href="https://taetaetae.github.io/2019/07/07/review-first-half-2019/"/>
    <id>https://taetaetae.github.io/2019/07/07/review-first-half-2019/</id>
    <published>2019-07-07T08:52:20.000Z</published>
    <updated>2019-07-07T15:10:13.467Z</updated>
    
    <content type="html"><![CDATA[<p>누구나 어렸을 땐 빨리 어른이 되고 싶어 하는 것 같다. 시간이 빨리 지나가길 바라고, 빨리 어른이 되고 싶다는 간절함이 있지만 이상하게도 그땐 시간이 천천히 가는 것처럼 느껴졌다. 반면, 시간이 천천히 갔으면 하는 때가 있다. 딱 지금. <a id="more"></a><br>남들은 <code>워어어어얼화아아수우우모옥금퇼</code> 이라고 부르며 시간이 느리게 간다고 빨리 주말이 왔으면 좋겠다고 하지만 요즘의 필자는 정 반대다. 방금 출근한 것 같은데 어느샌가 퇴근인사를 주고받고 있다. 무언가에 홀린 것 같다. 벌써 올해도 절반이 지나가고 뜨거운 여름과 함께 후반전이 시작되었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="speed_time.jpg" title="그래서 빨리 지나갔나...<br>출처 : https://m.blog.naver.com/kong6482/220584667861" data-caption="그래서 빨리 지나갔나...<br>출처 : https://m.blog.naver.com/kong6482/220584667861" data-fancybox="default"><img class="fig-img" src="speed_time.jpg" alt="그래서 빨리 지나갔나...<br>출처 : https://m.blog.naver.com/kong6482/220584667861"><span class="image-caption">그래서 빨리 지나갔나...<br>출처 : https://m.blog.naver.com/kong6482/220584667861</span></a><span class="caption">그래서 빨리 지나갔나...<br>출처 : https://m.blog.naver.com/kong6482/220584667861</span></div><div style="clear:both;"></div><p>이제까지는 12월 말 즈음에 한 해를 바라보고 리뷰를 했었는데 <code>글또</code>라는 글쓰기 모임에 가입을 하게 되어 상반기 리뷰를 해보려 한다. 글또 모임의 첫 숙제가 상반기 리뷰 포스팅이다. 사실 리뷰를 상반기에 하던 연 말에 한 해 기준으로 하던 정해진 건 없지만 나를 다시 바라보고 다잡는 시간이 많을수록 보다 더 앞으로 가는데 힘이 될 거라는 데에는 이견이 없다.</p><h3 id="회사-속에서의-나"><a href="#회사-속에서의-나" class="headerlink" title="# 회사 속에서의 나"></a># 회사 속에서의 나</h3><div class="figure center" style="width:;"><a class="fancybox" href="office_work.jpg" title="회사에서는 회사일이 최우선!<br>출처 : https://m.blog.naver.com/hwee__/221191852972" data-caption="회사에서는 회사일이 최우선!<br>출처 : https://m.blog.naver.com/hwee__/221191852972" data-fancybox="default"><img class="fig-img" src="office_work.jpg" alt="회사에서는 회사일이 최우선!<br>출처 : https://m.blog.naver.com/hwee__/221191852972"><span class="image-caption">회사에서는 회사일이 최우선!<br>출처 : https://m.blog.naver.com/hwee__/221191852972</span></a><span class="caption">회사에서는 회사일이 최우선!<br>출처 : https://m.blog.naver.com/hwee__/221191852972</span></div><div style="clear:both;"></div><p>최근에 팀장님과 면담 중에 나온 이야기다. 신기하게도 군 시절 장기를 꿈꾸던 필자를 어서 전역하라고 권유하시던 대대장님께 매일같이 들었던 이야기와 비슷하다.</p><blockquote><p>“이제는 단순 개발만 하고 기능구현만 하는 것이 아니라 <code>그 이상</code>을 해야 할 시기가 다가온다.”<br> “사람들 관리가 될 수도 있고 어느 한 분야에 전문가가 되어야 할 수도 있고, 선택은 본인의 몫” </p></blockquote><p>사실 기능 구현이야 누구나 다 할 수 있다. 단지 경험에 따른 구현의 속도나 안정성의 차이가 아닐까 생각해본다. 그렇다면 <code>그 이상</code>은 어떻게 해야 할까? 정답은 없겠지만 필자는 <code>그 이상</code>을 해보려 우선 팀에 도움이 되기 위해 여러 가지 자동화 툴 들을 만든 것 같다. 보다 기능 개발에 집중하고 단순 반복적인 업무는 시스템이 할 수 있도록. 그렇게 툴들을 만들어 가며 생각하지 못한 부분들을 배우게 되고 나중에 그걸 또 사용하게 되는, 미래의 나를 위해 강제로 배우고 있는듯한 느낌이랄까. 아, 물론 회사 본연의 업무가 최우선이지만 말이다.<br>어쨌든 <code>시킨 일</code>은 우선 차질 없이 잘 하고 <code>시키지도 않은 일</code>을 찾아서 하려고 노력했던 것 같다. 팀을 위해서, 곧 나를 위해서.<br>적어도 회사에서 있는 시간 속에서는 다른 곳에 한눈 안 팔고 회사 업무에 전념하려고 노력했던 것 같다.</p><h3 id="외부-활동"><a href="#외부-활동" class="headerlink" title="# 외부 활동"></a># 외부 활동</h3><p>부족한 시간을 쪼개면서 밋업이나 세미나에 참여하곤 했었다. 그리고 마냥 듣고만 오진 않았고 “행사에 참여하면 무조건 질문 하나는 하자”라는 나와의 약속을 지키며 정리한 내용을 블로그에 포스팅하기도 하였다. </p><div class="figure center" style="width:;"><a class="fancybox" href="magarine.jpg" title="올해 첫 발표!" data-caption="올해 첫 발표!" data-fancybox="default"><img class="fig-img" src="magarine.jpg" alt="올해 첫 발표!"><span class="image-caption">올해 첫 발표!</span></a><span class="caption">올해 첫 발표!</span></div><div style="clear:both;"></div><p>디자이너와 개발자가 함께하는 투게더톤을 진행하기도 했었다. 투게더톤은 약 한 달 동안 진행되는 해커톤으로 하루 또는 무박 2일 동안 하는 기존 해커톤과 다르다. 이 기간 동안 팀 내에서 자유롭게 일정을 조정할 수 있다. 우리 팀은 약 7주에 걸쳐 “동네 마트 할인 정보를 알려주는 앱” 을 만들게 되었다. 필자는 API 전반에 대해 담당을 하였고 작은 부분이었지만 웹사이트도 간단하게 만들어 보았다. 아무것도 없는 백지상태에서 시작하려니 막막했지만 <a href="https://taetaetae.github.io/2019/05/19/d-light-togetherthon-2019/">후기</a>에서도 적었듯이 다시 해보라고 하면 머릿속에 전체 아키텍처가 그림으로 그려질 만큼 자신감이 생겼다. 특히 정말 좋은 팀원들과 함께 협업할 수 있어서 너무 좋았다.</p><h3 id="내공-연마"><a href="#내공-연마" class="headerlink" title="# 내공 연마"></a># 내공 연마</h3><p>한 달에 2개 이상 블로그 글을 작성하는 목표가 있었다. 그런데 지난달에 이사를 하다 보니 (핑계…) 목표를 달성 할 수가 없었다. 하지만 나름 퀄리티가 있는 글을 쓰려고 노력했고 PV도 작년보다 조금씩 오르고 있는 것 같아 내심 기분이 좋다. 그리고 작년 말부터 시작한 필자의 첫 토이프로젝트 인 <a href="http://daily-devblog.com" target="_blank" rel="noopener">기술블로그 구독서비스</a> 에 이런저런 기능을 추가하였다. 설마 1000명이 넘게 구독 하겠어?라고 생각했지만 이 글을 작성하고 있는 시점에서 1,569명이나 구독했다. 설마 1년 넘게 내가 이 프로젝트를 운영하겠어?라고 생각했지만 다음 주가 되면 딱 1년째. 신기할 따름이다. 마침 기회가 되어 GDG 주관으로 행사하는 <a href="https://festa.io/events/364" target="_blank" rel="noopener">모두의 TOY STORY: SIDE PROJECT 어디까지 가봤니?</a>라는 주제에 첫! 공식 발표자로써 발표를 할 수 있게 되어 너무나도 영광이다. 해당 발표 후기는 나중에 작성하는 것으로~</p><h3 id="글또-3기-다짐"><a href="#글또-3기-다짐" class="headerlink" title="# 글또 3기 다짐"></a># 글또 3기 다짐</h3><p><code>글쓰는 또라이가 세상을 바꾼다</code> 라는 페이스북 모임이 있다. (이번기수가 벌써 3기라고 한다 ㄷㄷ) 글또 라는 모임에 대해 간단히 정리를 해보면 다음과 같다.</p><ul><li>일정의 예치금을 먼저 저장한다.</li><li>2주 간격으로 블로그 글을 작성 + 2명의 글에 대해 서로 리뷰</li><li>PASS권은 2회 (다른사람들의 글에 리뷰를 많이 해주면 PASS 권을 부여)</li><li>글을 올리지 않았거나, 리뷰를 하지 않았을 경우 예치금에서 일부 삭감</li><li>마지막 날까지 진행하고 예치금을 다시 돌려받는 형식</li></ul><p>올해부터 블로그 포스팅을 좀 더 많이 하자고도 했고, 단순 횟수만 늘리는 것이 아닌 글쓰기에 대해서도 연습을 하고자 했는데 마침 딱 원하는 모임이 있어 시작을 하게 되었다.<br>이 모임에 참여하기 위해 무작정 2주마다 한 개의 글을 쓰지 않을 것이다. 배운 것을 기록하고 정리하는 습관을 기르기 위해 글을 쓸 것이다. 또, 양질의 글을 작성하기 위해 글쓰기 책들을 읽어야겠다.</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>우선 다음 주에 있을 발표 준비에 최선을 다하고, 여력이 되면 새로운 프로젝트를 시작하고 싶다. 회사에서는 회사일 열심히 하고 회사 밖에서는 나만의 인사이트를 찾기 위한 여정에 지치지 않도록 체력이며 정신력이며 갈고닦아야 할 것 같다. 운동도 다시 시작을 해야 할 텐데 . . . ㅠㅠ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;누구나 어렸을 땐 빨리 어른이 되고 싶어 하는 것 같다. 시간이 빨리 지나가길 바라고, 빨리 어른이 되고 싶다는 간절함이 있지만 이상하게도 그땐 시간이 천천히 가는 것처럼 느껴졌다. 반면, 시간이 천천히 갔으면 하는 때가 있다. 딱 지금.
    
    </summary>
    
      <category term="blog" scheme="https://taetaetae.github.io/categories/blog/"/>
    
    
      <category term="review" scheme="https://taetaetae.github.io/tags/review/"/>
    
      <category term="글또" scheme="https://taetaetae.github.io/tags/%EA%B8%80%EB%98%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring에서 Request를 우아하게 로깅하기</title>
    <link href="https://taetaetae.github.io/2019/06/30/controller-common-logging/"/>
    <id>https://taetaetae.github.io/2019/06/30/controller-common-logging/</id>
    <published>2019-06-30T09:39:47.000Z</published>
    <updated>2019-07-01T02:07:47.247Z</updated>
    
    <content type="html"><![CDATA[<p>스프링 기반의 웹 어플리케이션을 만들다 보면 요청을 처리하는데 맨 처음에 위치하고 있는 <code>Controller</code>(이하 컨트롤러)라는 레이어를 만들게 된다. 그럴때면 사용자가 어떤 요청(Request)을 하였는지에 대해 확인이 필요할 수 있다. <a id="more"></a> 물론 확인을 안해도 무방하지만 가급적 로깅은 시스템 로직에 영향을 주지 않는 범위에서 최대한 다양하게 <code>미리</code> 해두는게 나중에 유지보수시 편할 수 있다. (예전 조직장님께서 말씀하신게 아직도 머릿속에 꽉 자리잡고 있다…)<br>아~주 일반적으로, 컨트롤러에서는 다음과 같이 메소드 단위로 파라미터를 직접 로깅하게 된다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(@RequestParam String id)</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">"id : &#123;&#125;"</span>, id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"length : "</span> + id.length();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이렇게 되면 사용자가 <code>GET /test1</code> 이라는 요청을 보낼때 어떤 파라미터로 호출하였는지에 대해 로깅이 남게 되는데 항상 <code>log.info(&quot;id : {}&quot;, id);</code> 과 같이 수동으로 로깅을 남겨야 하는 불편함이 생긴다. 물론 꼼꼼하게 메소드마다 로깅을 적어주면 전혀 문제될게 없지만 이러한 컨트롤러 ~ 메소드가 한두개가 아닌 수십 또는 수백개일 경우엔 그때마다 로깅을 적어줘야 하는 불편함이 있을 수 있다. 또한 자칫 깜박하고 로깅을 빼먹고 배포를 하게 된 경우 모니터링시 로깅을 하지 않아서 다시 로깅하고 배포를 하는, 별것도 아닌데(?) “정말 불편한” 상황이 있을 수 있다.<br>이번 포스팅에서는 사용자의 요청을 모니터링 하기 위해 컨트롤러마다 코드를 작성해가며 로깅을 하는것이 아니라 <code>HttpServletRequestWrapper</code> 라는 것과 <code>Filter</code>, <code>AOP</code>를 이용하여 <strong>Request의 정보를 한곳에서 우아하게 로깅하는 방법</strong>에 대해 알아보고자 한다.</p><h3 id="요구사항"><a href="#요구사항" class="headerlink" title="# 요구사항"></a># 요구사항</h3><div class="figure center" style="width:;"><a class="fancybox" href="bull_fighting.gif" title="와 개발하자아!<br>출처 : https://gfycat.com/ko/brightevilaoudad" data-caption="와 개발하자아!<br>출처 : https://gfycat.com/ko/brightevilaoudad" data-fancybox="default"><img class="fig-img" src="bull_fighting.gif" alt="와 개발하자아!<br>출처 : https://gfycat.com/ko/brightevilaoudad"><span class="image-caption">와 개발하자아!<br>출처 : https://gfycat.com/ko/brightevilaoudad</span></a><span class="caption">와 개발하자아!<br>출처 : https://gfycat.com/ko/brightevilaoudad</span></div><div style="clear:both;"></div><p>투우사가 흔드는 빨간 천을 보며 돌진하는 황소처럼 (쓰고보니 너무 TMI 같다….) 당장 코딩을 시작하며 개발을 할 수도 있지만 정작 원하는 기능이 무엇인지 천천히 정리하고 넘어갈 필요가 있는 것 같다. (어쩔땐 오히려 후자가 더 빠른 개발을 하게 되는것 같다.)</p><ol><li>GET, POST 등 다양한 http method 로 구현된 모든 컨트롤러의 파라미터와 기타 Request 정보가 로깅이 되야 한다.</li><li>컨트롤러, 메소드가 늘어날때마다 별도의 코드 추가 없이 한곳에서 공통적으로 로깅이 되야 한다.</li><li>URL 중 특정 패턴으로 들어오는 요청은 다른 방식으로 로깅을 하거나, 로깅에서 제외할 수 있어야 한다.</li><li>앞서 말했듯 다른 비지니스 로직에 영향을 주지 않아야 한다.</li></ol><h3 id="구현하기-Request-의-파라미터-정리"><a href="#구현하기-Request-의-파라미터-정리" class="headerlink" title="# 구현하기 - Request 의 파라미터 정리"></a># 구현하기 - Request 의 파라미터 정리</h3><p>Request 의 모든 로깅을 한곳에서 처리하기 위해서 filter(필터)를 활용하였다. 필터는 Dispatcher servlet의 앞단에 위치하고 있기 때문에 모든 정보를 확인할 수 있는데 용이하다. 물론 인터셉터를 활용해서도 방법이 있겠지만 본 포스팅 에서는 필터를 활용해서 구현하는것을 목적으로 한다. (사실 인터셉터로 몇번 시도해보다가 실패해서…유유 )</p><div class="figure center" style="width:;"><a class="fancybox" href="spring-request-lifecycle.jpg" title="Spring MVC Request Life Cycle<br>출처 : https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/" data-caption="Spring MVC Request Life Cycle<br>출처 : https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/" data-fancybox="default"><img class="fig-img" src="spring-request-lifecycle.jpg" alt="Spring MVC Request Life Cycle<br>출처 : https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/"><span class="image-caption">Spring MVC Request Life Cycle<br>출처 : https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</span></a><span class="caption">Spring MVC Request Life Cycle<br>출처 : https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</span></div><div style="clear:both;"></div><p>Filter를 만들기 전에 Filter에서 사용할 주요 핵심(?) 클래스가 필요한데 <code>HttpServletRequest</code> 를 Wrapping 해서 사용하기 위해 <code>HttpServletRequestWrapper</code>를 상속받는 클래스를 만들자. Request 에 담겨있는 param 과 body로 요청이 들어올 경우 body에 있는 내용을 param 에 담는 로직이다. 주요 설명은 코드 안에서 주석으로 설명하겠다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadableRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123; <span class="comment">// 상속</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Charset encoding;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] rawData;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String[]&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReadableRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.params.putAll(request.getParameterMap()); <span class="comment">// 원래의 파라미터를 저장</span></span><br><span class="line"></span><br><span class="line">String charEncoding = request.getCharacterEncoding(); <span class="comment">// 인코딩 설정</span></span><br><span class="line"><span class="keyword">this</span>.encoding = StringUtils.isBlank(charEncoding) ? StandardCharsets.UTF_8 : Charset.forName(charEncoding);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream is = request.getInputStream();</span><br><span class="line"><span class="keyword">this</span>.rawData = IOUtils.toByteArray(is); <span class="comment">// InputStream 을 별도로 저장한 다음 getReader() 에서 새 스트림으로 생성</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// body 파싱</span></span><br><span class="line">String collect = <span class="keyword">this</span>.getReader().lines().collect(Collectors.joining(System.lineSeparator()));</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(collect)) &#123; <span class="comment">// body 가 없을경우 로깅 제외</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request.getContentType() != <span class="keyword">null</span> &amp;&amp; request.getContentType().contains(</span><br><span class="line">ContentType.MULTIPART_FORM_DATA.getMimeType())) &#123; <span class="comment">// 파일 업로드시 로깅제외</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">JSONParser jsonParser = <span class="keyword">new</span> JSONParser();</span><br><span class="line">Object parse = jsonParser.parse(collect);</span><br><span class="line"><span class="keyword">if</span> (parse <span class="keyword">instanceof</span> JSONArray) &#123;</span><br><span class="line">JSONArray jsonArray = (JSONArray)jsonParser.parse(collect);</span><br><span class="line">setParameter(<span class="string">"requestBody"</span>, jsonArray.toJSONString());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">JSONObject jsonObject = (JSONObject)jsonParser.parse(collect);</span><br><span class="line">Iterator iterator = jsonObject.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">String key = (String)iterator.next();</span><br><span class="line">setParameter(key, jsonObject.get(key).toString().replace(<span class="string">"\""</span>, <span class="string">"\\\""</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"ReadableRequestWrapper init error"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String[] paramArray = getParameterValues(name);</span><br><span class="line"><span class="keyword">if</span> (paramArray != <span class="keyword">null</span> &amp;&amp; paramArray.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> paramArray[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.unmodifiableMap(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.enumeration(params.keySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">String[] result = <span class="keyword">null</span>;</span><br><span class="line">String[] dummyParamValue = params.get(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dummyParamValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">result = <span class="keyword">new</span> String[dummyParamValue.length];</span><br><span class="line">System.arraycopy(dummyParamValue, <span class="number">0</span>, result, <span class="number">0</span>, dummyParamValue.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line">String[] param = &#123;value&#125;;</span><br><span class="line">setParameter(name, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(String name, String[] values)</span> </span>&#123;</span><br><span class="line">params.put(name, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(<span class="keyword">this</span>.rawData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ServletInputStream() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener readListener)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> byteArrayInputStream.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.getInputStream(), <span class="keyword">this</span>.encoding));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>가장 중요한 부분은 <code>IOUtils.toByteArray(is)</code> 요 부분인데, InputStream은 한번밖에 읽을 수 없기 때문에 이 필터에서 스트림을 읽는 대신, 래퍼 구현으로 새 스트림 생성하도록 작업을 하였다. 자칫 잘못하다간 body의 내용이 유실될 수도 있기 때문이다.<br>참조 :<br><a href="http://stackoverflow.com/questions/10210645/http-servlet-request-lose-params-from-post-body-after-read-it-once" target="_blank" rel="noopener">http://stackoverflow.com/questions/10210645/http-servlet-request-lose-params-from-post-body-after-read-it-once</a><br><a href="http://stackoverflow.com/questions/3769259/why-is-the-parameter-value-an-object-hash-code-for-request-getparametermap-ge" target="_blank" rel="noopener">http://stackoverflow.com/questions/3769259/why-is-the-parameter-value-an-object-hash-code-for-request-getparametermap-ge</a></p><p>위에서 만든 래퍼 클래스를 이제 필터에서 적용해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadableRequestWrapperFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">ReadableRequestWrapper wrapper = <span class="keyword">new</span> ReadableRequestWrapper((HttpServletRequest)request);</span><br><span class="line">chain.doFilter(wrapper, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do nothing</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이렇게 되면 param으로 넘어온 파라미터나 body로 넘어온 정보들이 파싱되어 param에 담기게 된다.<br>(JSON으로 파싱하는 부분은 조금 지저분해 보일 수 있지만 다양한 테스트를 해보면서 얻은 결과물이다. 더 좋은 방식이 있다면 언제든지 PullRequest 또는 댓글 환영!)</p><h3 id="구현하기-컨트롤러에-AOP-셋팅"><a href="#구현하기-컨트롤러에-AOP-셋팅" class="headerlink" title="# 구현하기 - 컨트롤러에 AOP 셋팅"></a># 구현하기 - 컨트롤러에 AOP 셋팅</h3><p>이제 Request 의 params 를 한곳에서 로깅할 차례이다. 물론 위에서 만든 필터에서 로깅을 해도 되지만 필터에 로직이 들어가는 것보다 별도의 로직에서 처리하는게 맞다고 생각되어 분리를 하였다. (관심사의 분리)<br>AOP를 활용하여 다음과 같이 로직을 작성하였다. 아래 로직은 이해하기에 큰 어려움은 없을것 같지만 주석으로 설명을 하겠다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspect</span> </span>&#123;</span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.taetaetae..*Controller.*(..))"</span>) <span class="comment">// 이런 패턴이 실행될 경우 수행</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loggerPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"loggerPointCut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">methodLogger</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object result = proceedingJoinPoint.proceed();</span><br><span class="line">HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest(); <span class="comment">// request 정보를 가져온다.</span></span><br><span class="line"></span><br><span class="line">String controllerName = proceedingJoinPoint.getSignature().getDeclaringType().getSimpleName();</span><br><span class="line">String methodName = proceedingJoinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">params.put(<span class="string">"controller"</span>, controllerName);</span><br><span class="line">params.put(<span class="string">"method"</span>, methodName);</span><br><span class="line">params.put(<span class="string">"params"</span>, getParams(request));</span><br><span class="line">params.put(<span class="string">"log_time"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">params.put(<span class="string">"request_uri"</span>, request.getRequestURI());</span><br><span class="line">params.put(<span class="string">"http_method"</span>, request.getMethod());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"LoggerAspect error"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"params : &#123;&#125;"</span>, params); <span class="comment">// param에 담긴 정보들을 한번에 로깅한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line"><span class="keyword">throw</span> throwable;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 에 담긴 정보를 JSONObject 형태로 반환한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JSONObject <span class="title">getParams</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">Enumeration&lt;String&gt; params = request.getParameterNames();</span><br><span class="line"><span class="keyword">while</span> (params.hasMoreElements()) &#123;</span><br><span class="line">String param = params.nextElement();</span><br><span class="line">String replaceParam = param.replaceAll(<span class="string">"\\."</span>, <span class="string">"-"</span>);</span><br><span class="line">jsonObject.put(replaceParam, request.getParameter(param));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jsonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드에서는 단순히 console log를 찍었지만 필자가 운영하고 있는 어드민 툴에서는 Request 정보를 Elasticsearch 에 인덱싱하고 이를 키바나에서 보다 쉽게 조회 및 모니터링이 가능하도록 구현하였다. 로깅을 어떤식으로 남길지, 로깅이 아닌 특정 상황에서 알림을 보낸다거나 등등 이 부분은 실제 구현시에 상황에 맞춰서 만들면 될 것 같다.<br>또한 <code>Pointcut</code> 부분을 다르게 활용하여 위에서 이야기한 요구사항의 3번 (URL 중 특정 패턴으로 들어오는 요청은 다른 방식으로 로깅을 하거나, 로깅에서 제외할 수 있어야 한다.) 를 해결할 수 있다.<br>아참, AOP의 개념을 좀더 알고 싶다면 jojoldu 님의 블로그 포스팅을 추천한다. <a href="https://jojoldu.tistory.com/71" target="_blank" rel="noopener">https://jojoldu.tistory.com/71</a></p><p>그래서 아래처럼 테스트를 해보면 GET 이던 POST 이던 로깅이 되는것을 확인할수 있다.<br><div class="figure " style="width:;"><a class="fancybox" href="test.jpg" title="더 이쁘게 로깅을 하는건 자유!" data-caption="더 이쁘게 로깅을 하는건 자유!" data-fancybox="default"><img class="fig-img" src="test.jpg" alt="더 이쁘게 로깅을 하는건 자유!"><span class="image-caption">더 이쁘게 로깅을 하는건 자유!</span></a><span class="caption">더 이쁘게 로깅을 하는건 자유!</span></div><div style="clear:both;"></div></p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>사실 이 로직을 만들게 된 계기는 팀원중에 한분이 “GET 의 파라미터는 로깅이 되는데 POST 의 파라미터는 로깅이 안되요” 라는 말에 투우사 앞에 있는 황소마냥 찾아보다 만들게 되었다. 참고로 이 부분은 하나의 <code>무기</code>가 될것 같아 github에 공개를 하였고 위에서 적었던 요구사항보다 더 좋은 내용이 있다면 언제든지 PullRequest 를 날려주기를 바란다. Spring Boot 환경에서 Filter를 추가하며 구성하였다.<br><a href="https://github.com/taetaetae/request_logging" target="_blank" rel="noopener">https://github.com/taetaetae/request_logging</a><br>필터와 인터셉터, AOP 등 평소 자주 사용하지 않은 (이미 누군가 다 만들어 둔) 부분을 만지면서 다시한번 Spring의 주요 개념을 숙지하는데 도움이 되었던 경험으로 남을 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;스프링 기반의 웹 어플리케이션을 만들다 보면 요청을 처리하는데 맨 처음에 위치하고 있는 &lt;code&gt;Controller&lt;/code&gt;(이하 컨트롤러)라는 레이어를 만들게 된다. 그럴때면 사용자가 어떤 요청(Request)을 하였는지에 대해 확인이 필요할 수 있다.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="spring" scheme="https://taetaetae.github.io/tags/spring/"/>
    
      <category term="logging" scheme="https://taetaetae.github.io/tags/logging/"/>
    
      <category term="HttpServletRequestWrapper" scheme="https://taetaetae.github.io/tags/HttpServletRequestWrapper/"/>
    
      <category term="Filter" scheme="https://taetaetae.github.io/tags/Filter/"/>
    
      <category term="AOP" scheme="https://taetaetae.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>D.light 투게더톤 참가후기</title>
    <link href="https://taetaetae.github.io/2019/05/19/d-light-togetherthon-2019/"/>
    <id>https://taetaetae.github.io/2019/05/19/d-light-togetherthon-2019/</id>
    <published>2019-05-19T13:46:03.000Z</published>
    <updated>2019-05-30T08:14:52.107Z</updated>
    
    <content type="html"><![CDATA[<p>회사일을 하다 보면 시키는 대로 혹은 팀의 목표에 부합하기 위해 어쩔 수 없이 해야 하는 일을 하게 된다. 그러한 일이 재미있고 결과물에 대한 만족도가 100% 라면 다행이지만 간혹 재미도 없고 시켜서 하는 일은 밤을 꼬박 새 가면서 완성을 해도 썩 그렇게 만족스럽지 못한 경우가 대부분인 것 같다.<a id="more"></a> (물론 회사일에서 자신만의 인사이트를 찾는다면 금상첨화겠지만… + 매번 회사일이 재미없고 하기 싫은건 아님)<br>언제부터인지 필자도 이러한 부분에 갈증을 느끼며 회사와는 별도로 무언가를 만들어 보고 싶은 마음이 무럭무럭 생겨날 즈음 facebook 타임라인에서 개발자와 디자이너가 약 7주간 프로젝트를 진행하는 <code>D.light 투게더톤</code> 이라는 행사가 있다는 것을 발견하고 나름 정성스레 지원서를 작성 후 합격 메일을 받게 된다. (<a href="https://www.facebook.com/groups/gdgseoul/permalink/1265219273647317/" target="_blank" rel="noopener">GDG Facebook 해당 게시글</a>)<br>이번 포스팅에서는 해커톤과는 살짝 성격이 다른 <code>D.light 투게더톤</code>을 진행하면서 느꼈던 부분들과 진행한 결과물에 대해 간략히 리뷰를 해보며 정말 <code>급행</code>처럼 지나간 약 7주간을 돌이켜 보는 시간을 갖고자 한다.</p><h3 id="팀-빌딩"><a href="#팀-빌딩" class="headerlink" title="# 팀 빌딩"></a># 팀 빌딩</h3><div class="figure center" style="width:;"><a class="fancybox" href="team_build.jpg" title="눈도 못마주칠 정도로 어색한 첫날<br>Team. 그팽" data-caption="눈도 못마주칠 정도로 어색한 첫날<br>Team. 그팽" data-fancybox="default"><img class="fig-img" src="team_build.jpg" alt="눈도 못마주칠 정도로 어색한 첫날<br>Team. 그팽"><span class="image-caption">눈도 못마주칠 정도로 어색한 첫날<br>Team. 그팽</span></a><span class="caption">눈도 못마주칠 정도로 어색한 첫날<br>Team. 그팽</span></div><div style="clear:both;"></div><p>총 6개 팀 중에 필자는 여자 디자이너 두 분, 남자 안드로이드 개발자 두 분을 포함한 팀에 속하게 되었다. 5명 중 해커톤 참여 경험이 있다는 이유만으로 여자 디자이너 분께서 팀장이 되시고, 7주라는 시간이 정말 급하게 지나갈 것 같다는 억지(?) 이유를 들먹여 <code>그팽</code>이라는 팀 이름이 정해졌다. 그렇게 “우리가 정말 무엇을 만들 수 있을까?” 하는 의구심 속에 프로젝트가 시작이 되었다. </p><h3 id="프로젝트-진행-전반"><a href="#프로젝트-진행-전반" class="headerlink" title="# 프로젝트 진행 전반"></a># 프로젝트 진행 전반</h3><p>신기하게도 우리 5명은 각각 사는 지역이 전부 달랐다. (심지어 한 분은 매주 저 멀리 충청남도 천안에서 올라오셔야 하는 수고를 ㅠㅠ) 매 주말마다 오프라인으로 만나서 회의를 진행했다. 그래야 길다면 길고 짧다면 짧은 7주 안에 완성도 높은 결과물을 만들 수 있을 것 같아서였다. 프로젝트의 주제를 정하는 아이디어 회의에서 정해진 우리의 목표는 “동네 마트 할인 정보를 알려주는 앱”을 만들기로 하였다.<br><div class="figure center" style="width:;"><a class="fancybox" href="diagram.jpg" title="시간가는줄 몰랐던 아이데이션 회의" data-caption="시간가는줄 몰랐던 아이데이션 회의" data-fancybox="default"><img class="fig-img" src="diagram.jpg" alt="시간가는줄 몰랐던 아이데이션 회의"><span class="image-caption">시간가는줄 몰랐던 아이데이션 회의</span></a><span class="caption">시간가는줄 몰랐던 아이데이션 회의</span></div><div style="clear:both;"></div></p><p>팀워크가 중요한 <code>투게더톤</code> 임에도 불구하고 여느 천재 디자이너, 천재 개발자처럼 <code>일당백</code> 스타일로 뚝딱 만드는 그런 프로젝트의 진행 방식은 피하려고 우리 모두가 노력하였다. 되도록이면 이렇게 모인 다섯 명이 한마음 한뜻으로 각자가 생각하는 크기와 양은 다르겠지만 이 프로젝트를 통해 무엇이라도 배울 수 있었으면 했다. 디자이너 분들은 서로 디자인하신 시안에 대해 공유를 하면서 개선해 나가는 모습과, 안드로이드 개발자 두분은 (거의 매일) 밤마다 서로 슬랙에서 개발 방법론에 대해 스터디를 하는 모습이 보기 너무 보기 좋았다. 물론 필자도 아무것도 없는 환경에서 백엔드 서버를 구축하고 API를 만드는 과정 속에서 정말 많은것을 배울 수 있었다.<br>그렇게 시간이 흘러 마지막 발표하는 전날엔 팀원 몇 분과 함께 꼬박 밤을 새우며 프로젝트 결과물의 완성도를 높이는데 노력하였고 필자 개인적으로 아주 성공적으로 프로젝트를 마무리할 수 있었다.</p><h3 id="개발-진행"><a href="#개발-진행" class="headerlink" title="# 개발 진행"></a># 개발 진행</h3><p>안드로이드 개발자분들은 코틀린 기반으로 개발을 하였다. 여러 디자인 패턴과 다양한 기술들을 사용하였다고 들었는데 필자는 아쉽게도 백엔드 개발을 하다 보니 전부를 이해하지는 못하였다.<br>예전에 토이 프로젝트를 파이썬 기반으로 해본 경험이 있어서 Flask 또는 Django 기반으로 API 서버를 구축해볼까 하고 고민하였다. 하지만 (Spring Boot 기반으로도 해보고 싶었고) 파이썬보다는 자바 기반으로 다양한 어플리케이션의 요구 사항을 개발하는데 조금 더 능숙할 것 같아서 Spring Boot 기반으로 개발 환경을 구성하였다.<br>서버는 AWS 프리티어의 EC2를 발급받고 DB 또한 AWS에서 제공해주는 RDS(mysql)을 발급받아 구성하였다. 그리고 DNS는 예전에 무료 도메인을 찾다가 알게 된 <a href="http://mooo.com/" target="_blank" rel="noopener">http://mooo.com/</a> 라는 서비스에서 발급받아 연결하였고, 프로젝트 기능 중에 서버에서 앱으로 푸시를 하는 기능이 있었는데 Firebase를 활용해서 구성할 수 있었다.<br><div class="figure center" style="width:;"><a class="fancybox" href="server.jpg" title="사용한 기술들" data-caption="사용한 기술들" data-fancybox="default"><img class="fig-img" src="server.jpg" alt="사용한 기술들"><span class="image-caption">사용한 기술들</span></a><span class="caption">사용한 기술들</span></div><div style="clear:both;"></div></p><p>Entity Relationship Diagram (ERD) 는 무료로 인터넷에서 사용할 수 있는 툴이 있는지 찾다보니 <a href="http://aquerytool.com/" target="_blank" rel="noopener">http://aquerytool.com/</a> 라는 서비스가 있었고 (무려 한글…) 약간 부족하였지만 테이블들을 구성하고 연결관계를 표현하기에는 정말 간단하고 쉽게 사용할 수 있었다.<br><div class="figure center" style="width:;"><a class="fancybox" href="erd.jpg" title="테이블 관계도. PK, FK 등 완벽하진 않다." data-caption="테이블 관계도. PK, FK 등 완벽하진 않다." data-fancybox="default"><img class="fig-img" src="erd.jpg" alt="테이블 관계도. PK, FK 등 완벽하진 않다."><span class="image-caption">테이블 관계도. PK, FK 등 완벽하진 않다.</span></a><span class="caption">테이블 관계도. PK, FK 등 완벽하진 않다.</span></div><div style="clear:both;"></div></p><p>개발환경을 구성하면서 어떤 부분들은 보기만 해보고 사용만 해봤지 실제로 구성을 해보지는 않아서 정말 막막한 부분도 있었고 특히 내가 이것 하나 못하는가 하며 자괴감이 들때도 있었지만 그러면서 많은것을 배울 수 있었고 다시 해보라고 하면 머릿속에 전체 아키텍쳐가 그림으로 그려질 만큼 자신감이 조금이라도 생겨서 다행이라고 생각한다.</p><h3 id="프로젝트-결과"><a href="#프로젝트-결과" class="headerlink" title="# 프로젝트 결과"></a># 프로젝트 결과</h3><p><a href="http://magarine.mooo.com" target="_blank" rel="noopener">http://magarine.mooo.com</a><br>우리가 만든 서비스는 마트 가격 내린다 는 의미에서 <code>마가린</code> 이라는 이름으로 만들었고 그에 걸맞는 앱 아이콘이 만들어졌다. 필자는 이 아이콘을 볼때마다 심쿵거릴정도로 너무 이쁜것 같다.<br><div class="figure center" style="width:;"><a class="fancybox" href="magarine.jpg" title="마가린이 무려 천막을 달고 마트가 되었는데 할인이 되었기에 잘려 나가는 아트웤(?)을 표현해주셨다. 키햐... 무슨말이 필요하는가" data-caption="마가린이 무려 천막을 달고 마트가 되었는데 할인이 되었기에 잘려 나가는 아트웤(?)을 표현해주셨다. 키햐... 무슨말이 필요하는가" data-fancybox="default"><img class="fig-img" src="magarine.jpg" alt="마가린이 무려 천막을 달고 마트가 되었는데 할인이 되었기에 잘려 나가는 아트웤(?)을 표현해주셨다. 키햐... 무슨말이 필요하는가"><span class="image-caption">마가린이 무려 천막을 달고 마트가 되었는데 할인이 되었기에 잘려 나가는 아트웤(?)을 표현해주셨다. 키햐... 무슨말이 필요하는가</span></a><span class="caption">마가린이 무려 천막을 달고 마트가 되었는데 할인이 되었기에 잘려 나가는 아트웤(?)을 표현해주셨다. 키햐... 무슨말이 필요하는가</span></div><div style="clear:both;"></div></p><p>정말 간단하게 말하자면 일종의 쇼핑몰을 만들었다. 물건을 사고자 하는 사용자는 손쉽게 위치기반으로 근처 동네 마트의 할인 상품을 한눈에 확인 가능하고, 물건을 파는 마트 주인은 간단하고 편하게 홍보를 하는 서비스이다. 아쉽게도 물건을 파는 마트 주인을 위한 앱은 시간관계상 못 만들었지만 추후 기회가 된다면, 그리고 팀원들과 논의후 만들어 볼 계획이다.<br>프로젝트 소개 페이지에서 적어 놓은 것 처럼 여러가지 기능을 구현하였다. 그것도 완벽하게. </p><ul><li>단골마트 : 주변의 마트 또는 슈퍼를 지도에서 찾아 단골마트로 지정하고 마트의 전단지를 보며 행사를 확인할 수 있음</li><li>상품검색 : 단골마트에서 팔고있는 상품들을 검색이 가능</li><li>장보기 메모 : 상품 상세 페이지에서 구매할 수량을 선택하고 장보기 메모에 담아서 나중에 구매 또는 취소를 할 수 있음</li><li>장보기 메모 내역 : 이제까지 구매했던 이력을 확인할 수 있고 마치 가계부처럼 자신의 소비 습관을 해당 메뉴에서 분석할 수 있음</li><li>할인 알림 설정 : 원하는 상품이 있다면 알림설정을 할 수 있고 판매자가 상품을 등록하는 순간 푸시메세지로 정보를 알려줌</li></ul><p>아래는 발표 자료. 매년마다 어떤 행사에서라도 꼭 발표를 한 번 이상 하자는 나와의 약속을 이번 <code>D.light 투게더톤</code>에서 달성할 수 있어서 좋았다. 물론 이번 발표때도 여유라곤 찾을 수 없었지만…</p><iframe src="//www.slideshare.net/slideshow/embed_code/key/DzmojsEbuBMJus" width="750" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>결국 여러 심사조건(?)으로 6개 팀중 상위 2팀에게 주는 sketch 라이센스를 받게 되었고 (필자피셜) 만족할만한 마무리가 될 수 있었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="result.jpg" title="우리 다섯명 팀원들의 캐릭터(By ZEPETO), 최종발표 장소인 구글캠퍼스, sketch 라이센스" data-caption="우리 다섯명 팀원들의 캐릭터(By ZEPETO), 최종발표 장소인 구글캠퍼스, sketch 라이센스" data-fancybox="default"><img class="fig-img" src="result.jpg" alt="우리 다섯명 팀원들의 캐릭터(By ZEPETO), 최종발표 장소인 구글캠퍼스, sketch 라이센스"><span class="image-caption">우리 다섯명 팀원들의 캐릭터(By ZEPETO), 최종발표 장소인 구글캠퍼스, sketch 라이센스</span></a><span class="caption">우리 다섯명 팀원들의 캐릭터(By ZEPETO), 최종발표 장소인 구글캠퍼스, sketch 라이센스</span></div><div style="clear:both;"></div><p>발표에서도 몇번을 반복하며 이야기 했지만 이런 팀원들을 또 만날 수 있을까 하는 생각과 함께 다시한번 팀원들에게 감사하다는 말을 전하고 싶다. 그리고 아무것도 정해지지 않는 상황과 아무것도 구축되어 있지 않은 개발환경에서 나름 구현하고자 했던 기능을 구현하며 멋지게 마무리 할수 있어 다행이라 생각하고 다양한 트러블슈팅 속에서 나름 많은것을 배울 수 있었다.<br>머릿속에 있는 것과 그것을 말로 설명할 수 있는 것, 나아가 그것을 직접 내 손으로 해보고 문제를 해결해 나가는 것은 엄청난 차이가 있다고 생각한다. 그러한 과정들 속에서, 그리고 이렇게 다양한 사람들과의 협업을 통해 배우는 것 또한 분명히 있고 그것을 오롯히 내것으로 만드는게 마지막으로 남겨진 숙제인것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;회사일을 하다 보면 시키는 대로 혹은 팀의 목표에 부합하기 위해 어쩔 수 없이 해야 하는 일을 하게 된다. 그러한 일이 재미있고 결과물에 대한 만족도가 100% 라면 다행이지만 간혹 재미도 없고 시켜서 하는 일은 밤을 꼬박 새 가면서 완성을 해도 썩 그렇게 만족스럽지 못한 경우가 대부분인 것 같다.
    
    </summary>
    
      <category term="review" scheme="https://taetaetae.github.io/categories/review/"/>
    
    
      <category term="hackathon" scheme="https://taetaetae.github.io/tags/hackathon/"/>
    
      <category term="gdg" scheme="https://taetaetae.github.io/tags/gdg/"/>
    
  </entry>
  
  <entry>
    <title>자바, 성능, 모니터링 테크세미나 정리 및 후기 (by 우아한 형제들)</title>
    <link href="https://taetaetae.github.io/2019/05/12/got-of-java-seminar/"/>
    <id>https://taetaetae.github.io/2019/05/12/got-of-java-seminar/</id>
    <published>2019-05-12T11:04:01.000Z</published>
    <updated>2019-05-30T08:14:51.849Z</updated>
    
    <content type="html"><![CDATA[<p>실무에서 자바 기반으로 개발을 하고 서비스를 운영을 하다보면 처음엔 아무런 문제가 없다가 사용자가 몰리는 등 이벤트성으로 트래픽이 많아질 경우 꼭 문제가 생기기 마련이다. 그럴때면 뒤늦게 부랴부랴 원인을 찾고 개선하기 바빠지게 된다.  <a id="more"></a> (아마 윗분들에게 혼나면서?ㅠㅠ)<br>평소에 이런 성능문제를 개선하고 미리 모니터링 할수있는 부분에 대해 관심을 갖고 있었던 찰나, 우아한 형제들에서 <a href="https://www.facebook.com/woowahanTech/photos/a.1925530564354206/2280664485507477" target="_blank" rel="noopener">5월 우아한 테크 세미나</a>를 한다기에 부랴부랴 장문의 글로 신청을 하였고 운이 좋아 당첨이 되었다.<br>한창 회사에서 새로운 서비스 출시, 그리고 잠을 줄여가며 별도로 진행하고 있던 토이프로젝트 등 여러가지로 바쁜 시기였지만 특히 예전부터 뵙고싶던 이상민님께서 직접 강의를 해주신다기에 피곤한 심신을 이끌고 세미나에 참석하였고 그 후기를 적어보고자 한다.</p><blockquote><p>두레이로 만드신 발표자료를 공유해 주셨지만 저작권 문제도 있고 해서 필자기준에서 이해한 부분에 대해서만 공유하고자 한다. 더불어 그냥 듣고 앵무새처럼 발표내용 그대로를 공유하는건 의미가 없다고 생각되어…</p></blockquote><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="1.jpg" title="포스터만 봐도 벌써부터 가슴이 뛴다(?)." data-caption="포스터만 봐도 벌써부터 가슴이 뛴다(?)." data-fancybox="default"><img class="fig-img" src="1.jpg" alt="포스터만 봐도 벌써부터 가슴이 뛴다(?)."><span class="image-caption">포스터만 봐도 벌써부터 가슴이 뛴다(?).</span></a><span class="caption">포스터만 봐도 벌써부터 가슴이 뛴다(?).</span></div><div style="clear:both;"></div><h3 id="성능"><a href="#성능" class="headerlink" title="# 성능"></a># 성능</h3><p>구글에서 작성한 <a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/" target="_blank" rel="noopener">성능이 중요한 이유</a> 라는 아티클을 공유해 주셨다. (시간이 된다면 한번 읽어보길 강추, 무려 한글!) 어플리케이션에서 성능은 사용자의 증가, 이탈율, 응답속도에 영향이 있고 이는 결국 추구하는 가치(이를 테면 수익)에 직면한다고 한다.<br>사용자는 어느 관점에서 바라보는가에 따라 달라지고 각 관점에 따라 성능을 챙겨야 하는 부분이 달라진다. 수강신청을 하는 시점에서의 사용자와 뉴스 페이지를 읽는 시점에서의 사용자는 각 성격이 엄연히 다른것처럼. </p><ul><li>시스템 관리자<ul><li>등록된 / 등록되지 않은 사용자</li></ul></li><li>서버 관점<ul><li>로그인된 / 로그인 하지 않은 사용자</li></ul></li><li>성능 테스터 관점<ul><li>Active User<ul><li>서버에 부하를 주는 사용자</li><li>메뉴나 링크를 누르고 결과가 나오기를 기다리는 사용자</li><li>성능테스트시 Vuser와 거의 동일 ( Vuser : 가상사용자(virtual user) )</li></ul></li><li>Concurrent user<ul><li>서버에 부하를 주고 있거나, 줄 가능성이 매우높은 서비스에 접속중인 사용자</li><li>웹 페이지를 띄워놓은 사용자</li></ul></li></ul></li></ul><p>TPS(Transaction Per Seconds)는 초당 얼마나 많은 요청을 처리할수 있는지에 대한 시스템의 절대적인 수치로 볼수있다. (개발자는 어느상황에서든지 대충 감으로 이야기 하지말고 정확한 수치로 이야기 해야한다는 뼈를 때리는 조언과 함께…)  TPS는 Scale out/up을 통해 증가시킬수 있지만 Response Time 은 불가능하다. 물론 어플리케이션을 튜닝하면 두 수치 모두 개선이 가능하다. 이러한 TPS와 Response Time의 최대치는 출시전에 반드시 테스트를 통해 알고 있어야 이슈발생시 대응하는데 유용하다.<br>Bottleneck 즉 병목은 장비, 어플리케이션, 저장소, 설정 등 다양한 상황에서 발생할수 있다. 그중에 “아주 일반적”으로 가장 병목이 많이 발생하는 구간은 DB이고 그 다음으로 클라이언트(Web page, App), Network이 있을 수 있다.<br>결론은 <strong>Performance engineering is “Composite Art” of IT</strong> 라는 하나의 문장으로 정리를 해주셨다. 아무리 이쁜 디자인과 어렵고 복잡한 기능이 있을지라도 성능이 뒷받침 안된다면 대용량 트래픽 상황에서는 무의미해지기 때문이라고 생각한다.</p><h2 id="자바"><a href="#자바" class="headerlink" title="# 자바"></a># 자바</h2><p>자바의 역사에 대해 설명해 주셨다. ( 역사에 대한 보다 자세한 설명은 <a href="https://www.whatap.io/blog/12/" target="_blank" rel="noopener">https://www.whatap.io/blog/12/</a> 참고 ) 언제부터인가 JDK 라이센스 이슈가 많았었는데 실무에서 개발하는 입장에서는 java 8 에서는 문제가 안되고 java 11부터 라이센스 문제가 복잡하게 생길수 있다고 한다. 이부분은 공식문서(?)를 찾아보는게 좋을듯 하다. (개인 또는 회사에서 사용할 경우 상황에 따라 법적 이슈가 생길수도, 안생길수도 있는 복잡한 문제가 있어보여서… 필자도 제대로 이해하지는 못했다ㅠ)</p><p>그리고 각 자바 버전에서 발표한 새로운 기능에 대해 설명해주셨다.</p><ul><li>Java 8<ul><li>lambda, stream, default method, LocalDate / LocalTime 추가</li><li>stream 과 foreach 의 성능은 거의 차이 없음 (오히려 가독성이 나빠질수도 있다.)</li><li>ParallelStream 은 해당 장비의 cpu 개수만큼 스레드 풀을 만들어 사용 (오히려 독이 될수 있으니 잘 알아보고 사용할것)</li></ul></li><li>Java 9<ul><li>Compact Strings : char[] &gt; byte[]</li><li>G1 default GC : <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></li><li>Collections of (불변) : List.of, Set.of, Map.of</li></ul></li><li>Java 10<ul><li>var 의 등장</li><li>Application Class-Data Sharing(AppCDS)</li></ul></li><li>Java 11<ul><li>Oracle JDK의 유료화</li><li>Http Client. 기본 설정값들을 제대로 알고 써야한다. ( <a href="https://golb.hplar.ch/2019/01/java-11-http-client.html" target="_blank" rel="noopener">https://golb.hplar.ch/2019/01/java-11-http-client.html</a> )</li></ul></li><li>Java 12<ul><li>Switch expressions</li><li>Shenandoah : <a href="https://www.youtube.com/watch?v=E1M3hNlhQCg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=E1M3hNlhQCg</a></li></ul></li></ul><h2 id="모니터링"><a href="#모니터링" class="headerlink" title="# 모니터링"></a># 모니터링</h2><p>유명한 상용 APM들을 설명해 주셨다. 각각의 장점에 대해 설명해 주셨는데 정말 회사에 요청해 구매할수만 있다면 사서 해보고 싶을정도로 신기한 기능이 많았다. 그중 dynatrace 는 에이전트만 설치해두면 별도의 설정 필요없이 알아서 해준다고…</p><ul><li>dynatrace (<a href="https://www.dynatrace.com/" target="_blank" rel="noopener">https://www.dynatrace.com/</a>)</li><li>new relic (<a href="https://newrelic.com/" target="_blank" rel="noopener">https://newrelic.com/</a>)</li><li>AppDynamics (<a href="https://www.appdynamics.com/" target="_blank" rel="noopener">https://www.appdynamics.com/</a>)</li><li>WhaTap (<a href="https://www.whatap.io/" target="_blank" rel="noopener">https://www.whatap.io/</a>)</li></ul><p>오픈소스로는 스카우터와 핀포인트를 설명해 주셨다. 필자는 핀포인트로 회사 서비스를 모니터링 중에 있는데 스카우터에도 좋은 기능이 많아 보여 기회가 된다면 개발서버에 설치해서 핀포인트와 각각 장단점을 비교해 보고 싶어질 정도로 스카우터 자랑을 엄청 해주셨다. (NHN에서는 스카우터로 모니터링 하고 있다고 하니 더욱더 관심이 가게 되었다.)</p><ul><li>scouter (<a href="https://github.com/scouter-project/scouter" target="_blank" rel="noopener">https://github.com/scouter-project/scouter</a>)</li><li>pinpoint (<a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">https://github.com/naver/pinpoint</a>)</li></ul><p>APM 즉, Application Performance Management의 핵심은 바로 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/package-summary.html" target="_blank" rel="noopener">java.lang.instrument</a> package 와 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html" target="_blank" rel="noopener">Java ClassFileTransformer</a> 에 있다고 하셨다. 마치 Spring의  AOP처럼.</p><p>이번 세션의 결론은 처음에 이야기 하신 부분과 비슷한 “절대로 단정짓지 마라 ! 데이터로 이야기 하자 !” 라는 문장으로 정리를 해주셨다. 그만큼 테스트를 많이 해보고 평소에 모니터링을 자주 해가며 서비스의 안정성을 높여야 한다는 뜻으로 이해했다.<br>끝으로 Q&amp;A가 있어 평소에 궁금했던 질문을 드렸고 너무 친절하게 화이트보드에 그래프를 그려주시면서 (원래 강의시간보다 30분정도 더 하게 만든 장본인…ㅠㅠ) 답변을 해주셨다.</p><p>Q. Application의 상태를 확인하기 위해 각종 모니터링 툴을 활용하는데, 오히려 모니터링이 과하다 보면 Application 성능에 영향을 주게 된다. 어떻게 해야하는가?</p><p>A. 모니터링툴을 홍보하는 쪽에서는 당연히 성능에 영향이 없다고 한다. 하지만 먼저 개발서버에서 테스트를 해봐서 모니터링툴이 있고 없고의 서비 리소스의 차이를 확인해보고 조금씩 적용범위를 늘려가는 식으로 해보는것도 하나의 방법이 될 수 있다. 또한 샘플링을 통해 일부분만 확인하는 방법도 있다. (필자가 이용하는 pinpoint는 request의 20% 이런식으로 샘플링을 하고 있었는데 scouter에서는 response time기준으로 샘플링이 되나보다?ㄷㄷ)</p><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="2.jpg" title="너무 두서없이 적었나..." data-caption="너무 두서없이 적었나..." data-fancybox="default"><img class="fig-img" src="2.jpg" alt="너무 두서없이 적었나..."><span class="image-caption">너무 두서없이 적었나...</span></a><span class="caption">너무 두서없이 적었나...</span></div><div style="clear:both;"></div><p>그리고 필자의 질문 때문이였는지 실무에서 있었던 장애시 그래프 사례를 보여주시며 끔찍한(?) 상황까지 재밌게 표현해 주시며 약 3시간여 진행된 세미나가 마무리 되었다.</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>자바로 Application개발을 하면서 성능과 모니터링은 마치 삼겹살엔 소주, 치킨에 맥주처럼 정말 떼려야 뗄 수 없는 사이인것 같다. 우아한 형제들에서 주최한 이번 기술 세미나는 필자에게 정말 많은것을 배우게 해준 좋은 행사였다. 그리고 회사에 가면 짬나는 시간을 활용해서 스카우터로 성능테스트를 해볼 계획이다. (라고 말하면 안되고 점심에 졸려서 성능테스트를 해봤다고 말해야 직장 상사가 좋아하신다 라고 말씀해주셨다 ㅎㅎ)</p><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="3.jpg" title="질문을 해야 내것이 된다는 나와의 약속을 이번에도 지킬수 있었다! (질문하고 받은 배달의 민족 쿠폰!)" data-caption="질문을 해야 내것이 된다는 나와의 약속을 이번에도 지킬수 있었다! (질문하고 받은 배달의 민족 쿠폰!)" data-fancybox="default"><img class="fig-img" src="3.jpg" alt="질문을 해야 내것이 된다는 나와의 약속을 이번에도 지킬수 있었다! (질문하고 받은 배달의 민족 쿠폰!)"><span class="image-caption">질문을 해야 내것이 된다는 나와의 약속을 이번에도 지킬수 있었다! (질문하고 받은 배달의 민족 쿠폰!)</span></a><span class="caption">질문을 해야 내것이 된다는 나와의 약속을 이번에도 지킬수 있었다! (질문하고 받은 배달의 민족 쿠폰!)</span></div><div style="clear:both;"></div><p>1,2 회 모두 탈락해서 못들었지만 다음에도 이런 기술관련 행사가 있으면 꼭 듣고 싶고 마지막으로 필자에 질문에 너무 성실하게 답변해 주시고 재밌고 귀에 쏙쏙 들어오는 강연을 해주신 이상민님께 이 포스팅으로나마 다시한번 감사의 말씀을 전하고 싶다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;실무에서 자바 기반으로 개발을 하고 서비스를 운영을 하다보면 처음엔 아무런 문제가 없다가 사용자가 몰리는 등 이벤트성으로 트래픽이 많아질 경우 꼭 문제가 생기기 마련이다. 그럴때면 뒤늦게 부랴부랴 원인을 찾고 개선하기 바빠지게 된다.
    
    </summary>
    
      <category term="review" scheme="https://taetaetae.github.io/categories/review/"/>
    
    
      <category term="java" scheme="https://taetaetae.github.io/tags/java/"/>
    
      <category term="performance" scheme="https://taetaetae.github.io/tags/performance/"/>
    
      <category term="monitoring" scheme="https://taetaetae.github.io/tags/monitoring/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot에서 mybatis로 mysql 연동하기</title>
    <link href="https://taetaetae.github.io/2019/04/21/spring-boot-mybatis-mysql-xml/"/>
    <id>https://taetaetae.github.io/2019/04/21/spring-boot-mybatis-mysql-xml/</id>
    <published>2019-04-21T13:47:04.000Z</published>
    <updated>2019-05-30T08:14:51.918Z</updated>
    
    <content type="html"><![CDATA[<p>실무에서 개발을 하다보면 과거 누군가 잘 구성해 놓은 밥상(legacy)에 숟가락만 얹는 느낌으로 <code>로직 구현</code>만 할때가 있다. 그러다보면 각종 레이어가 어떻게 구성(설정)되어있는지도 모르고 <a id="more"></a> 간혹 설정에서 문제가 발생하면 “아 내가 이것도 모르고 이제까지 개발을 해왔나” 하는 자괴감이 들며 몇시간을 삽질하는 경우가 있다. 그게 지금의 필자인것 같다. (눙물…)<br><div class="figure center" style="width:;"><a class="fancybox" href="mung.jpg" title="<br>출처 : http://blog.naver.com/PostView.nhn?blogId=ondo_h&logNo=221437452142" data-caption="<br>출처 : http://blog.naver.com/PostView.nhn?blogId=ondo_h&logNo=221437452142" data-fancybox="default"><img class="fig-img" src="mung.jpg" alt="<br>출처 : http://blog.naver.com/PostView.nhn?blogId=ondo_h&logNo=221437452142"><span class="image-caption"><br>출처 : http://blog.naver.com/PostView.nhn?blogId=ondo_h&logNo=221437452142</span></a><span class="caption"><br>출처 : http://blog.naver.com/PostView.nhn?blogId=ondo_h&logNo=221437452142</span></div><div style="clear:both;"></div></p><p>사이드 프로젝트 초기셋팅을 하며 호기롭게 spring boot 최신버전에서 db를 연동하려 했는데 막상 완전 바닥부터 해본 경험이 적다보니 (spring boot 2 버전에서는 더욱더…) 어디서부터 뭘 설정을 해야할지… 그리고 <code>이럴때 보는</code> 도큐먼트를 봐도 잘 이해가 안되어 삽질을 해가며 당황하기 일쑤였다.<br>이번 포스팅에서는 아래와 같은 구성을 하는데 목표를 두고자 한다.</p><ul><li>Spring Boot 2 프로젝트를 처음 만들고 </li><li>mybatis 를 사용해서</li><li>mysql 을 연동하는것 (AWS 의 RDS를 사용, 추후 RDS사용법에 대해 블로깅 예정)</li></ul><p>위와 같은 상황을 처음 접하는 분들께 도움이 되었으면 하는 바램으로 짧게나마 필자의 삽질기를 여행해보자.</p><h3 id="Spring-boot-2-프로젝트-만들기"><a href="#Spring-boot-2-프로젝트-만들기" class="headerlink" title="# Spring boot 2 프로젝트 만들기"></a># Spring boot 2 프로젝트 만들기</h3><p>필자는 IntelliJ를 사용하고 있어서 새로 프로젝트를 만들려고 할때 클릭 몇번만으로 dependency 설정까지 다 해주기 때문에 편하고 좋았다. 혹 이클립스나 다른 IDE를 사용하고 있다면 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 을 참고하면 도움이 될것같다. 여기서도 클릭 몇번으로 IntelliJ 에서 해주는 것처럼 내가 사용할 모듈을 선택하고 generate 를 누르면 프로젝트가 생성되어 다운로드 받아진다. (참 좋은 세상…)<br>우선 File → New → Project 를 눌러서 아래 창을 열어보자. 그리고 뭔가 다 해줄것 같은 (개발도 해주면 안되나…) <code>Spring Initializr</code>을 선택후 아래와 같은 설정을 적어준 뒤 다음을 눌러준다.</p><div class="figure center" style="width:;"><a class="fancybox" href="1.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="1.jpg" alt=""></a></div><div style="clear:both;"></div><p>사용할 모듈을 선택해주자. 필자는 이것저것(?)을 도와주는 <code>lombok</code>과 <code>Mybatis</code>, <code>MySQL</code>을 선택하고 프로젝트를 생성하였다. 그러면 이쁜(?) pom.xml 과 함께 당장 개발을 시작할 수 있는 환경이 제공된다.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><div class="figure center" style="width:;"><a class="fancybox" href="2.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="2.jpg" alt=""></a></div><div style="clear:both;"></div><p>우선 여기까지 잘 되었는제 확인해보기 위해 Controller 에 현재시간을 출력하는걸 만들어 보고<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/helloWorld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>톰켓을 실행해보면 정상적으로 접속과 출력이 되는것을 확인할 수 있다.</p><div class="figure center" style="width:;"><a class="fancybox" href="3.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="3.jpg" alt=""></a></div><div style="clear:both;"></div><h3 id="MySQL-연동하기"><a href="#MySQL-연동하기" class="headerlink" title="# MySQL 연동하기"></a># MySQL 연동하기</h3><p>필자가 허둥지둥 했던점 중 하나는 MyBatis와 MySQL을 동시에 연동하려고 하다보니 문제가 발생해도 어디서의 문제인지를 제대로 파악하지 못하고 삽질했다는 점이다. 여기서 정확히 짚고 넘어가면 우선 데이터를 연결해주는 ORM인 MyBatis를 셋팅해준 다음 MySQL을 연동해주는 식으로 분리해서 설정을 하면 햇갈리지 않고 (돌아가지 않고) 보다 빠르게 설정이 가능할것 같다. (여기서 순서는 중요하지 않고 별도로 설정해야 한다는 관점이 중요한것 같다.)<br>우선 <code>src/main/resources</code>폴더에 있는 <code>application.properties</code> 에 다음처럼 작성해주자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.hikari.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.hikari.jdbc-url=jdbc:mysql://&#123;url&#125;:&#123;port&#125;/&#123;db&#125;</span><br><span class="line">spring.datasource.hikari.username=&#123;id&#125;</span><br><span class="line">spring.datasource.hikari.password=&#123;password&#125;</span><br></pre></td></tr></table></figure></p><p>위의 jdbc-url 항목에서 AWS에서 제공하는 RDS를 사용하는 경우 RDS에서 제공해주는 엔드포인트와 포트를 적어주면 된다. (추후 AWS - RDS에 대해 블로깅 예정이다.)<br>Spring Boot 2.0 이후부터 기본적으로 사용되는 커넥션 풀이 HikariCP로 변경되었다고 한다. (<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes#hikaricp" target="_blank" rel="noopener">링크</a>) 커넥션 풀 종류중 성능이 좋다고 하는데 <a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">링크</a>를 가보면 다른 커넥션 풀 라이브러리와 성능을 비교한 벤치마크 결과를 확인할 수 있다.<br>위처럼 <code>spring.datasource.hikari</code> 가 prefix로 붙고 각종 정보들을 적어주어 config 에서 인식될수 있도록 해주자. 그 다음 DataSource 설정을 해준다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/application.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.hikari"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> HikariConfig <span class="title">hikariConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HikariConfig();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DataSource dataSource = <span class="keyword">new</span> HikariDataSource(hikariConfig());</span><br><span class="line">log.info(<span class="string">"datasource : &#123;&#125;"</span>, dataSource);</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 내용은 DataSource 를 hikariConfig에서 설정한 정보로 만들어 준다는 의미이다. 이렇게만 하고 프로젝트를 다시 실행시켜보면 logger 에 의해 datasource 의 정보를 볼수가 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-22 00:27:35.048  INFO 23040 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2019-04-22 00:27:36.221  INFO 23040 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">2019-04-22 00:27:36.222  INFO 23040 --- [           main] c.e.m.config.DatabaseConfiguration       : datasource : HikariDataSource (HikariPool-1)</span><br><span class="line">2019-04-22 00:27:36.527  INFO 23040 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService &apos;applicationTaskExecutor&apos;</span><br></pre></td></tr></table></figure></p><p>여기까지 우선 Datasource 설정이 끝났다.<br>Q : <code>com.mysql.cj.jdbc.Driver</code> 에서 <code>cj</code>가 뭐지?<br>A : 해당 클래스는 더이상 사용하지 않아 <code>com.mysql.jdbc.Driver</code>로 설정하고 실행시켜보면 아래 문구를 볼수가 있다.</p><blockquote><p>Loading class `com.mysql.jdbc.Driver’. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</p></blockquote><p>당황하지 말고 클래스를 바꿔주자.</p><h3 id="MyBatis-연동하기"><a href="#MyBatis-연동하기" class="headerlink" title="# MyBatis 연동하기"></a># MyBatis 연동하기</h3><p>DB를 연동했으니 이제 쿼리를 작성하고 원하는 결과를 얻기위해 MyBatis를 활용할 차례다. 위에서 작성한 <code>DatabaseConfiguration</code>에 추가로 다음과 같이 작성해주자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">sqlSessionFactoryBean.setMapperLocations(applicationContext.getResources(<span class="string">"classpath:/mapper/**/*.xml"</span>));</span><br><span class="line"><span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 설정은 위에서 설정한 datasource를 사용하고 쿼리가 작성되는 xml위치를 지정해 줌으로써 추후 <code>Mapper</code> or <code>DAO</code> 레벨에서 사용되는 쿼리를 인식해주는 과정이다. 여기서 <code>classpath</code>는 <code>src/main/resourcs</code>이고 해당 쿼리가 있는 xml 위치는 본인의 취향대로 위치키시고 그에 맞도록 설정해주면 된다.<br>이렇게 한뒤 MySQL Workbench 로 DB에 접속후 임의의 데이터를 생성한 다음<br><div class="figure center" style="width:;"><a class="fancybox" href="4.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="4.jpg" alt=""></a></div><div style="clear:both;"></div><br>DAO 를 만들어 주고 이를 호출해보면 정상적으로 데이터를 읽어오는것이 확인된다.</p><ul><li><p>DAO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.express.magarine.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiDao</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE = <span class="string">"com.express.magarine.api."</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">selectName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sqlSession.selectOne(NAMESPACE + <span class="string">"selectName"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>query xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.express.magarine.api"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectName"</span> <span class="attr">resultType</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">SELECT name</span><br><span class="line">FROM test</span><br><span class="line">LIMIT 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApiDao apiDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/helloWorld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> String.format(<span class="string">"%s %s"</span>, apiDao.selectName(), LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>결과</p><div class="figure center" style="width:;"><a class="fancybox" href="5.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="5.jpg" alt=""></a></div><div style="clear:both;"></div></li></ul><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><div class="figure center" style="width:;"><a class="fancybox" href="gvsc.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="gvsc.png" alt=""></a></div><div style="clear:both;"></div><p>이 코드를, 그리고 이 포스팅을 작성하기 직전까지만 해도 “그냥 하면 되는거 아니야?”라고 생각했지만 알고있는 지식과 막상 해보는건 정말 하늘과 땅차이 라는걸 다시한번 느끼게 되었다. (자괴감의 연속…) 더불어 Spring Boot 의 간편함에 놀라웠고 이제 회사일이 조금 잠잠해졌으니 (과연?) Spring Boot로 이것저것 만들며 스터디를 해야겠다고 다짐해본다.<br>참고 URL</p><ul><li><a href="https://spring.io/guides/gs/accessing-data-mysql/" target="_blank" rel="noopener">https://spring.io/guides/gs/accessing-data-mysql/</a></li><li><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;실무에서 개발을 하다보면 과거 누군가 잘 구성해 놓은 밥상(legacy)에 숟가락만 얹는 느낌으로 &lt;code&gt;로직 구현&lt;/code&gt;만 할때가 있다. 그러다보면 각종 레이어가 어떻게 구성(설정)되어있는지도 모르고
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="mybatis" scheme="https://taetaetae.github.io/tags/mybatis/"/>
    
      <category term="spring-boot" scheme="https://taetaetae.github.io/tags/spring-boot/"/>
    
      <category term="mysql" scheme="https://taetaetae.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>AWS 프리티어 발급부터 EC2 접속까지</title>
    <link href="https://taetaetae.github.io/2019/04/14/aws-freetier-create-and-ssh-access/"/>
    <id>https://taetaetae.github.io/2019/04/14/aws-freetier-create-and-ssh-access/</id>
    <published>2019-04-14T08:39:03.000Z</published>
    <updated>2019-05-30T08:14:51.901Z</updated>
    
    <content type="html"><![CDATA[<p>IT 쪽에 일을 하고 있거나 관심을 가지고 있는 사람이라면 한번쯤을 들어봤을 AWS(Amazon Web Services). 이름에서도 알수있는 것처럼 아마존에서 제공하는 각종 원격 컴퓨팅 웹서비스이다. <a id="more"></a> 아마존은 이러한 서비스를 누구나 쉽게 접근해볼수 있도록 <a href="https://aws.amazon.com/ko/free/" target="_blank" rel="noopener">AWS 프리티어</a>를 제공해 주는데 이 프리티어 만으로도 과금없이 (또는 최소화 하여) 웹서비스를 구성할수 있다. 필자가 운영하고 있는 <a href="http://daily-devblog.com" target="_blank" rel="noopener">기술블로그 구독서비스</a>또한 AWS 프리티어로 운영되고 있다.<br>최근 GDG Seoul, P-typer, Sketch Seoul 에서 주최한 <a href="https://www.meetup.com/ko-KR/GDG-Seoul/events/259463050/" target="_blank" rel="noopener">D.light 345 투게더톤</a>에 참가하며 사이드 프로젝트를 하고 있는데 마침 AWS를 사용하게 되었다. 예전에 사용했을때는 장님 코끼리 만지듯이 설정을 했었는데 이번기회를 통해 다시한번 정리를 해본다.<br>본 포스팅에서는 AWS 계정을 발급받고 신용카드 확인까지 된 계정에서 EC2 서버를 발급받고 putty를 활용하여 서버에 접근을 해보는것을 목표로 둔다. </p><blockquote><p>(사이드 프로젝트를 하면서) 아마도 웹서비스를 개발하면서 AWS를 활용하는 부분에 대해 시리즈물로 포스팅을 하게 될것 같다.<br>사실 너무 간단해서 이런걸 글로 쓰나? 라고 할수도 있지만 눈으로만 보는것과 직접 해보는 것이 다르고, 이걸 다시 글로써 정리를 하는것 또한 완전 다른 부분이기 때문에 포스팅을 해본다.</p></blockquote><h3 id="EC2-생성하기"><a href="#EC2-생성하기" class="headerlink" title="# EC2 생성하기"></a># EC2 생성하기</h3><p>EC2? Amazon Elastic Compute Cloud의 약자로 물리서버가 아닌 클라우드 서버를 제공하고 있다. EC2의 장점은 서버의 스펙을 쉽고 자유롭게 조정할 수 있는점이 가장 매력있게 생각한다. 우선 콘솔에 들어가 EC2를 검색후 접속을 하고 <code>인스턴스 시작</code>을 눌러서 인스턴스 생성 화면으로 들어간다.<br><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="ec2-1.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="ec2-1.jpg" alt=""></a></div><div style="clear:both;"></div></p><p>AMI 즉 생성할 이미지를 선택하는 부분인데 여기서 주의할점은 잘못선택 했다간 계정 만들었을때의 카드로 생각지도 못할 금액이 결제가 되버릴수도 있다. (실제로 필자도 AWS를 처음 만져볼때 아무생각없이 좋아보이는걸로 했다가 한 30달러 정도를 지불했어야만 했다…) 좌측에 보면 <code>프리 티어만</code>이라는 체크박스를 체크하고 자신이 원하는 이미지를 선택하자. 일반적인 리눅스 서버를 발급받고 싶기 때문에 빨간 영역의 이미지를 선택하고 선택한 이미지의 스팩을 다시한번 확인하자. (cpu 1개에 메모리도 1기가… 너무 짜지만 무료니까…)<br><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="ec2-2.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="ec2-2.jpg" alt=""></a></div><div style="clear:both;"></div></p><p>마지막으로 <code>시작하기</code> 를 누르면 키 페어를 선택 또는 생성하도록 안내가 나오는데 당연히 아무것도 안한 상태라 <code>새 키 페어 생성</code>을 선택해 주고 이름을 지정한뒤 키 파일을 받아준다. 이 부분에서도 조심해야할 점이 키 페어를 한번 다운 받으면 다시 동일한 키 페어를 다운받을수가 없게 된다. (나중에 다시 발급을 받아야 하는 번거로운 문제가…) 다운을 받고 잊어버리지 않도록 잘 보관해두자.<br><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="ec2-3.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="ec2-3.jpg" alt=""></a></div><div style="clear:both;"></div></p><p>키 페어를 다운 받으면 생성중이라는 메세지와 함께 결과화면이 나온다. 여기서도 중요한 부분! <code>프리티어</code>라는 달콤한 키워드 때문에 들뜬 마음으로 성급하게 빨리 서버를 받아보고 싶다고 <code>다음다음 신공</code>을 하다보면 자칫 간과할수가 있는데 화면을 보면 <code>결제 알림 생성</code>이라는 다행스러운 기능이 있다. 별 어려운 설정이 아니니 꼭 설정을 해서 필자같이 기부(?)를 하는 일이 발생하지 않았으면 한다…<br><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="ec2-4.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="ec2-4.jpg" alt=""></a></div><div style="clear:both;"></div></p><p>EC2 인스턴스가 생성이 되었다. 인스턴스의 각종 정보를 확인할수가 있는데 public IP, public DNS 까지 제공되는것을 확인할 수 있다. (추후 DNS를 구입하게 되다면 이 IP에 연결을 시켜 도메인으로 해당 서버에 접속을 할수가 있게 된다.)<br><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="ec2-5.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="ec2-5.jpg" alt=""></a></div><div style="clear:both;"></div></p><h3 id="putty-로-발급받은-EC2-인스턴스에-접속을-해보자"><a href="#putty-로-발급받은-EC2-인스턴스에-접속을-해보자" class="headerlink" title="# putty 로 발급받은 EC2 인스턴스에 접속을 해보자."></a># putty 로 발급받은 EC2 인스턴스에 접속을 해보자.</h3><p>이제 발급받은 EC2 인스턴스에 접속을 해볼 차례이다. 다양한 서버 접속툴이 있지만 필자는 putty를 가장 선호한다. 디자인은 구닥다리처럼 보일지 모르겠지만 개인적으로 직관적인 UI에 가벼운 프로그램이라 생각이 든다. 우선 putty를 <a href="https://www.putty.org/" target="_blank" rel="noopener">다운</a> 받고 <code>putty.exe</code>를 실행시킨뒤에 바로 ssh 접속을 하면 너무 간단하게 서버 접속에 성공을 할수 있지만 위에서 받은 키 페어 파일을 다시 private key 로 전환해야 하는데 putty를 다운받으면 동일한 폴더에 <code>puttygen.exe</code>라는 파일을 실행시켜주자.<br>그다음 <code>pem</code>파일을 불러와서 마우스를 움직여서 게이지(?)를 다 채우고 <code>save private key</code>를 줄러 저장을 하는데 여기서 주의할점은 <code>ppk</code>파일명을 <code>pem</code>파일명과 동일하게 저장해야 한다는 것이다. (안그러면 서버 접속시 실패가 남… 삽질…)<br><div class="figure center" style="width:;"><a class="fancybox" href="putty-1.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="putty-1.jpg" alt=""></a></div><div style="clear:both;"></div> </p><p><code>putty.exe</code>를 실행시킨뒤 <code>Connection</code> &gt; <code>SSH</code> &gt; <code>Auth</code> 탭에서 방금 만들어 놓은 <code>ppk</code>파일을 불러오고, 다시 <code>Session</code>탭에서 host name 을 입력해주고 적당한 이름으로 저장을 눌러준다. 여기서 host name은 위에서 EC2 생성시 <code>Amazon Linux AMI</code>를 선택했기 때문에 사용자의 이름은 <code>ec2-user</code>가 되고 인스턴스의 정보중 public DNS와 함께 조합하여 다음과 같은 url을 적어준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ec2-user@&#123;public DNS&#125;</span><br><span class="line">e.g. ec2-user@ec2-###.compute.amazonaws.com</span><br></pre></td></tr></table></figure></p><div class="figure center" style="width:;"><a class="fancybox" href="putty-2.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="putty-2.jpg" alt=""></a></div><div style="clear:both;"></div> <p>이렇게 하고 해당 세션을 더블클릭 또는 하단에 <code>Open</code>을 누르게 되면 해당 서버로 접속이 되는것을 확인할 수 있다.<br><div class="figure center" style="width:;"><a class="fancybox" href="putty-3.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="putty-3.jpg" alt=""></a></div><div style="clear:both;"></div><br>사실 기술을 배움에 있어 가장 훌륭한 도구는 제공되는 도큐먼트만한게 없다고 생각한다. 그에 필자의 블로그도 좋지만(?) 도큐먼트를 보면서 좀더 자세한 설명을 봐야 한다는 것을 강조하며 이번 포스팅을 마무리 해본다.<br>※ putty로 AWS EC2 접속하기 : <a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/putty.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/putty.html</a></p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>다양한 클라우드 서비스들중에 너무나도 신기할정도로 간편하게 클릭 몇번만으로 서버를 띄우고, 서버 접속없이 이또한 클릭 몇번만으로 어플리케이션을 운영할수도 있는 서비스들이 많다. 하지만 필자는 시스템 아키텍쳐를 구성할때엔 버튼 하나로 설치 및 셋팅되는 것보다 직접 설정을 건드려가며 소스로 설치하는 것을 선호한다. 그럼에 AWS의 EC2라는 서비스는 필자의 취향에 너무 알맞는 서비스라며 매력을 느끼고 있는 중이다.<br>사이즈 프로젝트를 진행하면서 보다 다양한 AWS 프리티어 활용기를 포스팅 할 수 있을것 같아 벌써부터 설렌다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IT 쪽에 일을 하고 있거나 관심을 가지고 있는 사람이라면 한번쯤을 들어봤을 AWS(Amazon Web Services). 이름에서도 알수있는 것처럼 아마존에서 제공하는 각종 원격 컴퓨팅 웹서비스이다.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="aws" scheme="https://taetaetae.github.io/tags/aws/"/>
    
      <category term="ec2" scheme="https://taetaetae.github.io/tags/ec2/"/>
    
      <category term="putty" scheme="https://taetaetae.github.io/tags/putty/"/>
    
  </entry>
  
  <entry>
    <title>KafkaKRU(Kafka 한국사용자 모임) 밋업 후기</title>
    <link href="https://taetaetae.github.io/2019/03/31/kafka-meetup-2019/"/>
    <id>https://taetaetae.github.io/2019/03/31/kafka-meetup-2019/</id>
    <published>2019-03-30T16:49:30.000Z</published>
    <updated>2019-05-30T08:14:52.053Z</updated>
    
    <content type="html"><![CDATA[<p>필자는 ElasticStack을 사용하면서 처음 카프카를 접하게 되었다. 메세징 큐 라는 개념도 전혀 모르는 상태에서 설치부터 ElasticStack 연동까지 사용하며 정말 <code>강제로</code> 카프카에 대해 공부를 하게 되었다. 카프카를 자주 다루고 메커니즘에 대해 자세히 살펴보다 잠깐 해이해질 무렵 카프카 한국 사용자 모임에서 밋업을 한다고 하길래 빛의 속도로 신청, 아마도 1등으로 신청했지 않았을까 싶다.<a id="more"></a><br>사실 작년 카프카 밋업을 못간게 너무 한(?)이 되어 이번엔 회사 업무 등 여러가지로 한창 바쁘지만 “지금이 아니면 안돼” 라는 생각으로 밋업을 다녀왔고, 짧지만 후기를 작성해 보고자 한다.</p><blockquote><p>(요즘 왜 이렇게 바쁜지 모르겠지만… 신기하게도 그 바쁜 일정들이 하나도 겹치지 않는게 더 신기하다… )</p></blockquote><div class="figure center" style="width:;"><a class="fancybox" href="first.jpg" title="삼성 SDS 건물에서 진행된 카프카 밋업" data-caption="삼성 SDS 건물에서 진행된 카프카 밋업" data-fancybox="default"><img class="fig-img" src="first.jpg" alt="삼성 SDS 건물에서 진행된 카프카 밋업"><span class="image-caption">삼성 SDS 건물에서 진행된 카프카 밋업</span></a><span class="caption">삼성 SDS 건물에서 진행된 카프카 밋업</span></div><div style="clear:both;"></div><p>참고로 필자는 카프카에 대해 아주 조금 건드려본 수준이라 발표하시는 분들의 전부를 습득하기엔 다소 그릇이 작아서 일부 세션은 거의 “그런가보다~” 하고 들을 수 밖에 없었다. 후기도 아마 그런 맥락으로 작성할듯 싶다.</p><ul><li>Kafka 한국 사용자 모임 링크 : <a href="https://www.facebook.com/groups/kafka.kru" target="_blank" rel="noopener">https://www.facebook.com/groups/kafka.kru</a></li></ul><h3 id="카프카를-활용한-캐시-로그-처리-김현준-카카오"><a href="#카프카를-활용한-캐시-로그-처리-김현준-카카오" class="headerlink" title="# 카프카를 활용한 캐시 로그 처리 - 김현준(카카오)"></a># 카프카를 활용한 캐시 로그 처리 - 김현준(카카오)</h3><ul><li>이미지 등 캐시서버의 로그를 분석하기 위한 시스템을 구축하는데 ElasticStack 을 활용</li><li>Elasticsearch 로 늦게 들어와서 사례를 찾아보니 대용량 로깅 처리시 앞단에 메세징 큐를 둬야 한다고 했고 그게 카프카</li><li>카프카 모니터링은 그라파나로 활용</li><li>lag이 자꾸 생김<ul><li>파티션을 쪼개거나, 컨슈머를 늘리는 방법이 있음</li><li>auto.commit.interval.ms 와 enable.auto.commit=true 로 조정</li><li>interval을 줄이니 lag이 줄어듬</li></ul></li><li>현재는 수백대 캐시서버의 로그를 초당 15만건 이상 처리중</li></ul><p>질문을 했다. 필자도 lag이 높아지면 어쩌지 하는 불안감과 높아지면 컨슈머를 늘리면 되겠지 하는 막연함이 있었는데 commit interval을 줄이면 lag이 줄어든다고 해서 무조건 줄이면 좋은가에 답변은 카프카를 관리하는 주키퍼쪽에 무리가 간다고 설명해 주셨다. 역시 만병통치약은 없고 상황에 따라 적절하게 시스템 관리자가 조정해가며 운영해야 하는점을 느꼈다.</p><ul><li>참고 URL : <a href="https://kafka.apache.org/documentation/#adminclientconfigs" target="_blank" rel="noopener">https://kafka.apache.org/documentation/#adminclientconfigs</a></li></ul><h3 id="카프카를-활용한-엘라스틱서치-실무프로젝트-소개-이은학-메가존"><a href="#카프카를-활용한-엘라스틱서치-실무프로젝트-소개-이은학-메가존" class="headerlink" title="# 카프카를 활용한 엘라스틱서치 실무프로젝트 소개 - 이은학(메가존)"></a># 카프카를 활용한 엘라스틱서치 실무프로젝트 소개 - 이은학(메가존)</h3><ul><li>카드사의 프로젝트를 약 3개월간 개발하였고 전체 아키텍쳐 중에 일부분을 kakfa를 활용</li><li>Elasticsearch 데이터를 hadoop에 백업 형태로 옮기며 관리</li><li>filebeat &gt; kafka &gt; spark streaming 을 활용하여 데이터의 검증처리가 가능 (특정 상황에서의 관리자에게 알림 등)</li><li>logstash 의 ruby 필터를 활용하여 일정의 작업을 해주는 데이터 파이프라인 구성 가능 (개인정보 식별 등)</li><li>logstash 는 cron형태의 배치로도 가능</li></ul><p>또 질문을 하였다. (카프카 밋업과는 무관했지만…) logastsh 를 사용하면서 필터쪽에 로직이 들어가면 성능상 괜찮냐는 질문에 하루에 15억건을 처리하고있고 문제가 없었다고 한다. 필자는 아파치 엑세스 로그를 logstash로 처리하면서 간혹 뻗거나 에러가 발생했는데 아마 파일을 logstash가 직접 바라보고 처리도 하게해서 그런것 같다. (지금은 filebeat가 shipper 역활을 수행하고 있고 큰 무리 없이 운영중)</p><h3 id="카프카를-활용한-rabbitMQ-로그처리-정원빈-카카오"><a href="#카프카를-활용한-rabbitMQ-로그처리-정원빈-카카오" class="headerlink" title="# 카프카를 활용한 rabbitMQ 로그처리 - 정원빈 (카카오)"></a># 카프카를 활용한 rabbitMQ 로그처리 - 정원빈 (카카오)</h3><ul><li>레빗엠큐는 erlang으로 구현된 AMQP 메시지 브로커이고 TCP기반으로 구성</li><li>Kafka 는 게으르지만 메우 효율성이 뛰어남, 반면 RabbitMQ 는 똑똑하지만 보다 느림</li><li>Kafka 에서 Elasticsearch 로의 ingset 는 NIFI를 활용</li><li>레빗엠큐와 카프카의 차이</li></ul><table><thead><tr><th></th><th>Kafka</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>컨슈머 추가</td><td>여러 컨슈머가 하나의 메세지를 동시에 할수 있어 확장에 용이함</td><td>확장할때마다 큐를 추가 생성해야함</td></tr><tr><td>메세지 저장</td><td>로그기반으로 디스크에 저장, 리텐션 이후 삭제</td><td>큐 기반으로 메모리에 저장 컨슈머가 메세지 수신시 즉시 삭제</td></tr><tr><td>메세지 처리</td><td>발송확인 가능 / 수신확인 불가능</td><td>발송확인/수신확인 가능</td></tr></tbody></table><h3 id="카프카를-마이크로서비스-아키텍쳐에-활용하기-이동진-아파치-소프트웨어-파운데이션"><a href="#카프카를-마이크로서비스-아키텍쳐에-활용하기-이동진-아파치-소프트웨어-파운데이션" class="headerlink" title="# 카프카를 마이크로서비스 아키텍쳐에 활용하기 - 이동진 (아파치 소프트웨어 파운데이션)"></a># 카프카를 마이크로서비스 아키텍쳐에 활용하기 - 이동진 (아파치 소프트웨어 파운데이션)</h3><ul><li>카프카 스트림즈 소개 (Interactive Query)</li><li>카프카를 활용하여 마이크로서비스에서 사용하려면 데이터를 임시 공간에 넣어두고 (redis 같은?) 빼서 사용하는 형태가 아니라 Interactive Query 또는 Queryable Store 로 활용 가능</li></ul><p>사실 이부분은 필자가 제대로 못따라간 세션중에 하나이다. 용어나 메커니즘도 다소 생소했고 대략 어떤 부분을 발표해주시는지 느낌은 있었으나 제대로 이해를 못해서 …  부끄럽지만 카프카 스트림즈의 공식링크로 대체한다. </p><p><a href="https://kafka.apache.org/documentation/streams/" target="_blank" rel="noopener">https://kafka.apache.org/documentation/streams/</a></p><h3 id="카프카-프로듀서-amp-컨슈머-강한구-카카오-모빌리티"><a href="#카프카-프로듀서-amp-컨슈머-강한구-카카오-모빌리티" class="headerlink" title="# 카프카 프로듀서 &amp; 컨슈머 - 강한구 (카카오 모빌리티)"></a># 카프카 프로듀서 &amp; 컨슈머 - 강한구 (카카오 모빌리티)</h3><ul><li>프로듀서<ul><li>메세지를 생산 및 전송</li><li>Accumulator : 사용자가 send한 record를 메모리 쌓는 역활</li><li>Network thread : 전송</li><li>각 옵션 활용법 (도큐먼트 문서로 대체)<ul><li><a href="https://docs.confluent.io/current/installation/configuration/producer-configs.html#linger-ms" target="_blank" rel="noopener">linger.ms</a></li><li><a href="https://docs.confluent.io/current/installation/configuration/producer-configs.html#max-request-size" target="_blank" rel="noopener">max.request</a></li><li><a href="https://docs.confluent.io/current/installation/configuration/producer-configs.html#max-in-flight-requests-per-connection" target="_blank" rel="noopener">max.in.flight.requests.per.connection</a></li></ul></li></ul></li><li>브로커<ul><li>메세지를 저장</li><li>topic name - partition 폴더 구조</li><li>세그먼트 단위로 저장 (*.index, *.log, *.timeindex)</li></ul></li><li>컨슈머<ul><li>Fetcher : 네트워크 스레드와 비슷한 역할</li><li>Coordinator : 어떤 토픽의 어떤 파티션을 comsume할지, 브로커의 그룹 코디네이터와 통신 (hearbeat, offset comit, consumer group join)</li></ul></li></ul><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><div class="figure center" style="width:;"><a class="fancybox" href="meetup.jpg" title="발표자 분들과 질문 두번에서 받은 책선물" data-caption="발표자 분들과 질문 두번에서 받은 책선물" data-fancybox="default"><img class="fig-img" src="meetup.jpg" alt="발표자 분들과 질문 두번에서 받은 책선물"><span class="image-caption">발표자 분들과 질문 두번에서 받은 책선물</span></a><span class="caption">발표자 분들과 질문 두번에서 받은 책선물</span></div><div style="clear:both;"></div><p>확실히 수박 겉핥기 식으로  보다보니 지식에 대한 깊이도 얕아 발표자분이 전달하시고자 하는 내용을 100% 다 수용하기엔 힘들었다. 다음엔 가기전에 미리 밋업 발표에 대한 공부를 조금이라도 하고 들을 준비를 한 뒤에 참여하는것으로… 하지만 카프카를 활용해서 다양한 시스템 구성 방법론에 대해 간접으로라도 배울수 있었고, 현재 필자가 운영하고 있는 카프카의 설정값들을에 대해 잘 설정이 되어있나 (막연히 기본값들로만 설정되어 있지는 않은가) 살펴볼 계기가 만들어진것 같다. 이번에도 <code>다행히</code> “행사에 참여하면 꼭 질문을 하나이상 하자!” 라는 나와의 약속을 지킬수 있어 다행이었다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;필자는 ElasticStack을 사용하면서 처음 카프카를 접하게 되었다. 메세징 큐 라는 개념도 전혀 모르는 상태에서 설치부터 ElasticStack 연동까지 사용하며 정말 &lt;code&gt;강제로&lt;/code&gt; 카프카에 대해 공부를 하게 되었다. 카프카를 자주 다루고 메커니즘에 대해 자세히 살펴보다 잠깐 해이해질 무렵 카프카 한국 사용자 모임에서 밋업을 한다고 하길래 빛의 속도로 신청, 아마도 1등으로 신청했지 않았을까 싶다.
    
    </summary>
    
      <category term="review" scheme="https://taetaetae.github.io/categories/review/"/>
    
    
      <category term="kafka" scheme="https://taetaetae.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Write The Docs 서울 밋업 후기 (개발자 강추!)</title>
    <link href="https://taetaetae.github.io/2019/03/24/write-the-docs-seoul-2019-review/"/>
    <id>https://taetaetae.github.io/2019/03/24/write-the-docs-seoul-2019-review/</id>
    <published>2019-03-24T12:43:14.000Z</published>
    <updated>2019-05-30T08:14:51.642Z</updated>
    
    <content type="html"><![CDATA[<p>필자는 평소 개발자에게 가장 중요한 덕목 중 하나가 <code>글쓰기</code>라고 생각하고 있다. 마침 글쓰기와 기술의 접점을 고민하고 이야기하는 “Write The Docs 서울 밋업”(<a href="https://festa.io/events/191" target="_blank" rel="noopener">링크</a>) 이 있다고 하여 쉬고 싶던 주말이지만 만사를 집어치우고 참석하게 되었다. <a id="more"></a>사실 연예인 개발자분들을 직접 만날 수 있다는 기대감도 있었기 때문이다. (발표하시는 바로 앞자리에 앉았는데 정작 한마디도 못 건넸지만…)</p><div class="figure fig-75 center" style="width:;"><a class="fancybox" href="intro.jpg" title="밋업 가능길 문득 나를 사로잡았던 문구와 밋업 장소 마루 180" data-caption="밋업 가능길 문득 나를 사로잡았던 문구와 밋업 장소 마루 180" data-fancybox="default"><img class="fig-img" src="intro.jpg" alt="밋업 가능길 문득 나를 사로잡았던 문구와 밋업 장소 마루 180"><span class="image-caption">밋업 가능길 문득 나를 사로잡았던 문구와 밋업 장소 마루 180</span></a><span class="caption">밋업 가능길 문득 나를 사로잡았던 문구와 밋업 장소 마루 180</span></div><div style="clear:both;"></div><p>발표에 앞서 “이 발표 자료는 공개할 예정이니 필기하실 필요가 없다”라고 하셨다. 하지만 뒤통수를 (좋은 의미) 몇 대 아니 몇십대 맞은 느낌이라 정리를 하지 않을 수가 없었고 오늘 느끼고 배운 마음을 쭉 유지하고 싶어(내 것으로 만들고 싶어) 후기를 작성해 본다. 더불어 제목에 감히 개발자 강추!라고 적을만큼 최근 밋업 행사 중에 손꼽을 정도로 좋았기 때문이다.</p><div class="figure center" style="width:;"><a class="fancybox" href="action.gif" title="이정도로 쌔게 맞은건 아니다...<br>출처 : https://namu.moe/w/뒤통수" data-caption="이정도로 쌔게 맞은건 아니다...<br>출처 : https://namu.moe/w/뒤통수" data-fancybox="default"><img class="fig-img" src="action.gif" alt="이정도로 쌔게 맞은건 아니다...<br>출처 : https://namu.moe/w/뒤통수"><span class="image-caption">이정도로 쌔게 맞은건 아니다...<br>출처 : https://namu.moe/w/뒤통수</span></a><span class="caption">이정도로 쌔게 맞은건 아니다...<br>출처 : https://namu.moe/w/뒤통수</span></div><h3 id="변성윤-소카-글쓰는-개발자-모임-글또"><a href="#변성윤-소카-글쓰는-개발자-모임-글또" class="headerlink" title="# 변성윤(소카) - 글쓰는 개발자 모임, 글또"></a># 변성윤(소카) - 글쓰는 개발자 모임, 글또</h3><div class="figure fig-50 center" style="width:;"><a class="fancybox" href="session-1.jpg" title="변성윤 님" data-caption="변성윤 님" data-fancybox="default"><img class="fig-img" src="session-1.jpg" alt="변성윤 님"><span class="image-caption">변성윤 님</span></a><span class="caption">변성윤 님</span></div><div style="clear:both;"></div><p>필자도 가입만 하고 활동은 안 하는 중인 “글 쓰는 개발자 모임 - 글또” 모임에 대해 소개해주셨다. 글을 꾸준히 작성하기 위해 만들었고, 일정에 예치금을 내고 정해진 규칙에 의해 블로그에 글을 올리면 다시 돈을 환급받는 반강제적인 모임이라고 한다. 그뿐만 아니라 다른 분들이 글을 써서 공유를 하면 성윤님이 직접 피드백을 주며 개발 시 리팩토링을 하듯 더 나은 품질의 글을 쓸 수 있도록 도움을 주고 있다고 하신다. 이러한 피드백 문화가 1:N이 아닌 N:N이 되면 또 다른 동기부여가 될 것 같은데 … 하는 아쉬움을 느꼈다.<br>사실 “글을 꾸준히 작성”하는 부분이 필자도 매우 공감이 된다. 바쁘고, 귀찮고, 글을 쓰려면 욕심이 생기고 그러다 미루고… 그 동기부여가 “돈” 일수밖에 없는 현실이 아쉽긴 한데 오히려 그 “돈”만큼 동기부여가 잘 되는 것도 없을것 같다. (헬스장 1년 권 계약하고 돈이 아까워서라도 나가는 느낌으로…)<br>올해 새로운 기수를 모집한다고 하니 그때는 꼭 지원해서 글을 꾸준히 쓰는 습관을 길러보고 싶다.</p><h3 id="김대권-당근마켓-기술-블로그-생존-전략-구글-시대의-글쓰기"><a href="#김대권-당근마켓-기술-블로그-생존-전략-구글-시대의-글쓰기" class="headerlink" title="# 김대권(당근마켓) - 기술 블로그 생존 전략 : 구글 시대의 글쓰기"></a># 김대권(당근마켓) - 기술 블로그 생존 전략 : 구글 시대의 글쓰기</h3><div class="figure fig-50 center" style="width:;"><a class="fancybox" href="session-2.jpg" title="김대권 님" data-caption="김대권 님" data-fancybox="default"><img class="fig-img" src="session-2.jpg" alt="김대권 님"><span class="image-caption">김대권 님</span></a><span class="caption">김대권 님</span></div><div style="clear:both;"></div><p>얼마 전에 한번 쓱 보고 정독할 수밖에 없던 포스팅인 <a href="[https://www.44bits.io/ko/post/8-suggestions-for-tech-programming-blog](https://www.44bits.io/ko/post/8-suggestions-for-tech-programming-blog">좋은 기술 블로그를 만들어 나가기 위한 8가지 제언</a> 을 작성하시고, 해당 기술블로그 를 운영하시고 계시는 김대권 님께서 글을 왜 쓰는지, 그리고 어떻게 하면 사람들에게 잘 읽힐 수 있을지에 대해 구글 검색엔진 관점에서 정리해주셨다.<br>우리는 보통 읽히기 위해 공개된 글을 쓰기 때문에 좋은 글을 쓰는 게 선행되어야 하지만 반대로 어떻게 하면 잘 읽힐 수 있을지에 대해 고민이 필요한 부분 같다.  요즘은 소셜미디어나 검색을 통해 글이 공유되고 검색되는데 장기적으로 봤을 때는 검색엔진에 노출이 돼야 한다고 하신다.  또한 검색엔진은 백과사전처럼 정답을 알려주는것이 아닌 “거대한 추천 시스템”의 관점으로 접근해야 하며, 글의 양이 너무 크거나 적으면 안 되고 적당한(?) 수준을 지켜야 이를 검색엔진이 알아서 판단한다고 한다.<br>또한 <a href="[http://blog.weirdx.io/post/60414](http://blog.weirdx.io/post/60414">What nobody tells you about documentation (번역본)</a> 이라는 것도 소개해주시며 결국엔 글 내용의 자체가 좋아야 한다고 재차 강조하셨다. (매우 공감, SEO 아무리 잘 설정해봤자 내용이 안 좋으면 말짱 꽝)</p><h3 id="홍연의-LINE-To-지식-공유를-시작하려는-개발자-From-당신의-든든한-서포터-Developer-Relations팀"><a href="#홍연의-LINE-To-지식-공유를-시작하려는-개발자-From-당신의-든든한-서포터-Developer-Relations팀" class="headerlink" title="# 홍연의(LINE) - To. 지식 공유를 시작하려는 개발자, From. 당신의 든든한 서포터 Developer Relations팀"></a># 홍연의(LINE) - To. 지식 공유를 시작하려는 개발자, From. 당신의 든든한 서포터 Developer Relations팀</h3><div class="figure fig-50 center" style="width:;"><a class="fancybox" href="session-3.jpg" title="홍연의 님" data-caption="홍연의 님" data-fancybox="default"><img class="fig-img" src="session-3.jpg" alt="홍연의 님"><span class="image-caption">홍연의 님</span></a><span class="caption">홍연의 님</span></div><div style="clear:both;"></div><p>다소 생소한 Developer Relations 팀에 대해 소개를 해주시며 꼭 기술 관점이 아닌 다양한 분야에서 해당 팀이 어떤 지원을 해주고 있는지에 대해 알려주셨다. 기술 블로그 운영, 소셜 페이지 관리, 개발 컨퍼런스, 세미나, 커뮤니티 후원 등등 개발자와 개발 문화를 알리는 모든 일을 하고 있다고 한다.<br>옆 회사(?)이지만 저런 개발자의 문화를 만드는 팀이 있다는 게 부럽기도 하였고, 가끔 세미나가 있는 걸로 아는데 공개적으로 하면 어떨까 하는 아쉬움이 있지만… 점차 private에서 public으로 확대될 꺼라 기대를 해본다.<br>발표를 내가 직접 들으며 이러한 문화를 만들 수도 있겠구나 하는 생각도 해봤다. 작게는 팀 단위부터 시작해서 서버/앱 등 개발자들을 모아두고 관심 있는 사람들끼리 공유하는 자리를 정기적으로 만드는… 중요한 건 “정기적”으로… 일단 나부터라도 시작을 해보자.</p><h3 id="조은별-시큐아이-사용자를-외면하지-않는-릴리스-노트"><a href="#조은별-시큐아이-사용자를-외면하지-않는-릴리스-노트" class="headerlink" title="# 조은별(시큐아이) - 사용자를 외면하지 않는 릴리스 노트"></a># 조은별(시큐아이) - 사용자를 외면하지 않는 릴리스 노트</h3><div class="figure fig-50 center" style="width:;"><a class="fancybox" href="session-4.jpg" title="조은별 님" data-caption="조은별 님" data-fancybox="default"><img class="fig-img" src="session-4.jpg" alt="조은별 님"><span class="image-caption">조은별 님</span></a><span class="caption">조은별 님</span></div><div style="clear:both;"></div><p>테크니컬 라이터가 무슨 일을 하고 어떤 부분에서 고민을 하는지에 대해 소개를 해주셨다. 하나의 예로 앱스토어에서 릴리즈 노트를 보면 A라는 앱은 단순 “기능 개선”, “버그 수정” 인데 B라는 앱은 개발과 무관한 일반 사용자가 보더라도 상세히 적힌 걸 볼 수 있다. 이것만 봐도 그 앱에 대한 신뢰가 높아질 수 있는 부분이라고 생각할 수 있다는 점에서 나는 commit message, PR 등 너무 의미 없는 메세지들로 일관한 건 아닐까 하는 반성을 할 수 있었다. (뜬금스럽지만…)<br>프로야구의 더블플레이 룰이 올해부터 개정되는 것을 예로 들어주며 누가 읽고, 어떻게 읽으며 무엇을 읽는가에 대해 관점을 가지고 해당 사용자 시선에서 이해할 수 있도록 하는 게 가장 좋다고 설명해 주셨다. (이 분야 또한 리펙토링의 반복… )</p><h3 id="이동욱-우아한형제들-개발자는-왜-블로그를-해야하나요"><a href="#이동욱-우아한형제들-개발자는-왜-블로그를-해야하나요" class="headerlink" title="# 이동욱(우아한형제들) - 개발자는 왜 블로그를 해야하나요?"></a># 이동욱(우아한형제들) - 개발자는 왜 블로그를 해야하나요?</h3><div class="figure fig-50 center" style="width:;"><a class="fancybox" href="session-5.jpg" title="이동욱 님" data-caption="이동욱 님" data-fancybox="default"><img class="fig-img" src="session-5.jpg" alt="이동욱 님"><span class="image-caption">이동욱 님</span></a><span class="caption">이동욱 님</span></div><div style="clear:both;"></div><p>기술블로그를 어떻게 써야 하고 어떤 식으로 관리를 해야 하는지가 아닌 조금 더 강한 느낌의 “개발자는 기술블로그를 해야 한다” 의 이유를 설명해주셨다. 동욱님은 블로그를 통해 이직도 하고 기고&amp;집필 요청도 받으시고 인터뷰 요청도 받고…심지어 광고수입으로 매월 70~100달러가 들어온다고 한다. (필자의 몇 배인지 가늠도 안 간다…)<br>다양한 분야에서 얻은 이득이 많기 때문에 기술블로그를 해야 한다고 말하고 있고, 연봉/회사/직위/재산을 빼고 나를 표현할 수 있는 것이라고는 기술블로그밖에 없다고 한다. (극 공감) 필자도 서두에 말했던 것처럼 개발자는 글을 써야 한다고 하는 사람 중에 한 명이다 보니 동욱님의 발표 하나하나가 너무 몸 쪽 깊숙이 들어와서 글을 좀더 자주 + 잘 써야겠다고 다짐을 하게 되었다. 그리고 마지막에 말씀하신 중국 속담 하나가 아직까지 필자의 뒤통수를 계속 때리고 있다.<br><code>아무리 흐린 잉크라도 좋은 기억력보다 낫다</code></p><h3 id="변정훈-BlockchainOS-개발-관련-기술-블로그-운영하기"><a href="#변정훈-BlockchainOS-개발-관련-기술-블로그-운영하기" class="headerlink" title="# 변정훈(BlockchainOS) - 개발 관련 기술 블로그 운영하기"></a># 변정훈(BlockchainOS) - 개발 관련 기술 블로그 운영하기</h3><div class="figure fig-50 center" style="width:;"><a class="fancybox" href="session-6.jpg" title="변정훈 님" data-caption="변정훈 님" data-fancybox="default"><img class="fig-img" src="session-6.jpg" alt="변정훈 님"><span class="image-caption">변정훈 님</span></a><span class="caption">변정훈 님</span></div><div style="clear:both;"></div><p>국내에 몇 안되는, 오랫동안 기술블로그를 운영해오시는 개발자 중에 한분인 아웃사이더 변정훈님께서 어떤 식으로 기술블로그를 운영해야 하는가에 대해 발표해주셨다. 필자와는 다르게 (워낙 많이 쓰셔서 일것 같지만) 퇴고는 잘 안 하시고 항상 글을 작성할 것을 생각하며 개인 노트에 메모하고 글을 쓴다고 하신다. (필자도 얼마 전부터 <a href="https://notion.so/" target="_blank" rel="noopener">노션</a>이라는 것을 활용해서 관리하고 있는데… 잘 따라 하고 있는 것 같아 나름 뿌듯함을 느꼈다.)<br>이 세션에서도 뒤통수를 때리는 멘트가 많았는데… 괜히 유명하신 분이 아니구나 싶을 정도였다. (심지어 멘트마저…)</p><ul><li>공부할 시간도 적은데 블로그는 또 언제 쓰는가 &gt; 공부할게 많으니까 블로그를 쓴다. (캬~ 1)</li><li>글을 지속적으로 쓰려면 어떻게 해야 하는가 &gt; 꾸준히 쓰다 보니 이제는 근육처럼 되었다. (캬~ 2)</li><li>문제가 생겨 검색해보고 해결한다고 해서 내 것이 되는 것은 아님 &gt; 내가 직접 재현을 해보고 테스트를 해봐야 내것이 됨. (캬~ 3)</li></ul><p>나름의 철학으로 글을 작성할 때 일관된 흐름을 유지하려고 노력 중이시고 그게 구글에서 검색하면 아웃사이더님의 글이 처음으로 나오는 이유가 아닐까 싶다. (그만큼 사이트의 신뢰도가 높아져서?)</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>무슨 말이 필요하겠는가. 필자의 메모장에도 블로깅을 하려고 적어놓은 것들만 있지 실제로 실행에 옮기지 못하고 있는데 꾸준히, 그리고 체계적으로, 읽는 사람의 위치에서 글을 잘 써보겠다고 다짐할 수 있었던 좋은 행사였다. 한 가지, 밋업이 끝나고 네트워킹 행사나 뒷풀이가 있었으면 좋았을 텐데 하는 아쉬움이 있었지만 다른 행사에서 자주 찾아뵈고 하다 보면 인연이 생길 꺼라 감히 소망해본다.</p><p>#wtdseoul #WritetheDocs</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;필자는 평소 개발자에게 가장 중요한 덕목 중 하나가 &lt;code&gt;글쓰기&lt;/code&gt;라고 생각하고 있다. 마침 글쓰기와 기술의 접점을 고민하고 이야기하는 “Write The Docs 서울 밋업”(&lt;a href=&quot;https://festa.io/events/191&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;링크&lt;/a&gt;) 이 있다고 하여 쉬고 싶던 주말이지만 만사를 집어치우고 참석하게 되었다.
    
    </summary>
    
      <category term="review" scheme="https://taetaetae.github.io/categories/review/"/>
    
    
      <category term="blog" scheme="https://taetaetae.github.io/tags/blog/"/>
    
      <category term="write" scheme="https://taetaetae.github.io/tags/write/"/>
    
      <category term="write the docs" scheme="https://taetaetae.github.io/tags/write-the-docs/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins 업그레이드 및 Master-Slave 구성</title>
    <link href="https://taetaetae.github.io/2019/03/17/jenkins-upgrade-master-slave/"/>
    <id>https://taetaetae.github.io/2019/03/17/jenkins-upgrade-master-slave/</id>
    <published>2019-03-17T09:23:03.000Z</published>
    <updated>2019-05-30T08:14:51.937Z</updated>
    
    <content type="html"><![CDATA[<p>어떠한 작업(Job)이 있다고 가정해보자. 이를 “정해진 시간에 주기적” 이나 “필요할때” 작업을 수행하고 싶다면 어떤 툴(Tool)이 떠오르는가? <a id="more"></a>그리고 이 작업(Job)들의 실행이력 등 전체적으로 관리하고 필요에 따라 다양한 플러그인을 활용하여 입맛에 맞는 작업(Job)으로 구성하고 싶을때 가장 첫번째로 떠오르는 툴은 바로 “Jenkins” 다. (극히 필자 개인적인 생각일수도 있지만… ) 물론 리눅스 기반의 crontab 이나 다른 스케쥴러를 활용할수도 있다. 다만 필자 개인적인 느낌으로 나만의 Jarvis(?)처럼 내가 원하는데로 설정만 해두면 정해진 시간에 수행하고 그 결과를 로그로 남겨놓고 문제가 발생했을때 알림도 받을수 있으니 너무 좋은 툴이라 생각이 든다.</p><div class="figure center" style="width:;"><a class="fancybox" href="ColossalSociableBuffalo-size_restricted.gif" title="실제로 Jarvis가 있다면 얼마나 편할까<br>출처 : https://gfycat.com/ko/colossalsociablebuffalo" data-caption="실제로 Jarvis가 있다면 얼마나 편할까<br>출처 : https://gfycat.com/ko/colossalsociablebuffalo" data-fancybox="default"><img class="fig-img" src="ColossalSociableBuffalo-size_restricted.gif" alt="실제로 Jarvis가 있다면 얼마나 편할까<br>출처 : https://gfycat.com/ko/colossalsociablebuffalo"><span class="image-caption">실제로 Jarvis가 있다면 얼마나 편할까<br>출처 : https://gfycat.com/ko/colossalsociablebuffalo</span></a><span class="caption">실제로 Jarvis가 있다면 얼마나 편할까<br>출처 : https://gfycat.com/ko/colossalsociablebuffalo</span></div><p>지난 <a href="https://taetaetae.github.io/2018/12/02/jenkins-install/">포스팅</a>에서는 Jenkins 를 설치하는 방법에 대해 알아보았다. (정확히 말하면 치트키 수준의… ) 이번 포스팅에서는 Jenkins에 노드를 추가하여 master-slave 분산환경으로 구성하는 방법과 Jenkins 버전을 업그레이드 하는 방법에 대해 정리해보고자 한다.</p><blockquote><p>마침 필자의 팀에서 젠킨스를 분산환경으로 운영하고 있었는데 버전은 1.x … 간헐적으로 Jenkins 버전 이슈로 에러가 발생해서 업그레이드를 해야하는 상황이 생긴것이다. 시키지도 않은 일을 하면서 팀에 도움도 될겸, 포스팅도 할겸, 1석 2조 효과. 서버 환경은 CentOS 7.4 64Bit 에서 테스트 하였다.</p></blockquote><h3 id="Jenkins-버전-업그레이드-하기"><a href="#Jenkins-버전-업그레이드-하기" class="headerlink" title="# Jenkins 버전 업그레이드 하기"></a># Jenkins 버전 업그레이드 하기</h3><p>Jenkins를 업그레이드 하게되면 기존에 있었던 Jenkins의 환경설정은 어떻게 마이그레이션 할까? Job 실행기록들은 그냥 날려버려야 하나? 걱정을 하며 구글링을 해본다. 그러면 “안해본것에 대한 두려움” 을 갖는 필자의 마음이 무색할 정도로 너무 간단하게도 그냥 기존에 있던 war 파일을 최신버전으로 교체하고 재시작 하라고 나온다.  읭? 뭐이리 간단해? 대부분의 문제들은 지레 겁부터 먹고 실행에 옮기지 <del>못해서</del> 않아서 해결을 하지 못하는게 절반 이상같다.  자, 바로 실행에 옮겨보자.<br>우선 버전 업그레이드를 테스트 하기 위해 일부러 <a href="http://mirrors.jenkins.io/war-stable/" target="_blank" rel="noopener">낮은버전</a>으로 설치를 해둔다. (필자는 1.609.1로 설치해봤다.) 그리고 버전 업그레이드 후 설정이 그대로 옮겨지는지를 확인하기위해 Security 설정을 해서 Jenkins 접근시 로그인 여부를 물어보록 설정해둔다.</p><div class="figure center" style="width:;"><a class="fancybox" href="old_jenkins.jpg" title="우측 하단에 빨간영역으로 낮은버전이 설치된것을 확인할수 있다." data-caption="우측 하단에 빨간영역으로 낮은버전이 설치된것을 확인할수 있다." data-fancybox="default"><img class="fig-img" src="old_jenkins.jpg" alt="우측 하단에 빨간영역으로 낮은버전이 설치된것을 확인할수 있다."><span class="image-caption">우측 하단에 빨간영역으로 낮은버전이 설치된것을 확인할수 있다.</span></a><span class="caption">우측 하단에 빨간영역으로 낮은버전이 설치된것을 확인할수 있다.</span></div><p>설정이 완료되었으면 최신버전의 war를 다운받아 교체하고 재시작을 해준다. 그러면 너무나도 간단하게 버전이 업그레이드가 된것을 확인할수 있다. 그리고 처음에 설정한 Security 설정까지 그대로 유지되는것 또한 확인이 가능하다. 물론 구 버전에서 설치되었던 플러그인들이 버전업이 되며 그에 따라 지원하지 않는 문제들이 생길 수 있는데 이 부분은 플러그인을 업그레이드를 해준다거나 각 상황에 맞는 대응을 해줘야 한다. 이렇게 해서 생각보다(?) 너무 간단하게 버전업이 완료되었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="upgrade_complete.jpg" title="업그레이드 후 플러그인 업그레이드도 동일하게 맞춰주는게 중요하다." data-caption="업그레이드 후 플러그인 업그레이드도 동일하게 맞춰주는게 중요하다." data-fancybox="default"><img class="fig-img" src="upgrade_complete.jpg" alt="업그레이드 후 플러그인 업그레이드도 동일하게 맞춰주는게 중요하다."><span class="image-caption">업그레이드 후 플러그인 업그레이드도 동일하게 맞춰주는게 중요하다.</span></a><span class="caption">업그레이드 후 플러그인 업그레이드도 동일하게 맞춰주는게 중요하다.</span></div><h3 id="Jenkins-분산환경-구성하기-노드-추가하기"><a href="#Jenkins-분산환경-구성하기-노드-추가하기" class="headerlink" title="# Jenkins 분산환경 구성하기 (노드 추가하기)"></a># Jenkins 분산환경 구성하기 (노드 추가하기)</h3><p>이번엔 Jenkins를 분산환경으로 구성해보고자 한다. 이렇게 노드를 추가하며 분산환경을 구성하는 이유는 마스터-슬레이브(Master-Slave) 패턴의 장점을 얻고자 함이다. 마스터는 작업을 쪼개고 슬레이브로 구성된 노드에게 분배를 하게되면 슬레이브 서버는 마스터의 요청을 처리하고 리턴하게 된다. 마치 스타크래프트에서 일꾼을 늘려서 미네랄과 가스를 더 빨리 얻는것처럼 말이다.</p><p>여기서 필자가 가장 많이 삽질한 부분. 슬레이브 서버를 추가하는데 슬레이브 서버가 되는 서버에 동일하게 젠킨스를 설치하고 그들을 모두 연결하려 했던것… 마치 클러스터링 하는것처럼…  당연히 Jenkins 들의 묶음형태(?) 가 되야 할것같은 생각으로 시도하였지만 엄청난 삽질의 연속이 되어버렸다. 알고보니 마스터 Jenkins에서 슬레이브 서버에 작업을 전달할수 있도록 연동만 시켜주면 자동으로 Agent를 마스터 Jenkins가 슬레이브 서버에 설치/실행을 하고 작업을 분할하는것을 확인할 수 있었다. 자, 그럼 시작해보자.</p><ol><li><p>마스터 서버에서 공개키와 개인키 생성<br>먼저 마스터 서버와 슬레이브 서버를 SSH로 통신할수 있도록 SSH 키 설정을 해준다. 통상 홈 디렉토리 하위 .ssh 폴더에서 생성한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ssh 키 생성</span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/~/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /~/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /~/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ user@hostname</span><br><span class="line">The key's randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|oo. .            |</span><br><span class="line">|o... o  +        |</span><br><span class="line">|. .o  o+.o       |</span><br><span class="line">|.++++. +o+o..    |</span><br><span class="line">|o.+*=.o.SEoo=    |</span><br><span class="line">| .  o+.*...+ +   |</span><br><span class="line">|   .. + +.  +    |</span><br><span class="line">|     + .     .   |</span><br><span class="line">|      ...        |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br><span class="line">공개키 확인</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat id_rsa.pub</span></span><br><span class="line">ssh-rsa AAAAB3Nza~~~~~~~~eQKcx8B6uAflRm1J8In1 user@hostname</span><br></pre></td></tr></table></figure></li><li><p>슬레이브 서버에서 마스터 서버에서 만든 공개키를 등록<br>슬레이브 서버에서는 마스터 서버에서 SSH 접속을 허용해야 하기때문에 마스터 서버에서 생성한 공개키를 등록해준다. 슬레이브 서버의 홈 디렉토리 하위 .ssh 폴더아래 파일을 만들고 위 공개키를 넣어주자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi authorized_keys</span></span><br><span class="line">ssh-rsa AAAAB3Nza~~~~~~~~eQKcx8B6uAflRm1J8In1 user@hostname</span><br></pre></td></tr></table></figure></li><li><p>Jenkins 에서 Credentials 을 만들때 Private Key 설정을 “From the Jenkins master ~/.ssh”으로 설정한다. 나중에 이 정보로 인증을 처리한다.</p><div class="figure center" style="width:;"><a class="fancybox" href="jenkins_upgrade_3.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="jenkins_upgrade_3.jpg" alt=""></a></div></li></ol><ol start="4"><li>노드를 추가하고 조금 있으면 마스터 노드가 슬레이브 서버에 에이전트를 설치/실행하고 연동이 된것을 확인할수 있다.<div class="figure center" style="width:;"><a class="fancybox" href="jenkins_upgrade_4.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="jenkins_upgrade_4.jpg" alt=""></a></div>실제로 슬레이브 서버에서 프로세스를 확인하면 아래처럼 에이전트( slave.jar )가 설치/실행되고 있는것을 확인할수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep java</span><br><span class="line">user   105431 105288  0 01:03 ?        00:00:00 bash -c cd &quot;/home&quot; &amp;&amp; java  -jar slave.jar</span><br><span class="line">user   105463 105431  3 01:03 ?        00:00:08 java -jar slave.jar</span><br></pre></td></tr></table></figure></li></ol><p>위와 같은 방법으로 슬레이브 서버를 총 두개를 구성하고 job을 여러개 실행하게 하면 자동으로(랜덤으로) 분배되어 실행하는것을 확인할 수 있다.<br><div class="figure center" style="width:;"><a class="fancybox" href="jenkins_node_job_execute.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="jenkins_node_job_execute.jpg" alt=""></a></div></p><p>특정 job은 특정 슬레이브 서버에서 실행하고 싶은 경우도 있다. 예로들어 특정 슬레이브 서버가 성능이 더 좋다거나 네트워크 ACL이 특정 슬레이브 서버만 오픈되었다거나… 그럴 경우에는 아래처럼 job 실행설정에서 슬레이브를 강제로 지정할수도 있다. (짱…)<br><div class="figure center" style="width:;"><a class="fancybox" href="execute_target_node.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="execute_target_node.jpg" alt=""></a></div></p><h3 id="Jenkins-분산환경에서-버전-업그레이드-하기"><a href="#Jenkins-분산환경에서-버전-업그레이드-하기" class="headerlink" title="# Jenkins 분산환경에서 버전 업그레이드 하기"></a># Jenkins 분산환경에서 버전 업그레이드 하기</h3><p>이제 위에서 했던것들의 종합 세트인 “Master-Slave로 되어있는 구성에서의 Jenkins 업그레이드” 를 해보자.  우선 위에서 했던것처럼 구버전으로 Master-Slave 를 구성한다.<br>이제부터가 중요한데 필자는 당연히 위에서 했던 업그레이드 방법처럼 (이렇게 노드가 연결되어있는 상황에서) 기존의 war을 교체하면 되겠거니 했다. 하지만 업그레이드는 되었지만 노드가 연결이 안되면서 너무나도 다양한(?)에러를 만나야만 했다. 에러 내용을 찾아보니 필자처럼 버전 업그레이드를 하며 예외상황이 발생해 에러가 나는 경우가 많았고 삽질을 거듭해본 결과 다음과 같은 방법으로 하면 업그레이드도 되고 노드도 연결이 가능한것을 확인할 수 있었다. (다른 더 좋은 방법이 있다면 알고싶다… )</p><ol><li>우선 기존에 추가해둔 노드들을 제거한다.</li><li>그 다음 위에서 했던것처럼 war를 교체하며 업그레이드를 진행한다.</li><li>Credentials 항목에 보면 개인키가 있는것을 볼수 있다. (기존에는 “From the Jenkins master ~/.ssh” 항목이 있었는데 없어졌다. )</li><li>위에서 했던것처럼 노드를 추가해준다. 그럼 다음과 같은 에러를 만날수 있는데 에러 내용을 보면 known_hosts 파일이 없다고 나온다. 뭔가 해결할수 있을것만 같은 느낌이 든다. master 서버에서 <code>ssh 슬레이브서버주소</code> 명령어를 실행해서 known_hosts 파일을 생성하도록 해준다.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/home/.ssh</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">id_rsa  id_rsa.pub</span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh slave-host</span></span><br><span class="line">The authenticity of host 'slave-host (0.0.0.0)' can't be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:0zb~~~~~B1A.</span><br><span class="line">ECDSA key fingerprint is MD5:~~~~:87.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added 'slave-host,0.0.0.0' (ECDSA) to the list of known hosts.</span><br><span class="line">Last login: Thu Mar 14 13:30:04 2019 from 10.113.219.197</span><br><span class="line">[user@slave-host ~]$ exit</span><br><span class="line">logout</span><br><span class="line">Connection to slave-host closed.</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">id_rsa  id_rsa.pub  known_hosts</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat known_hosts</span></span><br><span class="line">slave-host,0.0.0.0 ~~~ AAAA~~~~~~~8=</span><br></pre></td></tr></table></figure></li></ol><div class="figure center" style="width:;"><a class="fancybox" href="final_upgrade.jpg" title="업그레이드 후 노드 구성한 화면" data-caption="업그레이드 후 노드 구성한 화면" data-fancybox="default"><img class="fig-img" src="final_upgrade.jpg" alt="업그레이드 후 노드 구성한 화면"><span class="image-caption">업그레이드 후 노드 구성한 화면</span></a><span class="caption">업그레이드 후 노드 구성한 화면</span></div><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>“Master-Slave로 되어있는 구성에서의 Jenkins 업그레이드”를 하며 정말 많은 시간을 할애할 수 밖에 없었고 (관련 지식도 없고 경험도 없었으니… ) 너무 안되어 포기할까도 싶었다. 하지만 경험하지 않은 모든 일들은 다 그만큼의 고통이 필요하고, 그 고통이 있어야지만 비로소 내것이 된다는 생각을 하고 있다. 이것도 나만의 무기가 되어 나중에 jenkins 를 업그레이드 한다거나 노드구성을 할때 보다 쉽고 빠르게 할수있지 않을까 기대를 해본다. 더불어 어려운 이야기이지만 삽질도 올바른 삽질을 할수 있도록 소망해본다…<br><div class="figure center" style="width:;"><a class="fancybox" href="spadework.gif" title="이런 삽질은 그만... <br>출처 : https://gfycat.com/ko/illiterateonlyicelandgull" data-caption="이런 삽질은 그만... <br>출처 : https://gfycat.com/ko/illiterateonlyicelandgull" data-fancybox="default"><img class="fig-img" src="spadework.gif" alt="이런 삽질은 그만... <br>출처 : https://gfycat.com/ko/illiterateonlyicelandgull"><span class="image-caption">이런 삽질은 그만... <br>출처 : https://gfycat.com/ko/illiterateonlyicelandgull</span></a><span class="caption">이런 삽질은 그만... <br>출처 : https://gfycat.com/ko/illiterateonlyicelandgull</span></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;어떠한 작업(Job)이 있다고 가정해보자. 이를 “정해진 시간에 주기적” 이나 “필요할때” 작업을 수행하고 싶다면 어떤 툴(Tool)이 떠오르는가?
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="jenkins" scheme="https://taetaetae.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>기술블로그 구독서비스 개발 후기 - 3부</title>
    <link href="https://taetaetae.github.io/2019/02/17/daily-dev-blog-3/"/>
    <id>https://taetaetae.github.io/2019/02/17/daily-dev-blog-3/</id>
    <published>2019-02-16T16:17:27.000Z</published>
    <updated>2019-05-30T08:14:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>작년 7월 12일부터 시작한 필자의 첫 토이프로젝트인 <a href="http://daily-devblog.com" target="_blank" rel="noopener">기술블로그 구독서비스</a>. 오픈할 때까지만 해도 “AWS 프리티어를 사용하고 있는 1년 안에 구독자가 설마 1,000명이 넘겠어?” 라고 생각을 했었는데 <a id="more"></a> 오픈을 하고 220일째 되는 바로 어제 어느덧 벌써 구독자가 1,000명을 달성하게 되었다. 그 기념으로 그동안 미뤄두었던 <code>기술블로그 구독서비스 개발 후기</code> 시리즈의 3부를 쓰고자 한다.<br><div class="figure center" style="width:;"><a class="fancybox" href="nice_minion.gif" title="오예~ 1,000명이다! 땡큐! <br>출처 : https://gfycat.com/ko/leafytorngroundbeetle" data-caption="오예~ 1,000명이다! 땡큐! <br>출처 : https://gfycat.com/ko/leafytorngroundbeetle" data-fancybox="default"><img class="fig-img" src="nice_minion.gif" alt="오예~ 1,000명이다! 땡큐! <br>출처 : https://gfycat.com/ko/leafytorngroundbeetle"><span class="image-caption">오예~ 1,000명이다! 땡큐! <br>출처 : https://gfycat.com/ko/leafytorngroundbeetle</span></a><span class="caption">오예~ 1,000명이다! 땡큐! <br>출처 : https://gfycat.com/ko/leafytorngroundbeetle</span></div></p><p>혹시 전에 내용을 보고자 하면 아래 링크에서 확인할 수 있다.</p><ul><li>1부 : <a href="https://taetaetae.github.io/2018/08/05/daily-dev-blog-1/">왜 만들게 되었는가 그리고 어떤 구조로 만들었는가</a></li><li>2부 : <a href="https://taetaetae.github.io/2018/08/09/daily-dev-blog-2/">문제발생 및 Trouble Shooting</a></li><li>3부 : <a href="https://taetaetae.github.io/2019/02/17/daily-dev-blog-3/">앞으로의 계획과 방향성</a></li></ul><h3 id="그간-어떤-식으로-서비스를-운영했는가"><a href="#그간-어떤-식으로-서비스를-운영했는가" class="headerlink" title="# 그간 어떤 식으로 서비스를 운영했는가?"></a># 그간 어떤 식으로 서비스를 운영했는가?</h3><p>(한마디로 정리할 순 없는 지난 220일이었지만…) 딱 한마디로 정리하자면 <code>엄청나게 많은 것을 배우고 경험할 수 있었으나 그만큼 힘들었던 시간들</code>이라고 말할 수 있을 것 같다.     2부에서 이야기한 <code>문제 발생에 따른 Trouble Shooting</code>들도 있었지만 운영을 해오다 보니 사전에 생각하지도 못한 부분에서 문제가 생기는 정말 다양한 경험을 할 수 있었기 때문이다.</p><ul><li><p>블로그 포스팅을 수집하는 과정에서의 문제<br>일부 블로그 RSS url에 접근을 할 때 요청에 대한 응답이 무한대로 멈춰버리는 현상이 간헐적으로 있었다. 이는 별도의 타임아웃을 설정하지 않았기 때문이다. 그래서 어느 정도의 타임아웃을 두고 시간 내에 응답이 없을 경우 다음 포스팅으로 넘어가도록 하였다. (타임아웃은 아주 기본적인 부분인데…)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(rss_url, timeout=10.0)</span><br></pre></td></tr></table></figure></li><li><p>메일 발송하는 과정에서의 문제<br>가끔 메일이 오지 않는다고 친절하게 필자 개인 메일로 연락이 오는 경우가 있었다. 그때마다 서버의 상태를 보면 서버에 직접 접속조차 안 될 정도로 메모리 사용량이 너무 많아서 그때마다 AWS 웹 콘솔에서 강제로 서버를 재부팅을 하곤 했었다. 예전에도 이야기한 것처럼 AWS 프리티어를 사용하고 있다 보니 서버의 메모리가 1기가밖에 되지 않아서 … 제한된 시스템에서 서비스 운영을 할 수밖에 없는 상황이었다.<br>그래서 수집/발송 상태를 로깅으로 쉽게 볼 수 있고 스케줄링을 하기 위해 띄워둔 Jenkins(tomcat)를 중단하고 crontab으로 스케줄링을 하도록 하였고, 로깅은 <a href="https://stackoverflow.com/questions/4811738/how-to-log-cron-jobs" target="_blank" rel="noopener">별도의 파일로 로깅</a>하도록 변경하였다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/python3.6 /home/~~~/email_send.py &gt; /home/~~~/logs/job/email_send_`date +\%Y\%m\%d\%H\%M\%S`.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>  또한 기존에는 빠르게 발송하기 위해 냅다 스레드로 돌렸는데 구독자 수가 많아지다 보니 <code>RuntimeError: can&#39;t start new thread</code> 라고 스레드를 만들 수 없다는 에러가 발생하기도 했다. 그래서 Pool을 사용하는 방식의 <a href="https://docs.python.org/3.4/library/multiprocessing.html" target="_blank" rel="noopener">multiprocessing</a> 을 도입하여 스레드로 발송할 때보다는 엄청나게 빠른 속도는 아닐지라도 효율적인 메모리 사용으로 2분 안에 1,000명에게 안정된 메일을 보낼 수 있게 되었다. (여담이지만 메일이 안 온다고 알려주셨던 분들께 이 자리를 빌려 감사의 인사를 전하고 싶다.)</p><pre><code class="python"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool...pool = Pool(<span class="number">20</span>)pool.map(sendMail, email_list)</code></pre><blockquote><p><a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku</a> 나 <a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a> 같이 서버를 직접 들어가지 않고 앱 형태로 배포하는 식으로 할 수도 있다. 하지만 초기에 이 토이프로젝트를 시작할 때 실 서비스와 최대한 동일한 시스템으로 운영해보고 싶었기 때문에 라즈베리파이에 설치하는 것까지 알아보다 결국 AWS를 사용하기로 하게 되었다.<br>그렇다면 AWS 프리티어를 사용하지 않고 별도의 서버를 구매하면 안 될까? 하는 생각도 해봤지만 최소한의 인프라로 최대한의 성능을 내보고 싶은 욕심(?) 때문에 1년간은 프리티어로 운영하고 그다음엔 (혹은 소프트웨어적으로 한계까지 도달한다면) 서버를 구매해서 운영하게 될 것 같다. (적어도 이후에도 이 서비스를 유지한다는 가정하에…)</p></blockquote></li></ul><div class="figure center" style="width:;"><img class="fig-img" src="daily-ddb-check.jpg" alt="농부의 마음으로... <br>출처 : http://www.iwithjesus.com/news/articleView.html?idxno=2511"><span class="image-caption">농부의 마음으로... <br>출처 : http://www.iwithjesus.com/news/articleView.html?idxno=2511</span><span class="caption">농부의 마음으로... <br>출처 : http://www.iwithjesus.com/news/articleView.html?idxno=2511</span></div><p>아침 10시가 되면 자동으로 메일이 잘 발송되었는지, 혹 어제 수집된 것이 아니라 예전에 수집된 내용이 중복 발송된 건 아닌지, 발송은 구독한 사람 전부에게 잘 보내졌는지… 거의 매일같이 Daily-DevBlog 서비스를 살피며 지낸 것 같다. (하루라도 문제가 생기면 밤을 새워서라도 원인을 파악하고 다음 발송에는 정상적으로 발송되도록 수정하기도 했다.)</p><h3 id="앞으로의-계획과-방향성"><a href="#앞으로의-계획과-방향성" class="headerlink" title="# 앞으로의 계획과 방향성"></a># 앞으로의 계획과 방향성</h3><p>여력이 되는 데까지 이 서비스를 운영할 계획이다. AWS 프리티어 기간이 끝나도 라즈베리파이나 안 쓰는 노트북을 활용해서 서버를 구성하던지 (한 달에 얼마를 지불할지는 모르겠지만) AWS에서 서버를 발급받아서라도 운영하고 싶다. 그 이유는 이 토이프로젝트를 진행하면서 얻게 된 인사이트도 상당히 많았고, python과 apache 등 기존에 알고 있던 부분 이외로 알게 되는 것 또한 많았기 때문이다. 그리고 가장 중요한 <code>공유</code>, 사실 이 서비스를 만들면서 필자 또한 많은 좋은 글들을 볼수있었고 그에 큰 도움도 많이 받을 수 있었다.<br>만들고 싶은 기능도 많다. 포스팅의 내용을 분석하여 자동으로 기술과 관련되지 않는 글을 제외하는 기능도 만들고 싶고, 자동으로 주요 키워드 (태그)를 만들어 이후에도 태그 기준으로 검색을 통해 보고싶은 글을 뉴스처럼 볼수 있는 기능도 만들고 싶고… 운영을 하다 보니 만들고 싶은 기능은 많지만 기술적인 접근이 어려운 상황이다.<br>하지만 가장 중요한 건 새로운 기능 추가보다 안정적으로 매일 아침 10시마다 바로 어제의 글들을 수집하여 구독자들에게 발송하는 것이 가장 중요한 게 아닐까 싶다.</p><div class="figure center" style="width:;"><a class="fancybox" href="subscriber.jpg" title="구독자수 증가 그래프" data-caption="구독자수 증가 그래프" data-fancybox="default"><img class="fig-img" src="subscriber.jpg" alt="구독자수 증가 그래프"><span class="image-caption">구독자수 증가 그래프</span></a><span class="caption">구독자수 증가 그래프</span></div><h3 id="구독자-1-000명-기념-추가-기능-공개"><a href="#구독자-1-000명-기념-추가-기능-공개" class="headerlink" title="# 구독자 1,000명 기념 추가 기능 공개!"></a># 구독자 1,000명 기념 추가 기능 공개!</h3><p>예전부터 1,000명이 되는 시점에 뭔가 이벤트 성으로 새로운 기능을 공개하고 싶어서 준비를 해보았다.</p><ol><li><a href="http://daily-devblog.com/log/view" target="_blank" rel="noopener">아카이브</a><br>위에서 이야기했듯이 <code>기술과 관련되지 않는 글들에 대한 필터링</code>을 기술적으로 하고 싶었으나 예로 들어 “00역 맛집리스트 자동으로 가져오기” 나 “코딩하면서 먹기에 좋은 음식” 이라는 제목이 있을 경우 과연 어떤 글이 기술에 관련된 글이고 어떤 글이 기술과는 거리가 있는 글인지 기술적으로 분석할 방법이 아직까지는 떠오르지 않는다. (물론 머신러닝이나 다른 방법이 있겠지만…)<br>그래서 기존에 수집한 글들을 한 곳에서 보여주면서 기술과는 거리가 있어 보이는 글들에 대해서 제외하고 볼 수 있도록 아카이빙 페이지를 만들었다. 그리고 날짜를 넘겨가며 조회할 수 있고 정렬 순서는 랜덤으로 만들었다. </li><li><p><a href="https://chrome.google.com/webstore/detail/daily-dev-blog-extensions/ejaakkdnneplldikcnkbfdjahmlcaeaa?hl=ko" target="_blank" rel="noopener">크롬 익스텐션</a></p><div class="figure center" style="width:;"><a class="fancybox" href="chrome_ddb.jpg" title="기술블로그 라고 검색해도 나온다." data-caption="기술블로그 라고 검색해도 나온다." data-fancybox="default"><img class="fig-img" src="chrome_ddb.jpg" alt="기술블로그 라고 검색해도 나온다."><span class="image-caption">기술블로그 라고 검색해도 나온다.</span></a><span class="caption">기술블로그 라고 검색해도 나온다.</span></div><p>위에서 만들었던 아카이빙 페이지를 단순하게 익스텐션 클릭 한 번으로 접속이 되도록 만들어보았다. 점심시간 또는 여유시간에 공유된 기술 블로그 포스팅을 쉬운 접근성을 통해 읽어보자는 조금이라도 챙겨보자는 느낌으로 만들게 되었고, 크롬 알림 기능을 활용하여 PC 크롬이 켜져 있는 상황에서 아침 10시가 되면 메일이 발송되는 것처럼 아래 화면과 같이 알람을 주도록 하였다.</p><div class="figure center" style="width:;"><a class="fancybox" href="chrome_ddb.gif" title="아침 10시엔 우리 모두 Daily-DevBlog를~" data-caption="아침 10시엔 우리 모두 Daily-DevBlog를~" data-fancybox="default"><img class="fig-img" src="chrome_ddb.gif" alt="아침 10시엔 우리 모두 Daily-DevBlog를~"><span class="image-caption">아침 10시엔 우리 모두 Daily-DevBlog를~</span></a><span class="caption">아침 10시엔 우리 모두 Daily-DevBlog를~</span></div></li><li><p>주간 인기글<br>구독자들이 어떤 글에 더 관심이 갖는지 궁금하였고 많이 본 글에 대해서는 한 번 더 정리하여 메일로 발송해주는 것이 좋을 것 같다는 생각이 들었다. 그래서 메일로 발송된 글에 대해 클릭수를 기준으로 매주 월요일마다 “주간 인기글”을 발행하는 기능을 추가하였다.</p></li><li><p>단체 블로그 추가 수집<br>지금은 <a href="https://awesome-devblog.netlify.com" target="_blank" rel="noopener">어썸 데브블로그</a>에서 제공해주는 개인 블로거들의 피드를 수집하고 있는데 단체 블로그들 또한 추가로 수집하여 메일의 상단에 배치한다. (단체 블로그는 아무래도 검증이 된 글일 거라 생각이 든다.)</p></li></ol><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>혹시 이 서비스에 대한 아이디어가 있는 분들은 아래 댓글이나 개인 메일로 알려주시면 최대한 반영해보고자 한다. 또한 나중에는 github에 공개하여 오픈소스화한다면 필자보다 더 뛰어난 python 개발자들이 보다 좋은 코드를 만들어주어 점점 해당 서비스가 좋아지지 않을까 하는 기대를 해보며 <code>기술블로그 구독서비스 개발후기</code>를 마친다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;작년 7월 12일부터 시작한 필자의 첫 토이프로젝트인 &lt;a href=&quot;http://daily-devblog.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;기술블로그 구독서비스&lt;/a&gt;. 오픈할 때까지만 해도 “AWS 프리티어를 사용하고 있는 1년 안에 구독자가 설마 1,000명이 넘겠어?” 라고 생각을 했었는데
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
  </entry>
  
  <entry>
    <title>누구나 할 수 있는 엑세스 로그 분석 따라 해보기 (by Elastic Stack)</title>
    <link href="https://taetaetae.github.io/2019/02/10/access-log-to-elastic-stack/"/>
    <id>https://taetaetae.github.io/2019/02/10/access-log-to-elastic-stack/</id>
    <published>2019-02-10T05:37:31.000Z</published>
    <updated>2019-05-30T08:14:51.979Z</updated>
    
    <content type="html"><![CDATA[<p>필자가 Elastic Stack을 알게된건 2017년 어느 여름 동기형이 공부하고 있는것을 보고 호기심에 따라하며 시작하게 되었다. 그때까지만 해도 버전이 2.x 였는데 지금 글을 쓰고있는 2019년 2월초 최신버전이 6.6이니 정말 빠르게 변화하는것 같다. <a id="more"></a>빠르게 변화하는 버전만큼 사람들의 관심도 (드라마틱하게는 아니지만) 꾸준히 늘어나 개인적으로, 그리고 실무에서도 활용하는 범위가 많아지고 있는것 같다.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1709_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"elasticsearch","geo":"KR","time":"today 5-y"}],"category":0,"property":""}, {"exploreQuery":"date=today%205-y&geo=KR&q=elasticsearch","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><p>그래서 그런지 최근들어 <code>(아주 코딱지만큼 조금이라도 더 해본)</code> 필자에게 Elastic Stack 사용방법에 대해 물어보는 주변 지인들이 늘어나고 있다. 그리고 예전에 한창 공부했을때의 버전보다 많이 바꼈기에 이 기회에 “그대로 따라만 하면 Elastic Stack을 구성할 수 있을만한 글”을 써보고자 한다. 사실 필자가 예전에 “도큐먼트를 보기엔 너무 어려워 보이는 느낌적인 느낌” 때문에 삽질하며 구성한 힘들었던 기억을 되살려 최대한 심플하고 처음 해보는 사람도 따라하기만 하면 “아~ 이게 Elastic Stack 이구나!”, “이런식으로 돌아가는 거구나!” 하는 도움을 주고 싶다. </p><blockquote><p>+ 그러면서 최신버전도 살펴보고… 1석2조, 이런게 바로 블로그를 하는 이유이지 않을까?<br>다시한번 말하지만 도큐먼트가 최고 지침서이긴 하다…</p></blockquote><p><a href="https://www.elastic.co/kr/products" target="_blank" rel="noopener">Elastic 공식 홈페이지</a>에 가면 각 제품군들에 대해 그림으로 된 자세한 설명과 도큐먼트가 있지만 이들을 어떤식으로 조합하여 사용하는지에 대한 전체적인 흐름을 볼 수 있는 곳은 없어 보인다. (지금 보면 도큐먼트가 그 어디보다 설명이 잘되어 있다고 생각되지만 사전 지식이 전혀없는 상태에서는 봐도봐도 어려워 보였다.)<br>이번 포스팅에서는 <strong>Apache access log를 Elasticsearch에 인덱싱 하는 방법</strong>에 대해 설명해보고자 한다.</p><h4 id="전체적인-흐름"><a href="#전체적인-흐름" class="headerlink" title="# 전체적인 흐름"></a># 전체적인 흐름</h4><p>필자는 글보다는 그림을 좋아하는 편이라 전체적인 흐름을 그림으로 먼저 보자.</p><div class="figure center" style="width:;"><a class="fancybox" href="concept.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="concept.jpg" alt=""></a></div><ol><li>외부에서의 접근이 발생하면 apache 웹서버에서 설정한 경로에 access log가 파일로 생성이 되거나 있는 파일에 추가가 된다. 해당 파일에는 한줄당 하나의 엑세스 정보가 남게 된다.</li><li>fileBeat에서 해당 파일을 트래킹 하고 있다가 라인이 추가되면 이 정보를 logstash 에게 전달해준다.</li><li>logastsh 는 filebeat에서 전달한 정보를 특정 port로 input 받는다.</li><li>받은 정보를 filter 과정을 통해 각 정보를 분할 및 정제한다. (ip, uri, time 등)</li><li>정리된 정보를 elasticsearch 에 ouput 으로 보낸다. (정확히 말하면 인덱싱을 한다.)</li><li>elasticsearch 에 인덱싱 된 정보를 키바나를 통해 손쉽게 분석을 한다.</li></ol><p>한번의 설치고 일련의 과정이 뚝딱 된다면 너무 편하겠지만, 각각의 레이어가 나뉘어져있는 이유는 하는 역활이 전문적으로(?) 나뉘어져 있고 각 레이어에서는 세부 설정을 통해 보다 효율적으로 데이터를 관리할 수 있기 때문이다.</p><blockquote><p>beats라는 레이어가 나오기 전에는 logstash에서 직접 file을 바라보곤 했었는데 beats가 logstash 보다 가벼운 shipper 목적으로 나온 agent 이다보니 통상 logstash 앞단에 filebeat를 위치시키곤 한다고 한다.</p></blockquote><p>전체적인 그림은 위와 같고, 이제 이 글을 보고있는 여러분들이 따라할 차례이다. 각 레이어별로 하나씩 설치를 해보며 구성을 해보자. 설치순서는 데이터 흐름의 순서에 맞춰 다음과 같은 순서로 설치를 해야 효율적으로 볼수가 있다. (아래순서대로 하지 않을경우 설치/시작/종료 를 각각의 타이밍에 맞추어 해줘야 할것 같아 복잡할것같다.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch → logstash → kibana → filebeat</span><br></pre></td></tr></table></figure><p>이 포스팅은 CentOS 7.4에서 Java 1.8, apache 2.2가 설치되어있다는 가정하에 보면 될듯하다. 또한 각 레이어별 설명은 구글링을 하거나 Elastic 공식 홈페이지에 가보면 자세히 나와있으니 기본 설명은 안하는것으로 하고, 각 레이어의 세부 설정은 하지 않는것으로 한다.</p><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="# Elasticsearch"></a># Elasticsearch</h4><p><a href="https://www.elastic.co/kr/products/elasticsearch" target="_blank" rel="noopener">공식 홈페이지</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">다운받고 압축풀고 심볼릭 경로 만들고 (심볼릭 경로는 선택사항)</span><br><span class="line">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.6.0.tar.gz</span><br><span class="line">$ tar zxvf elasticsearch-6.6.0.tar.gz</span><br><span class="line">$ ln -s elasticsearch-6.6.0 elasticsearch</span><br><span class="line"></span><br><span class="line">설정 파일을 열고 추가해준다.</span><br><span class="line">$ cd elasticsearch/conf</span><br><span class="line">$ vi elasticsearch.yml</span><br><span class="line">path.data: /~~~/data/elasticsearch (기본경로에서 변경할때추가)</span><br><span class="line">path.logs: /~~~/logs/elasticsearch</span><br><span class="line">network.host: 0.0.0.0 # 외부에서 접근이 가능하도록 (실제 ip를 적어줘도 됨)</span><br><span class="line"></span><br><span class="line">elasticsearch 의 시작과 종료를 조금이나마 편하게 하기위해 스크립트를 작성해줌 (이것또한 선택사항)</span><br><span class="line">$ cd ../bin</span><br><span class="line">$ echo &apos;./elasticsearch -d -p es.pid&apos; &gt; start.sh</span><br><span class="line">$ echo &apos;kill `cat es.pid`&apos; &gt; stop.sh</span><br><span class="line">$ chmod 755 start.sh stop.sh</span><br></pre></td></tr></table></figure></p><p>혹시 아래와 같은 에러가 발생할경우 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker-cli-run-prod-mode" target="_blank" rel="noopener">공식문서</a> 대로 진행해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [1] bootstrap checks failed</span><br><span class="line">[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line"></span><br><span class="line">&gt; sudo /sbin/sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure></p><p>이렇게 하고 시작을 한뒤 브라우저에서 <code>http://{ip}:9200</code> 로 접속하면 다음과 같이 설치된 elasticsearch에 기본 정보가 나오게 되고 이렇게 elasticsearch의 설치 및 실행이 완료되었다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;@@@&quot;,</span><br><span class="line">&quot;cluster_name&quot;: &quot;elasticsearch&quot;,</span><br><span class="line">&quot;cluster_uuid&quot;: &quot;@@@&quot;,</span><br><span class="line">&quot;version&quot;: &#123;</span><br><span class="line">&quot;number&quot;: &quot;6.6.0&quot;,</span><br><span class="line">&quot;build_flavor&quot;: &quot;default&quot;,</span><br><span class="line">&quot;build_type&quot;: &quot;tar&quot;,</span><br><span class="line">&quot;build_hash&quot;: &quot;@@@&quot;,</span><br><span class="line">&quot;build_date&quot;: &quot;2019-01-24T11:27:09.439740Z&quot;,</span><br><span class="line">&quot;build_snapshot&quot;: false,</span><br><span class="line">&quot;lucene_version&quot;: &quot;7.6.0&quot;,</span><br><span class="line">&quot;minimum_wire_compatibility_version&quot;: &quot;5.6.0&quot;,</span><br><span class="line">&quot;minimum_index_compatibility_version&quot;: &quot;5.0.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;tagline&quot;: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Logstash"><a href="#Logstash" class="headerlink" title="# Logstash"></a># Logstash</h4><p><a href="https://www.elastic.co/kr/products/logstash" target="_blank" rel="noopener">공식 홈페이지</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">다운을 받고 압축풀고 심볼릭 링크 설정</span><br><span class="line">$ wget https://artifacts.elastic.co/downloads/logstash/logstash-6.6.0.tar.gz</span><br><span class="line">$ tar -zxvf logstash-6.6.0.tar.gz</span><br><span class="line">$ ln -s logstash-6.6.0 logstash</span><br><span class="line"></span><br><span class="line">logstash가 실행될때 설정값 파일을 만들어준다.</span><br><span class="line">$ cd logstash/config</span><br><span class="line">$ vi access_log.conf</span><br><span class="line"># beats 에서 5044 port 로 데이터를 input 받겠다는 의미</span><br><span class="line">input &#123; </span><br><span class="line">        beats &#123; </span><br><span class="line">                port =&gt; &quot;5044&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># grok 필터를 활용하여 엑세스로그 한줄을 아래처럼 파싱하겠다는 의미</span><br><span class="line"># 해당 필터는 apache의 로깅 설정에 의해 만들어지는 파일의 포멧에 맞추어 설정해야한다.</span><br><span class="line">filter &#123;</span><br><span class="line">        grok &#123;</span><br><span class="line">                match =&gt; &#123; &quot;message&quot; =&gt; [&quot;%&#123;IPORHOST:clientip&#125; (?:-|%&#123;USER:ident&#125;) (?:-|%&#123;USER:auth&#125;) \[%&#123;HTTPDATE:timestamp&#125;\] \&quot;(?:%&#123;WORD:httpMethod&#125; %&#123;NOTSPACE:uri&#125;(?: HTTP/%&#123;NUMBER:httpversion&#125;)?|-)\&quot; %&#123;NUMBER:responseCode&#125; (?:-|%&#123;NUMBER:bytes&#125;) (?:-|%&#123;NUMBER:bytes2&#125;)( \&quot;%&#123;DATA:referrer&#125;\&quot;)?( \&quot;%&#123;DATA:user-agent&#125;\&quot;)?&quot;] &#125;</span><br><span class="line">                remove_field =&gt; [&quot;timestamp&quot;,&quot;@version&quot;,&quot;path&quot;,&quot;tags&quot;,&quot;httpversion&quot;,&quot;bytes2&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 정제된 데이터를 elasticsearch 에 인덱싱 하겟다는 의미</span><br><span class="line"># index 이름에 날짜 형태로 적어주면 인덱싱 하는 시점의 시간에 따라 인덱싱 이름이 자동으로 변경이 된다. (아래는 월별로 인덱스를 만들경우)</span><br><span class="line">output &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">                hosts =&gt; [ &quot;&#123;elasticsearch ip&#125;:9200&quot; ]</span><br><span class="line">                index =&gt; &quot;index-%&#123;+YYYY.MM&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행은 다음과 같이 <code>&amp;</code>연산자를 활용하여 background로 실행하게 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/logstash -f config/access_log.conf &amp;</span><br></pre></td></tr></table></figure><p>이렇게 해서 실행을 하고 에러없이 정상적으로 실행이 된뒤 프로세스가 올라와 있으면 (<code>ps -ef | grep logstash</code>) 성공된 상태라 볼수있다.</p><h4 id="Kibana"><a href="#Kibana" class="headerlink" title="# Kibana"></a># Kibana</h4><p><a href="https://www.elastic.co/kr/products/kibana" target="_blank" rel="noopener">공식 홈페이지</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">역시 다운받고 압축풀고 심볼릭 링크 설정</span><br><span class="line">$ https://artifacts.elastic.co/downloads/kibana/kibana-6.6.0-linux-x86_64.tar.gz</span><br><span class="line">$ tar -zxvf kibana-6.6.0-linux-x86_64.tar.gz</span><br><span class="line">$ ln -s kibana-6.6.0-linux-x86_64 kibana</span><br><span class="line"></span><br><span class="line">외부에서 접근을 하기위해 ip를 적어주고, 연결할 elasticsearch 주소또한 적어준다.</span><br><span class="line">$ cd kibana/config</span><br><span class="line">$ vi kibana.yml</span><br><span class="line">server.host: &quot;@.@.@.@&quot;</span><br><span class="line">elasticsearch.hosts: [&quot;http://@.@.@.@:9200&quot;]</span><br></pre></td></tr></table></figure><p>실행은 bin 폴더로 이동후에 다음과 같이 실행시켜준다. 별다른 에러가 없으면 외부에서 접근이 가능한지 확인해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd bin/</span><br><span class="line">$ nohup ./kibana &amp;</span><br><span class="line"></span><br><span class="line">접속 : http://@.@.@.@/5601</span><br></pre></td></tr></table></figure></p><h4 id="Filebeat"><a href="#Filebeat" class="headerlink" title="# Filebeat"></a># Filebeat</h4><p><a href="https://www.elastic.co/kr/products/beats" target="_blank" rel="noopener">공식 홈페이지</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">다운 → 압축해제 → 심볼릭링크</span><br><span class="line">$ wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.6.0-linux-x86_64.tar.gz</span><br><span class="line">$ tar -zxvf filebeat-6.6.0-linux-x86_64.tar.gz</span><br><span class="line">$ ln -s filebeat-6.6.0-linux-x86_64 filebeat</span><br><span class="line"></span><br><span class="line">filebeat가 실행될때의 설정파일을 작성해준다.</span><br><span class="line">$ cd filebeat</span><br><span class="line">$ vi access_log.yml</span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    - /~~~/logs/apache/access.log.* # 실제 엑세스 파일의 경로</span><br><span class="line">  tail_files: true # filebeat 시작시점 기준 파일 끝에서부터 로깅을 읽기 시작</span><br><span class="line">  ignore_older: 1m # filebeat 시작시점 기준 1분전의 내용은 무시</span><br><span class="line">  close_inactive: 2m</span><br><span class="line">  clean_inactive: 15m</span><br><span class="line">logging.level: info</span><br><span class="line">logging.to_files: true</span><br><span class="line">logging.files: # filebeat가 실행되면서 남기는 로깅파일 정보. 도큐먼트를 읽어보는것을 추천한다.</span><br><span class="line">  path: /~~~/logs/filebeat</span><br><span class="line">  name: test-filebeat-log</span><br><span class="line">  keepfiles: 7</span><br><span class="line">  rotateeverybytes: 524288000</span><br><span class="line">output.logstash: # 최종적으로 output 할 logstash의 정보를 입력해준다.</span><br><span class="line">  hosts: [&quot;@.@.@.@:5044&quot;]</span><br></pre></td></tr></table></figure><p>위와 같이 설정파일을 작성한 다음 아래처럼 실행을 하면 엑세스 파일의 내용이 filebeat를 거치고 logstash를 거쳐 최종적으로 elasticsearch 에 도달하게 된다. 기존에 엑세스 로그가 양이 많다면 그 정보를 다 읽는 시간이 걸리므로 주의한다. (filebeat 자체적으로 해당 파일의 offset을 관리하기 때문)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./filebeat -c access_log.yml -d publish &amp;</span><br></pre></td></tr></table></figure><h4 id="최종-확인"><a href="#최종-확인" class="headerlink" title="# 최종 확인"></a># 최종 확인</h4><p>왼쪽에는 해당 서버를 호출하고 오른쪽에는 키바나를 띄워논뒤 테스트를 해보면 아래처럼 access log를 확인이 가능하다. (apache만 띄워놓은 상태라 404상태로 나오긴 한다..) 불필요한 필드가 있다면 logstash 의 filter에서 remove 하면되고 키바나에서 각 정보를 가지고 다양한 유의미한 데이터를 만들어볼 수 있게 되었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="kibana.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="kibana.jpg" alt=""></a></div><h4 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h4><p>막상 해보면 (해보기전에 느끼는 두려움보다는) 엄청나게 미친듯이 어렵지는 않는데… 맨땅에 해딩이든 뭐든 시작해보고 만들어보는게 중요하다고 다시한번 생각해본다. 필자는 elasticsearch 2.4버전에 대해 영어로된 문서를 보며 설치하고 구성하며 (왜 한글로 된 문서가 한명도 없을까…) 하는 아쉬움에 있었는데 이 글이 필자처럼 설치하는데 비슷한(?) 고충을 느낀 사람들에게 도움이 되었으면 한다.<br>마지막으로 세부 설정값들로 인해 성능이나 기능이 다양하게 바뀔수 있으니 <a href="https://www.elastic.co/guide/kr/index.html" target="_blank" rel="noopener">공식 도큐먼트</a>를 보는것을 강력 추천하고 싶다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;필자가 Elastic Stack을 알게된건 2017년 어느 여름 동기형이 공부하고 있는것을 보고 호기심에 따라하며 시작하게 되었다. 그때까지만 해도 버전이 2.x 였는데 지금 글을 쓰고있는 2019년 2월초 최신버전이 6.6이니 정말 빠르게 변화하는것 같다.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="elasticsearch" scheme="https://taetaetae.github.io/tags/elasticsearch/"/>
    
      <category term="logstash" scheme="https://taetaetae.github.io/tags/logstash/"/>
    
      <category term="kibana" scheme="https://taetaetae.github.io/tags/kibana/"/>
    
      <category term="filebeat" scheme="https://taetaetae.github.io/tags/filebeat/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC Redirect 처리중에 발생한 Out Of Memory 원인 분석하기</title>
    <link href="https://taetaetae.github.io/2019/01/10/spring-redirect-oom/"/>
    <id>https://taetaetae.github.io/2019/01/10/spring-redirect-oom/</id>
    <published>2019-01-10T09:39:47.000Z</published>
    <updated>2019-06-30T16:34:26.503Z</updated>
    
    <content type="html"><![CDATA[<p>초창기 신입시절에 배우거나 사용했던 기술적인 방법들이 있다. 시간이 지날수록 왠만해선 다른방법은 사용하지 않으려 하고 <code>습관</code>처럼 기존에 사용했던 방법을 고수하는 버릇이 있다. 그 이유는 과거에 사용했을때 아무 탈 없이 잘 되었기 때문에, 그리고 빠른 구현 때문이라는 핑계일 것 같다. <a id="more"></a>이러한 버릇은 비단 이 글을 적고있는 필자 뿐만이 아니라 대부분의 개발자들이 가지고 있을꺼라 조심스레 추측해본다. (아니라면…더욱 분발 해야겠다…ㅠ)<br>최근 운영하고 있는 서비스에서 장애 상황까지 갈수있는 위험한 상황이 있었는데 팀내 코드리뷰를 통해 문제점을 파악할 수 있었다. 그 원인은 Spring MVC Controller 레벨에서 redirect 처리를 할때 return값의 Cardinality가 높을경우 다음과 같이 사용하면 안된다고…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String url = <span class="string">"어떠한 로직에 의해 생성되는 url"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:"</span> + url; <span class="comment">// &lt;- 위험 포인트!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드가 왜? 어디가 어때서?<br>이제까지 Controller 레벨에서 redirect 처리를 할때 아무생각없이 위에 있는 코드 형태로 구현을 했는데 저러한 코드 때문에 OOM이 발생하여 fullGC 가 여러번 발생하고, 일시적으로 서비스가 지연되는 현상이 발생했다고 한다. 자주 사용하던 방법이였는데 장애를 유발할수 있는 위험한 방법이였다니…<br>이번 포스팅에서는 이러한 방법이 왜 잘못되었는지 실제로 테스트를 통해 몸소(?) 체감을 해보고, 그럼 어떤 방법으로 redirect 처리를 해야 하는가와 개선을 함으로써 기존방식에 비해 어떤점이 좋아졌는지에 대해서 정리해보고자 한다. </p><blockquote><p>뭔가 <strong>내것으로 만들기</strong> 시리즈물이 나올것만 같은 느낌이다…</p></blockquote><h4 id="기존방식의-문제점-재현-및-다양한-원인분석"><a href="#기존방식의-문제점-재현-및-다양한-원인분석" class="headerlink" title="# 기존방식의 문제점 재현 및 다양한 원인분석"></a># 기존방식의 문제점 재현 및 다양한 원인분석</h4><p>기존방식으로 했을때 왜 OOM이 발생했을까? 우리는 개발자이기 때문에 이런저런 글들만 보고 추측 할것이 아니라 직접 재현을 해보고 다양한 시각에서 원인분석을 해보자.<br>먼저 기본적인 Spring MVC 뼈대를 만들고 redirect 하는 return 값의 Cardinality가 높도록 random string 을 만들어 주도록 한다. 즉, <code>/random</code>을 호출하면 <code>/result/ETmHfowFkU</code>처럼 random string 이 만들어 지며 redirect 처리가 되는 매우 심플한 구조이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring 버전은 4.0.6.RELEASE</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"random"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:result/"</span> + UUID.randomUUID();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"result/&#123;message&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">result</span><span class="params">(ModelMap model, @PathVariable String message)</span> </span>&#123;</span><br><span class="line">model.addAttribute(<span class="string">"message"</span>, message);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또한 해당 프로젝트에서는 AOP를 사용하고 있었기 때문에 그때와 동일한 상황으로 재현을 하기 위해 AOP관련 설정도 추가해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"HelloWorld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InternalResourceViewResolver viewResolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">viewResolver.setViewClass(JstlView.class);</span><br><span class="line">viewResolver.setPrefix(<span class="string">"/WEB-INF/views/"</span>);</span><br><span class="line">viewResolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 한뒤 tomcat으로 최대/최소 메모리를 256m으로 설정후 해당 모듈을 띄워준다. 그다음 메모리 상태를 보기 위해 tomcat에 pinpoint를 연동하고 마지막으로 호출테스트를 위해 nGrinder을 설정해준다. 특별한 설정은 없고 위 컨트롤러의 url (/random) 을 여러번 호출하도록 하였다. nGrinder을 설정하는대에는 <a href="https://black9p.github.io/2019/01/02/nGrinder-%EA%B0%84%ED%8E%B8-%EC%82%AC%EC%9A%A9%EA%B0%80%EC%9D%B4%EB%93%9C/" target="_blank" rel="noopener">이 블로그 포스팅</a>을 참고해서 설정하였다.</p><p>자, 이제 테스트를 시작해보자. (마치 수술 집도하는것 같은 기분으로…간호사~ 칼!)</p><ol><li><p>nGrinder<br>nGrinder의 기본 스크립트에서 url만 해당 서버로 호출되도록 바꿔주고 총 가상 사용자는 2,000으로 시간은 5분으로 설정후에 테스트 시작을 하였더니 다음과 같은 그래프를 볼수 있었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="test1-ngrinder.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test1-ngrinder.jpg" alt=""></a></div><p>TPS가 불안정해지다가 어느시점부터 낮아지는것을 확인할 수 있다. 이게 서비스 였다면 사용자가 접속하는데 불편을 느꼈을꺼라 추측을 해본다. 또한 아주 간단한 random string 을 리턴하는 페이지 임에도 불구하고 에러 응답이 적지 않은것을 확인할 수 있었다.</p></li><li><p>pinpoint<br>메모리 상태는 어떤지 확인하기 위해 pinpoint를 확인해보면 다음과 같은 그래프를 볼수 있었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="test1-pinpoint.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test1-pinpoint.jpg" alt=""></a></div><p>보기만해도 심장이 벌렁벌렁(?) 뛸 정도로 무서운 그림이다. 실제로 서비스에 (이정도까진 아니였지만) 비슷한 상황이 발생했었다. 메모리가 테스트를 점점 하면 할수록 올라가다가 fullGC가 발생하더니 대나무 숲에 있는 대나무마냥 fullGC가 빼곡히 발생하였다. (이러니… 페이지 접근에 지연이 생긴것 같다.)</p></li><li><p>Heap dump<br>그럼 실제로 메모리는 어떤 상태였고 어디서 메모리를 많이 사용하고(점유하고) 있는지를 확인하기 위해 Heap dump를 생성해 보았다. 힙덤프 분석하는데 잘 알려진 <a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">Memory Analyzer (MAT)</a>를 다운받고 해당 프로세스의 힙덤프를 생성한다음 분석을 해봤더니 아래와 같은 화면을 볼 수 있었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="test1-dump1.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test1-dump1.jpg" alt=""></a></div><p>힙덤프 파일을 열자마자 (저 문제 있어요~ 도와주세요 하듯) 뭔가 많이 점유하고 있는것처럼 보이는 파이그래프가 Overview에 보였다. Reports 영역에 있는 Leak Suspects를 확인해보니 아래 경로에서 많이 사용하는 것을 확인할 수 있었다.</p><blockquote><p>java.util.concurrent.ConcurrentHashMap$Node</p></blockquote><p><br></p><div class="figure center" style="width:;"><a class="fancybox" href="test1-dump2.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test1-dump2.jpg" alt=""></a></div><p>이 툴에서는 OQL이라고 힙덤프에 있는 데이터를 일반 SQL처럼 쿼리처럼 볼수 있었다. 그래서 아래처럼 쿼리를 작성해서 봤더니 결과만 봐도 어디서 메모리를 점유하고 있는지 한눈에 볼수 있었다</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.key.toString() </span><br><span class="line"><span class="keyword">FROM</span> java.util.concurrent.ConcurrentHashMap$Node o </span><br><span class="line"><span class="keyword">WHERE</span> ((o.key != <span class="literal">null</span>) <span class="keyword">and</span> (o.key.toString().indexOf(<span class="string">"org.springframework.web.servlet.view.RedirectView_redirect"</span>) = <span class="number">0</span>))</span><br></pre></td></tr></table></figure><div class="figure center" style="width:;"><a class="fancybox" href="test1-dump3.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test1-dump3.jpg" alt=""></a></div><p>무작위로 만들어진 url에 대한 정보를 캐시하고 있는 듯한 결과였다.</p></li></ol><h4 id="방식-개선-및-변화-비교"><a href="#방식-개선-및-변화-비교" class="headerlink" title="# 방식 개선 및 변화 비교"></a># 방식 개선 및 변화 비교</h4><p>결국 <code>return &quot;redirect:&quot; + url;</code> 와 같은 처리가 문제를 야기했던 것이였다. 그럼 redirect 처리를 어떻게 하는게 좋을까?<br>조금 검색을 해보면 <code>RedirectView</code> 나 <code>ModelAndView</code>를 사용하라고 권장하고 있다. 물론 redirect 되는 url의 Cardinality가 높지않고 고정적이라면 지금의 <code>return &quot;redirect:&quot; + url;</code> 이 방식을 사용해도 무방할수 있다. 하지만 컨트롤러 메소드가 String타입을 return 하게 되면 View 클래스로 변환작업을 진행하게 된다고 한다.<br>이 작업중에 <code>org.springframework.beans.factory.config.BeanPostProcessor</code>구현체들도 같이 진행되고, 이중에 하나가 <code>AnnotationAwareAspectJAutoProxyCreator</code> 라고 있는데 해당 클래스 내부적으로 <code>ConcurrentHashMap&lt;Object, Boolean&gt;</code> 타입 객체에 key : viewName, value : 필요 여부(boolean) 형태로 갯수 제한 없이 저장하고 있다. 그러다보니 url의 종류가 많아질수록 메모리가 많이 사용될 수밖에 없었던 것 같다.<br>즉, 동일한 url에 대해 View 객체를 캐싱하고 있으니 위와 같이 url의 종류가 다양할경우 (특히 로그인 같은 처리를 할때 고유값을 파라미터로 넘기는 경우) 캐싱 객체 숫자가 많아지기 마련이다.</p><p>실제로 코드를 보면 캐싱을 하고있는것을 볼수 있다. <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java#L358" target="_blank" rel="noopener">Spring-project github</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 생략</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 생략</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE); <span class="comment">// &lt;- 여기 </span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 생략</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE); <span class="comment">// &lt;- 여기 </span></span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 생략</span></span><br></pre></td></tr></table></figure></p><p>자, 그럼 개선방법을 알아봤으니 한번 비교를 해보자. 아래처럼 <code>ModelAndView</code>를 사용해서 redirect처리를 할수있도록 코드를 변경하고</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"random"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">    RedirectView redirectView = <span class="keyword">new</span> RedirectView();</span><br><span class="line">    redirectView.setUrl(<span class="string">"result/"</span> + UUID.randomUUID());</span><br><span class="line"></span><br><span class="line">    modelAndView.setView(redirectView);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/result/&#123;message&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">result</span><span class="params">(ModelMap model, @PathVariable String message)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"message"</span>, message);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기존과 동일한 방법과 환경에서 테스트를 해보자.</p><ol><li><p>nGrinder<br>위해서 했던 방법과 동일한 가상 사용자 수와 동일한 시간으로 테스트를 해보니 다음과 같은 그래프를 볼수 있었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="test2-ngrinder.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test2-ngrinder.jpg" alt=""></a></div><p>위에서 봤던 들쭉날쭉 그래프보다 훨씬 더 안정적인것을 볼 수 있었고, 에러도 단 한건도 없이 훨씬 높은 TPS를 끝까지 일정하게 유지하는 모습을 볼수 있었다. (로직상 에러가 나는게 이상한… 아니 안나야 정상이다.) </p></li><li><p>pinpoint<br>TPS가 안정적이였기 때문에 메모리의 상태를 안봐도 되겠지만 비교의 목적이 있기 때문에 pinpoint 의 그래프를 한번 보자.</p><div class="figure center" style="width:;"><a class="fancybox" href="test2-pinpoint.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test2-pinpoint.jpg" alt=""></a></div><p>nGrinder로 테스트하는 시점만 잠깐 메모리가 올라가다가 다시 내려오고 전에 있었던 fullGC도 없고 위에서 테스트 했던 그래프 보다는 안정적인 그래프라고 볼수 있었다.</p></li><li><p>Heap dump<br>메모리가 안정적이였지만 혹시 pinpoint에서 잘못 집계하거나 그래프만 보고 맹신할수 없었기 때문에 이번에도 Heap dump를 생성해 보았다.</p><div class="figure center" style="width:;"><a class="fancybox" href="test1-dump2.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test1-dump2.jpg" alt=""></a></div><p>일단 점유하고 있는 메모리의 크기가 약 10분의 1정도로 줄어든것을 확인할수 있었고, 위에서 했던 OQL을 이용한 메모리 점유를 확인해봐도 기존에 있던 <code>RedirectView_redirect</code>관련 데이터가 아예 없음을 확인할 수 있었다.</p><div class="figure center" style="width:;"><a class="fancybox" href="test2-dump2.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test2-dump2.jpg" alt=""></a></div></li></ol><p>코드 몇줄 변경한것밖에 없는데 같은 테스트 환경에서 확연히 좋아진것을 확인할 수 있다. (뿌듯) 전체적으로 다시 비교를 해보면 아래와 같이 이쁜(?) 변화를 볼수가 있다.<br><div class="figure center" style="width:;"><a class="fancybox" href="test-diff.jpg" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="test-diff.jpg" alt=""></a></div></p><h4 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h4><p>평소에 자주 사용하던 방식인데 성능적으로 자칫 치명적인 결과를 가져올수 있다고 하여 재현을 안해볼수가 없었다. 만약 악의적으로 url뒤에 무작위 문자열을 더해서 ddos공격을 했더라면? 얼마 안가서 서버가 터졌을지도 모른다.<br>지금이라도 알아서 다행이라는 생각과 재현을 안해보고 그냥 그런가보다 하며 넘어갔다면 실제 Spring 내부 코드까지 볼일이 있었을까 하는 생각을 해본다.<br>이번에 재현을 해보면서 nGrinder 로 성능테스트에 pinpoint 모니터링, 마지막으로 힙덤프 분석까지. 꼭 이번 url redirect 문제만이 아니라 다른 성능적인 이슈가 생길때 마치 <code>치트키</code>처럼 활용할수 있을 <code>나만의 무기</code>를 얻은것 같아 다시한번 뿌듯함을 느낀다.</p><p>마지막으로, 이렇게 재현까지 하도록 <code>자극</code>을 주신 팀 동료분께 감사드린다고 전하고 싶다. (보실지 안보실지 모르겠지만 ^^;)</p><hr><ul><li>관련 참고글<br><a href="https://www.baeldung.com/spring-redirect-and-forward" target="_blank" rel="noopener">https://www.baeldung.com/spring-redirect-and-forward</a><br><a href="https://www.slideshare.net/benelog/ss-35627826" target="_blank" rel="noopener">https://www.slideshare.net/benelog/ss-35627826</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;초창기 신입시절에 배우거나 사용했던 기술적인 방법들이 있다. 시간이 지날수록 왠만해선 다른방법은 사용하지 않으려 하고 &lt;code&gt;습관&lt;/code&gt;처럼 기존에 사용했던 방법을 고수하는 버릇이 있다. 그 이유는 과거에 사용했을때 아무 탈 없이 잘 되었기 때문에, 그리고 빠른 구현 때문이라는 핑계일 것 같다.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="spring" scheme="https://taetaetae.github.io/tags/spring/"/>
    
      <category term="redirect" scheme="https://taetaetae.github.io/tags/redirect/"/>
    
      <category term="out of memory" scheme="https://taetaetae.github.io/tags/out-of-memory/"/>
    
      <category term="heap dump" scheme="https://taetaetae.github.io/tags/heap-dump/"/>
    
  </entry>
  
  <entry>
    <title>천만 명의 사용자에게 1분 내로 알림 보내기 (병렬프로세스의 최적화)</title>
    <link href="https://taetaetae.github.io/2019/01/02/faster-parallel-processes/"/>
    <id>https://taetaetae.github.io/2019/01/02/faster-parallel-processes/</id>
    <published>2019-01-02T03:43:44.000Z</published>
    <updated>2019-05-30T08:14:51.910Z</updated>
    
    <content type="html"><![CDATA[<p>만약 1번부터 10번까지 번호표가 있는 사람들 총 열명에게 혼자서 동일한 내용의 메일을 보낸다고 가정해보자. 그리고 메일 발송시 한번에 한명에게만 보내야 하는 제한사항이 있을때 과연 당신은 어떤식으로 보내겠는가? 이어서 읽지말고 한번 생각해보자.<a id="more"></a><br>아무것도 고려하지 않고 단순하게 생각한다면 1번 보내고 &gt; 2번 보내고 … 9번 보내고 &gt; 10번 보내는 방법이 먼저 떠오르게 된다. (for loop 1 to 10 … ) 하지만 보내야 할 사람들이 많아져서 백명, 천명 많게는 천만명에게 보내야 할 경우 방금과 같은 순차적인 방법을 사용하면 너무 늦게 발송된다는건 코드를 작성하지 않아도 알 수있는 문제… 그렇다면 어떤 방법으로 보내야 보다 빨리 보낼수 있을까?<br>이번 포스팅에서는 필자가 운영하고 있는 서비스에서 기존에 있던 병렬프로세스를 어떤식으로 최적화 했는지, 그래서 결국 얼마나 빨라졌는지에 대한 과정을 정리해 보고자 한다. 비단 메일 발송이나 앱 푸시 등 특정 도메인에 국한되지는 않고 전반적인 프로세스에 대해 이해를 한다면 다른 곳에서도 비슷한 방법으로 활용할 수 있을꺼라 기대 해본다.</p><hr><h3 id="상황파악-및-목표"><a href="#상황파악-및-목표" class="headerlink" title="# 상황파악 및 목표"></a># 상황파악 및 목표</h3><p>(원할한 이해를 돕기 위하여) 먼저 필자가 운영하고있는 서비스를 간략히 소개부터 해야겠다. (그렇다고 필자 혼자 다 하는건 아님^^;…)<br>셀럽의 방송이 시작되면 구독한 사용자에게 각 모바일 기기에 설치되어있는 앱으로 알림을 보내어 예정에 없던 깜짝 라이브 방송이나 VOD 영상 오픈을 보다 빠르게 확인할 수 있도록 제공하고 있다.<br>여기서, 알림이 늦게 발송되면 셀럽은 방송을 시작하고 팬들이 들어오기까지 기다려야 한다거나 반대로 팬들은 방송 시작하고 뒤늦게 방송을 보게되는 불편함이 생기게 된다. 그리고 중복으로 알림이 발송되거나 특정 사용자들에게 발송이 누락되면 안 되는 등 “알림” 이란 기능은 서비스에 있어서 중요한 기능 중에 하나라고 할수 있다.</p><blockquote><p>여기서 “발송 시간”은 처음 발송작업 시작부터 마지막 사용자에 대해 사내 발송 플랫폼으로 발송 요청을 하기까지의 시간을 의미</p></blockquote><p>그리고 “채널” 이라는 샐럽단위의 그룹이 있는데 영상과 채널의 관계는 1:N이다. 즉, 하나의 영상을 여러 채널에 연결시킬수 있어서 하나의 영상에 대해 여러 채널들에게 연결을 시켜놓으면 채널을 구독하고있는 각각의 사용자에게 모두 알림을 발송 할수가 있게 된다.</p><p>우선, 알람이 사용자에게 전달되기까지의 큰 흐름은 다음과 같다.</p><div class="figure center" style="width:;"><img class="fig-img" src="push_process.jpg" alt="알림 프로세스"><span class="image-caption">알림 프로세스</span><span class="caption">알림 프로세스</span></div><ol><li>서비스에서 보낼 대상과 보낼 정보를 조합하여 </li><li>사내 푸시 발송 플랫폼인 사내 발송 플랫폼에게 전달을 하면 플랫폼에 따라 발송이 되고</li><li>최종적으로는 사용자의 모바일 기기에 노출이 됨</li></ol><p>간단하게 “병렬로 발송하면 되지 않을까?”라는 필자의 생각이 부끄러워질 정도로 이미 redis, rabbitMQ 를 활용해서 아래 그림처럼 병렬 프로세스로 구성되어 있었다.</p><div class="figure center" style="width:;"><img class="fig-img" src="legacy_structure.jpg" alt="기존 구조"><span class="image-caption">기존 구조</span><span class="caption">기존 구조</span></div><ol><li>라이브가 시작되거나 VOD가 오픈될 경우 api가 호출이 되고 다시 배치 서버에게 영상의 고유번호를 전달</li><li>전달받은 영상의 고유번호를 rabbitMQ의 수신자 조회 Queue에 produce</li><li>수신자 조회 Queue의 consumer인 수신자 조회 모듈에서 영상의 고유번호를 consume 후 아래 작업을 진행<br>3-1. 영상:채널 은 1:N 구조이기 때문에 여러 채널의 사용자들에게 알림을 발송할 수 있고, 영상에 연결된 채널들의 user를 db에서 가져온다.<br>3-2. 가져온 user를 (중복으로 알림이 발송되지 않기 위해) java set에 담고 모든 채널을 조회했다면 redis에 sorted set으로 담는다.<br>3-3. 적당한 크기로 분할하고 이 분할정보를 발송 Queue에 produce</li><li>발송 모듈에서 분할 정보를 consume 하고 아래 작업을 진행 (병렬처리)<br>4-1. redis 에서 user 모음을 가져오고<br>4-2. 조회한 user에 해당하는 deviceId를 db에서 가져옴</li><li>deviceId와 컨텐츠 정보를 활용하여 적절한 payload를 구성 후 사내 발송 플랫폼 에게 전달</li></ol><p>기존 구조에서 발송 시간은 서비스에서 구독자 수가 가장 많은 채널 기준으로 약 1.1천만 명에게 최종 11분 정도 소요되고 있었다. (맨 처음에 이야기 한 순차적인 방법이였다면… 훨씬더 오래 걸렸을꺼라 예상해본다…)</p><p>기존에 구성하셨던 분들도 수많은 시행착오와 고민을 하시며 구성하셨을 텐데 더 이상 어떻게 더 빠르게 보낼 수 있을까 하는 부담감과 자칫 알림이 잘못 발송되기라도 한다면(장애가 발생한다면) 그 수많은 사용자들의 불만 화살 과녁이 필자가 되어야 한다는 압박감이 개선 시작 전부터 머릿속을 휘감고 있었던 찰나에</p><div class="figure center" style="width:;"><img class="fig-img" src="goal.jpg" alt="답정너"><span class="image-caption">답정너</span><span class="caption">답정너</span></div><p>라는 불가능할 것만 같은 목표가 (<a href="https://ko.dict.naver.com/#/entry/koko/5e83a17fa0064cc0bb6879031f4d32a2" target="_blank" rel="noopener">답정너</a> 마냥) 정해지며 그렇게 푸시 개선 프로젝트가 시작되었다. 결국 <strong>사내 발송 플랫폼에게 얼마나 더 빨리 보낼수 있는가</strong> 가 개선 포인트 라고 할수 있겠다.</p><hr><h3 id="1차-개선-AsyncRestTemplate-적용"><a href="#1차-개선-AsyncRestTemplate-적용" class="headerlink" title="# 1차 개선 : AsyncRestTemplate 적용"></a># 1차 개선 : AsyncRestTemplate 적용</h3><p>사내 발송 플랫폼에 요청을 한 뒤 응답의 종류(성공/실패)에 따라 발송 시간 로깅만 하기 때문에 응답을 기다리지 않고 <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/AsyncRestTemplate.html" target="_blank" rel="noopener">AsyncRestTemplate</a>를 사용해서 비동기 호출로 변경하였다. 사내 발송 플랫폼에 요청에 따른 응답은 1~2초 내외였지만 발송 대상이 많을수록 기다리는 시간을 모아보면 무시 못 할 시간이었기 때문이다.</p><p>구조가 크게 변경된 건 없었고 발송하는 부분에서 약간의 로직만 변경하였는데 나름의 큰 효과를 볼 수 있었다.</p><p><strong>▶ 개선 결과</strong></p><table><thead><tr><th>항목</th><th>기존</th><th>1차</th><th>2차</th><th>3차</th></tr></thead><tbody><tr><td>발송 대상수</td><td>약 10,530,000명</td><td><font color="red">약 10,570,000명</font></td><td></td><td></td></tr><tr><td>첫발송</td><td>약 6분</td><td><font color="red">약 6분</font></td><td></td><td></td></tr><tr><td>마지막 발송</td><td>약 11분</td><td><font color="red">약 7분</font></td><td></td></tr></tbody></table><hr><h3 id="2차-개선-발송대상-구하는-즉시-병렬-발송처리-불필요-프로세스-제거"><a href="#2차-개선-발송대상-구하는-즉시-병렬-발송처리-불필요-프로세스-제거" class="headerlink" title="# 2차 개선 : 발송대상 구하는 즉시 병렬 발송처리, 불필요 프로세스 제거"></a># 2차 개선 : 발송대상 구하는 즉시 병렬 발송처리, 불필요 프로세스 제거</h3><ul><li>발송대상 구하는 즉시 병렬 발송처리<br>기존 구조에서는 발송 대상을 전부다 구한 뒤에 발송이 시작되었다. 왜냐하면 영상에 연결된 채널이 여러 개가 될 수 있다 보니 중복 사용자 제거를 해야 하기 때문이었다. 예로 들어 영상 하나에 A, B, C 채널이 연결되어있고 어느 사용자가 A, B 채널을 구독하고 있는 상황에서 중복제거를 하지 않고 보낸다면 해당 사용자는 같은 내용의 알림을 두 번 받는 상황이 된다.<br>영상에 연결된 채널이 한 개라면 문제가 없지만 두 개 이상일 경우부터 중복알림 문제가 발생했기 때문에, 그리고 이 중복제거 프로세스가 다 되어야지만 첫 번째 발송이 되는 구조였기 때문에 어떻게든 다른 방법으로 중복 발송을 해결해야만 했다.<br>그래서 여러 시행착오 끝에 결정된 방법은 “이 사용자는 발송이 되었다”라는 정보를 redis에 담는 식으로 중복체크하는 방법을 바꾸는 것이었다. 또한 첫 번째 채널(구독자 수가 가장 많은 채널)은 중복체크를 할 필요가 없기 때문에 db에서 조회하는 즉시 발송해서 방송 시작 1초 내에 사용자에게 알림을 발송할 수가 있었다.</li><li>불필요 프로세스 제거<br>발송 triggering 을 배치(jenkins)에서 하고 있었다. api에서 jenkins remote api로 호출이 되면 기본적으로 약 20~30초가량의 인스턴스 구동시간이 존재하게 되는데 이 시간 또한 불필요한 프로세스라고 생각되어 api가 바로 수신자 조회 Queue에 produce 하는 식으로 구조를 변경하였다.</li></ul><div class="figure center" style="width:;"><img class="fig-img" src="improvement_2.jpg" alt="2차 개선"><span class="image-caption">2차 개선</span><span class="caption">2차 개선</span></div><ol><li>api에서 바로 수신자 조회 분할 Queue로 produce</li><li>수신자 조회 분할 모듈에서 consume을 하고 적당한 크기로 start index, end index를 구분하여 다시 수신자 조회 Queue로 produce</li><li>수신자 조회 모듈이 병렬로 consume을 하며 아래 작업을 수행합니다.<br>3-1. 발송 대상 user를 db에서 가져옴<br>3-2. 첫 번째 채널일 경우(구독자 수가 가장 많은 채널) 중복제거키에 담고 발송대상 key에 담은 뒤 발송 Queue에 produce<br>3-3. 첫 번째 채널이 아닐 경우 중복제거를 해야 하기 때문에 중복제거키에서 redis의 <a href="https://redis.io/commands/zscore" target="_blank" rel="noopener">zscore 연산</a> (시간 복잡도 O(1) )을 활용하여 발송되지 않은 user만 간추려서 발송 대상 key에 담은 뒤 발송 Queue에 produce</li><li>기존과 동일</li></ol><p>이렇게 개선한 결과 사용자들이 방송이 시작되자마자 알림을 받기 시작할 수 있었고, 발송 대상을 구하자마자 발송하기 때문에 발송 속도도 개선이 됬음을 확인할 수 있었다.</p><p><strong>▶ 개선 결과</strong></p><table><thead><tr><th>항목</th><th>기존</th><th>1차</th><th>2차</th><th>3차</th></tr></thead><tbody><tr><td>발송 대상수</td><td>약 10,530,000명</td><td>약 10,570,000명</td><td><font color="red">약 11,120,000명</font></td><td></td></tr><tr><td>첫발송</td><td>약 6분</td><td>약 6분</td><td><font color="red">약 1초</font></td><td></td></tr><tr><td>마지막 발송</td><td>약 11분</td><td>약 7분</td><td><font color="red">약 5분 30초</font></td></tr></tbody></table><hr><h3 id="3차-개선-발송대상-병렬x병렬조회-redis-파티셔닝-채널간의-발송-타이밍-해소"><a href="#3차-개선-발송대상-병렬x병렬조회-redis-파티셔닝-채널간의-발송-타이밍-해소" class="headerlink" title="# 3차 개선 : 발송대상 병렬x병렬조회, redis 파티셔닝, 채널간의 발송 타이밍 해소"></a># 3차 개선 : 발송대상 병렬x병렬조회, redis 파티셔닝, 채널간의 발송 타이밍 해소</h3><ul><li><p>발송대상 병렬x병렬조회<br>몇 차례 속도 개선을 하는 필자를 보고 팀원 분들이 짠하게(?) 느끼셨는지 아이디어를 하나 건네주셨다. 그건 바로 db에서 user를 조회할 때 병렬 조회하는 것을 다시 병렬 조회하는 것.<br>db에 채널별 구독자 테이블에는 user가 오름차순으로 정렬되어 있다 보니 큰 단위로 나눌수가 있고, 다시 이를 작은 단위로 분할하여 조회가 가능했던 것이었다. 대신, 나누는 단위가 적당해야 하고(테스트를 통해서 찾아내야…) user가 꽉 찬(?) 그룹이 있는가 반면 비어있는 그룹이 있을 수가 있다. 그림으로 그려보면 다음과 같다.</p><div class="figure " style="width:;"><img class="fig-img" src="user.jpg" alt=""></div><ul><li>1단계 : 첫 번째 user가 1, 마지막 user가 300만이라고 가정할 때 큰 단위(10만)로 분할합니다.<br>예 ) 0~100,000 / 100,000~200,000 / … / 2,900,000~3,000,000</li><li>2단계 (병렬) : 1단계에서 나눈 단위를 다시 작은 단위(1,000)로 분할하여 db에서 조회를 하고 그다음 단계를 진행합니다.<br>예) 0~1,000 / 1,000~2,000 / … / 99,000~100,000</li></ul><p>이렇게 하고서 반영을 해보니 속도가 빨라진 대신 redis 가 부하를 많이 받게 되어 다른 모듈에서 redis 를 사용하는 곳에서 지연이 발생하게 되었습니다. 모니터링 툴인 pinpoint에 롯데타워가 뙇..</p><div class="figure " style="width:;"><img class="fig-img" src="pinpoint.jpg" alt=""></div><p>결국 알림 속도를 빠르게 한답시고 서비스 전체가 사용하는 공용 redis에 지연이 발생하게 되어버린 것이었다. 개선을 함에 있어 서비스 영향도를 리스트업 하고, 조금이라도 문제가 생길것 같은 부분을 고려해야 하는 교훈을 얻을수 있었다.</p></li><li>redis 파티셔닝<br>알림 발송만을 위한 별도 redis 클러스터를 구축하기에는 장비 발급부터 간단한 작업이 아니었기에 어떻게든 로직에서 해결점을 찾아야 했다. 고민의 고민을 한 결과 redis 는 Single thread 방식으로 처리하기 때문에 key 하나에 연산이 끝날 때까지 해당 key가 속한 redis는 다른 연산을 처리할 수가 없게 되는 부분을 인지하고 중복 발송을 막기 위한 redis 키를 기존에는 하나를 사용하고 있었는데 이를 user 값 기준으로 여러 개의 키로 파티셔닝 하게 되었다.<br>즉, user가 천만 개라고 가정했을 때 기존에는 한 개의 키에 천만 개가 들어가던 구조에서 user 값을 10,000으로 나누어 결과적으로는 하나의 키에 1,000개씩 총 10,000개의 키에 파티셔닝되어 들어가게 되는 구조로 변경하게 되었다. 그랬더니 발송 속도도 더 빨라지고 pinpoint에 응답 그래프도 전혀 문제가 없는 수치인 것을 확인할 수 있었다.</li><li><p>채널간의 발송 타이밍 해소<br>여러 채널을 동시에 보내다 보니 아주 간헐적으로 중복 알림이 발생하게 되었다. 이유는 지금까지 프로세스를 보면 여러 단계의 병렬 프로세스가 있는데 각 프로세스별 순서 보장이 안되고 각자 진행되기 때문에 중복체크 키에 들어가기 전에 다른 프로세스에서 먼저 중복체크를 하고 발송을 해버리면 중복으로 발송이 되어버리던 것이었다. 간단히 그림으로 설명해보면…</p><div class="figure " style="width:;"><img class="fig-img" src="rabbitmq.jpg" alt=""></div><p>위 그림에서 1,2,3,4,5 가 동시에 발송을 시작한다고 가정했을 때 그 다음은 2번이 먼저 진행될 수도 있고 5번이 먼저 진행될 수도 있게 된니다. 그렇기 때문에 매번 중복 알림이 발생되는 건 아니었지만 아주아주 간헐적으로 발생하게 되었다.<br>이 문제는 간단히 채널별로 병렬 조회 하는 부분에서, 1초마다 발송 대상수(redis 를 활용하여 로깅 목적으로 발송 대상수를 트래킹하고 있다.)가 변하지 않을 경우 한 채널에 대해 발송이 완료되었다고 간주하고 그 다음 채널을 발송하는 방법으로 해결하였다.</p></li></ul><p>이렇게 거듭된 개선을 거쳐 정리된 최종 구조는 다음과 같다.</p><div class="figure center" style="width:;"><img class="fig-img" src="improvement_3.jpg" alt="3차 개선. a.k.a. 최종 구조"><span class="image-caption">3차 개선. a.k.a. 최종 구조</span><span class="caption">3차 개선. a.k.a. 최종 구조</span></div><ol><li>채널별로 큰 단위로 index를 파티셔닝 하여 병렬 조회할 수 있도록 한다.<br>1-1. 첫 consumer는 채널을 채널 간의 알림 발송 진행을 담당해주고,<br>1-2. redis에 발송 대상수가 변함이 없을 경우 다음 채널을 발송하도록 한다.</li><li>1에서보다 더 작은 단위로 파티셔닝하여 아래 작업을 수행한다.<br>2-1. db에서 user를 조회하고<br>2-2. user를 중복제거 key에 10만단위로 파티셔닝 하여 담는다.<br> ex ) user가 105872 인경우 push:overlapCheck:100000 에, user가 3409572 인 경우 push:overlapCheck:3400000<br>2-3. 2-1에서 가져온 user를 임의 redis key에 담는다.</li><li>중복체크 작업을 수행합니다.<br>3-1. 첫 번째 채널일 경우 중복체크를 하지 않고 바로 발송을 한다.<br>3-2. 첫 번째 채널이 아닐 경우 2-3에서 저장한 redis key의 값을 조회하여 2-2에서 저장한 중복제거 key에 있는지 확인 후 발송 여부를 결정한다.</li></ol><p><strong>▶ 개선 결과</strong></p><table><thead><tr><th>항목</th><th>기존</th><th>1차</th><th>2차</th><th>3차</th></tr></thead><tbody><tr><td>발송 대상수</td><td>약 10,530,000명</td><td>약 10,570,000명</td><td>약 11,120,000명</td><td><font color="red">약 11,240,000명</font></td></tr><tr><td>첫발송</td><td>약 6분</td><td>약 6분</td><td>약 1초</td><td><font color="red">약 1초</font></td></tr><tr><td>마지막 발송</td><td>약 11분</td><td>약 7분</td><td>약 5분 30초</td><td><font color="red">51초</font></td></tr></tbody></table><hr><h3 id="마치며"><a href="#마치며" class="headerlink" title="# 마치며"></a># 마치며</h3><p>결국 처음에 개선 프로젝트 시작 시 정해졌던 목표에 도달할 수 있었다.(발송 대상이 약 100만 명이 더 늘었지만 1분내로 발송 성공)<br>또한 무조건 좋다고 사용하다간 오히려 독이 될 수 있고, 반대로 돌아가는 원리를 잘 알아보고 사용한다면 본인이 원하는 가장 이상적인 결과를 만들 수 있다는 좋은 경험을 얻을 수 있었다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;만약 1번부터 10번까지 번호표가 있는 사람들 총 열명에게 혼자서 동일한 내용의 메일을 보낸다고 가정해보자. 그리고 메일 발송시 한번에 한명에게만 보내야 하는 제한사항이 있을때 과연 당신은 어떤식으로 보내겠는가? 이어서 읽지말고 한번 생각해보자.
    
    </summary>
    
      <category term="tech" scheme="https://taetaetae.github.io/categories/tech/"/>
    
    
      <category term="parallel precess" scheme="https://taetaetae.github.io/tags/parallel-precess/"/>
    
      <category term="redis" scheme="https://taetaetae.github.io/tags/redis/"/>
    
      <category term="rabbitMQ" scheme="https://taetaetae.github.io/tags/rabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>2018 회고 - Coder가 아닌 Programmer로</title>
    <link href="https://taetaetae.github.io/2018/12/31/review-2018/"/>
    <id>https://taetaetae.github.io/2018/12/31/review-2018/</id>
    <published>2018-12-31T12:33:29.000Z</published>
    <updated>2019-05-30T08:14:51.650Z</updated>
    
    <content type="html"><![CDATA[<p>매사에 행동하는 모든것들의 끝자락에서는 그동안 잘한것과 못한것을 다시 생각하며 잘한것은 보다 더 잘할수 있도록 하고 못한것은 왜 못했는지 그리고 어떻게 하면 못한 부분을 고칠수 있을지에 대한 시간을 갖으려고 노력해왔다. 그게 개발이 되었든 게임이 되었든 연인과의 데이트가 되었든 뭐든지. <a id="more"></a>이러한 시간들은 필자에게 큰 인사이트를 얻을 수 있게 되었고 지난 한해를 돌이켜 보자면 개인적으로 계획한 전부를 다 이뤄내지는 못했지만 나름의 많은 경험과 성과를 달성했다고 생각해본다.<br>이제 몇시간 뒤면 올해가 끝나고 새로운 한 해가 시작되는 이 시점에 <code>개발자로써의 회고</code>를 해보며 2018년 정리 및 2019년 목표를 다짐해보자.</p><h4 id="글쓰는-개발자가-되자-개인-블로그-운영"><a href="#글쓰는-개발자가-되자-개인-블로그-운영" class="headerlink" title="# 글쓰는 개발자가 되자. 개인 블로그 운영"></a># 글쓰는 개발자가 되자. 개인 블로그 운영</h4><p>아주 오래전, 동기 형을 통해 <code>개발자가 글을 써야하는 중요성</code>에 대해 절실하게 배우게 되었고 그때부터 블로그를 운영하기 시작하였다. 그 동기형의 말에 조금 더 내 생각을 첨가하자면 글을 쓰다보면 누군가 내 글을 본다는 마음에 내가 알고있는 지식을 보다 더 깊게 공부하게 되고 그것들이 모여 내 개발 히스토리가 만들어 지며 포트폴리오 등 다양하게 활용할 수 있기에 블로그를 운영하는건 정말 좋은 선택지 였던것 같다. 실제로 그냥 구글링 해서 알게된 것과는 또 다른 배움이 있었기 때문이다.<br>회사 일 그리고 개인 공부를 하면서 적어도 한달에 한가지 이상은 배우게 되기 때문에 올해 초 한달에 한개 이상의 글을 쓰기로 결심하였다.(그 달의 글이 없다면 뭔가 놀았거나(?) 미친듯이 바빴거나 아니면 게을렀거나…) 블로그에 글을 쓴 내역을 그래프로 시각화 해보면 아래처럼 총 23개의 글을 작성하였고 월 평균 1.9개의 글을 작성하게 된것을 볼수 있다.</p><blockquote><p>9월달엔 팀 옮기자마자 엄청 바빴고, 11월엔 그 바쁜게 결실을 맺는 시간… 이라 핑계를… (나중에 블로깅 예정, 병렬 프로그래밍 관련)</p></blockquote><div class="figure center" style="width:;"><img class="fig-img" src="post_count.jpg" alt="월별 글 작성수"><span class="image-caption">월별 글 작성수</span><span class="caption">월별 글 작성수</span></div><p>위 결과만을 두고 봤을땐 많으면 많고 적으면 적다고 할 수 있는 결과지만 개인적으로는 자투리 시간을 활용해서 그간 배웠던것, 그리고 경험했지만 내것으로 만들지 못하고 보기만 하며 넘어간것들에 대해 귀찮지만 시간을 투자하고 정리했더라면 더 많은 글을 썼을것 같다는 조금 아쉬운 결과라고 생각이 든다.</p><div class="figure center" style="width:;"><img class="fig-img" src="blog_ga.jpg" alt="주 단위 PV, 누군가 내 글을 보고 있다는것에 뿌듯함"><span class="image-caption">주 단위 PV, 누군가 내 글을 보고 있다는것에 뿌듯함</span><span class="caption">주 단위 PV, 누군가 내 글을 보고 있다는것에 뿌듯함</span></div><p>나름 열심히 글을 쓴 결과일까, GA를 통해 본 필자의 블로그에 유입량이 점점 늘어나는것을 보며 하나를 쓰더라도 좀더 자세히 독자의 입장에서 써야겠다고 다시한번 다짐하게 된다. 다만 글을 “많이” 쓰는것보다 하나를 작성하더라도 원인과 근거를 들어가며 문제를 정확히 파악하는데 집중을 해야하고, 단순 사용법 나열이 아닌 실제로 경험을 해가면서 “내것”으로 만드는 과정이 필요하겠다.</p><h4 id="회사-팀-변경-그리고-토이-프로젝트"><a href="#회사-팀-변경-그리고-토이-프로젝트" class="headerlink" title="# 회사 팀 변경 그리고 토이 프로젝트"></a># 회사 팀 변경 그리고 토이 프로젝트</h4><p>기존에 아무것도 없던 환경에서 서버 발급부터 이런 저런 서비스에 도움이 되는 다양한 모니터링 툴을 개발하며 무사히 서비스를 오픈을 하였고, 약간의 매너리즘이 생겨날 즈음 좋은 기회가 생겨 성격이 전혀 다른 서비스를 하는 팀을 옮기게 되었다. 약간 이직과도 비슷한 느낌으로 팀을 옮기게 되었는데 처음엔 새로운 지식을 습득해야 하는 두려움도 있었고 기존 서비스에 애정이 많아서 고민이 많았지만 벌써 옮긴지 5개월이 지나고 돌이켜보면 올해 가장 잘한 일 중 하나가 아닐까하는 생각이 든다. 전 팀에선 서비스를 운영하는데 그쳤지만 지금 내가 있는 곳은 대용량 서비스를 성능측면에서, 그리고 아키텍쳐 측면에서 보다 효율적으로 개발하는데 집중을 하려는 모습들이 보이기 때문이다. 더불어 팀에 투입되자마자 필자 홀로 기존에 있던 병렬 프로세스를 개선하여 서비스적으로 약 90%의 개선효과를 볼수있었는데 이 부분은 추후 포스팅 할 예정이다.<br>그리고 팀을 옮기기 한두달 전 개인적인 여유시간이 많이 있었고, 다른사람들의 블로그를 보며 챙겨보고 싶은 마음에 <a href="http://daily-devblog.com" target="_blank" rel="noopener">토이 프로젝트</a>를 만들게 되었다. 7월 중순부터 시작했으니 이것도 어느덧 반년이 지나고 있는데 운영을 해가면서 기능을 추가하기 위해 종종 밤을 새는 등 올 한해있어 꽤 많은것을 얻을수 있었던 시간이였다. 간혹 버그가 생겨 메일이 발송 안되면 지인 또는 모르는 분들이 메일로 제보도 해주시고 … 색다른 경험이였다. 자세한 내용 및 후기는 <a href="https://taetaetae.github.io/2018/08/05/daily-dev-blog-1/">개발후기-1</a> 과 <a href="https://taetaetae.github.io/2018/08/09/daily-dev-blog-2/">개발후기-2</a>에서 확인 가능하다. (어서 3편을 쓰고 마무리를 지어야 할텐데…) 그리고 최근에는 <a href="http://daily-devblog.com/archive" target="_blank" rel="noopener">아카이빙</a> 기능을 만들어 과거 글을 조회할수 있도록 만들었는데 2% 부족한 느낌이다… (맘같아서는 형태소 분석을 해서 자동 필터링도 해보고 싶은데…)</p><div class="figure center" style="width:;"><img class="fig-img" src="ddb_graph.jpg" alt="점점 늘어가는 구독자수, AWS 프리티어가 끝나기 전에 뭔가 방법을 찾아야 하는데 ..."><span class="image-caption">점점 늘어가는 구독자수, AWS 프리티어가 끝나기 전에 뭔가 방법을 찾아야 하는데 ...</span><span class="caption">점점 늘어가는 구독자수, AWS 프리티어가 끝나기 전에 뭔가 방법을 찾아야 하는데 ...</span></div><h4 id="공유-및-발표"><a href="#공유-및-발표" class="headerlink" title="# 공유 및 발표"></a># 공유 및 발표</h4><p>3월 즈음 <a href="https://www.popit.kr" target="_blank" rel="noopener">POP it</a> 관리자분께서 회사까지 직접 찾아와 주셔서 만남을 갖고 <a href="https://www.popit.kr/author/taetaetae" target="_blank" rel="noopener">POP it 저자활동</a>을 시작하게 된다. 그리고 비슷한 시점 D2 Hello World 담당자의 제안으로 이전 팀에서 활용했었던 기술에 대해 기고를 하는 영광을 얻게되고 (<a href="https://d2.naver.com/helloworld/3585246" target="_blank" rel="noopener">내 서버에는 누가 들어오는 걸까 - Apache 액세스 로그를 Elastic Stack으로 분석하기</a>, 여러차례 각종 개발 관련 행사에 참여하며 “난 언제쯤 저런 발표를 할수 있을까?” 하는 부러움이 무엇때문인지 “나도 할수있다”는 자신감으로 변화되어 2018 Pycon 행사에서 짧은 5분이였지만 급작스럽게 필자가 만들었던 토이 프로젝트에 대해 약 100~200여명 앞에서 간단히 소개하는 발표를 하게된다. (<a href="https://www.pycon.kr/2018/program/81" target="_blank" rel="noopener">Pycon 라이트닝토크</a>)</p><p><iframe width="560" height="315" src="https://www.youtube.com/embed/e10hVYJHvKU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>작년까지만 해도 전혀 생각하지도 못할 외부활동을 정말 다양하게, 그리고 두려움을 떨쳐내고 회사라는 울타리를 벗어나 바깥세상을 바라볼수 있는 눈을 얻는 좋은 기회였다고 생각이 든다.</p><h4 id="결론-그래서-내년엔"><a href="#결론-그래서-내년엔" class="headerlink" title="# 결론, 그래서 내년엔?"></a># 결론, 그래서 내년엔?</h4><p>숨가쁘게 달려온 2018년. 올해는 무엇보다 외부활동을 많이 하면서 기존에 갖고있던 <code>주니어</code>로써의 개발 마인드를 조금이나마 벗어나며 <code>주니어</code>와 <code>시니어</code> 사이의 포지션으로 한발자국 올라선 기분이다. 예전에는 회사내에 팀장님이나 선배 개발자분들이 시킨일을 하며 <code>감</code>을 받아 먹었다면, 지금은 그 <code>감</code>을 어떻게 따먹는지, 어떤 <code>감</code>이 더 맛있고 어떻게 따먹어야 더 효율적인지 스스로 일어서는 방법에 첫 단추를 낀것 같아 한편으로는 마음이 무겁지만 한편으로는 새로움을 경험하고 배운다는 것에 벅차오르기까지 한다. 또한 기존에는 일반적인 Web Framework인 Spring 만을 가지고 CRUD에 고심했다면 ElasticStack, kafka, RabbitMQ, Redis 등 새로운 기술들을 배우기 시작하면서 새로운것에 대한 두려움 보다는 호기심이 더 커서 스펀지마냥 습득할수 있었던것 같다.<br>새해계획이라면 거창하게 들릴지 모르겠지만 다가오는 2019년엔 Coder 가 아닌 Programmer 가 되고 싶다. (<a href="http://openuiz.blogspot.com/2016/09/vs-vs-vs.html" target="_blank" rel="noopener">관련 좋은 글</a>) 막연하게 들릴지 모르겠지만 회사원이 아닌 개발자로써 나를 발전시키고 공유하며 서로 성장해 가는, 골을 직접 넣진 않지만 그 과정을 빌드업 하는 <code>미드필더</code>같은 역활을 할수있는 개발자가 되고 싶다. 이러한 계획을 달성하기 위해서는 내년에도 올 2018년을 계속 회고해가면서 잘못된 점을 고쳐나가고 잘한점을 상기하며 개발에 임해야 하지 않을까 싶다.<br>2018년, 고생했다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;매사에 행동하는 모든것들의 끝자락에서는 그동안 잘한것과 못한것을 다시 생각하며 잘한것은 보다 더 잘할수 있도록 하고 못한것은 왜 못했는지 그리고 어떻게 하면 못한 부분을 고칠수 있을지에 대한 시간을 갖으려고 노력해왔다. 그게 개발이 되었든 게임이 되었든 연인과의 데이트가 되었든 뭐든지.
    
    </summary>
    
      <category term="blog" scheme="https://taetaetae.github.io/categories/blog/"/>
    
    
      <category term="review" scheme="https://taetaetae.github.io/tags/review/"/>
    
  </entry>
  
</feed>
